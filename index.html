<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Piano Economico â€” Generatore Business Plan</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
body{font-family:'DM Sans',sans-serif;background:linear-gradient(180deg,#f8fafc 0%,#eef2f7 100%);min-height:100vh;color:#111827}
input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{opacity:1}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:#f1f5f9}::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:3px}
.fade-in{animation:fadeIn .3s ease}@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
.pulse{animation:pulse 2s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}
@media(max-width:900px){
  .app-sidebar{display:none!important}
  .app-content{margin-left:0!important;padding:12px!important}
  .v4-mobile-tabs{display:flex!important}
}
@media(max-width:600px){
  .app-content{padding:8px!important}
  div[style*="gridTemplateColumns"]{grid-template-columns:1fr!important}
}
.v4-mobile-tabs{display:none;overflow-x:auto;gap:4px;padding:8px;background:#f3f4f6;border-radius:10px;margin-bottom:12px}
.v4-mobile-tabs button{flex-shrink:0;padding:8px 14px;border:none;border-radius:8px;font-family:'DM Sans',sans-serif;font-size:11px;font-weight:600;cursor:pointer;white-space:nowrap}
</style>
</head>
<body>
<div id="root"></div>
<script>
const {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef
} = React;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const YEARS = [0, 1, 2, 3, 4];
let YL = ["Anno 1", "Anno 2", "Anno 3", "Anno 4", "Anno 5"];
function updateYL(company) {
  const sy = company && company.startYear ? company.startYear : new Date().getFullYear();
  YL[0] = String(sy); YL[1] = String(sy+1); YL[2] = String(sy+2); YL[3] = String(sy+3); YL[4] = String(sy+4);
}
const STEPS = [{
  id: 0,
  label: "Azienda",
  icon: "ðŸ¢",
  desc: "Info generali e scenario"
}, {
  id: 1,
  label: "Ricavi",
  icon: "ðŸ“ˆ",
  desc: "Linee di prodotto/servizio"
}, {
  id: 2,
  label: "Produzione",
  icon: "ðŸ­",
  desc: "Costi diretti e margini"
}, {
  id: 3,
  label: "Personale",
  icon: "ðŸ‘¥",
  desc: "Organico e costi HR"
}, {
  id: 4,
  label: "Costi Op.",
  icon: "ðŸ’¼",
  desc: "Affitti, utenze, marketing"
}, {
  id: 5,
  label: "Investimenti",
  icon: "ðŸ”§",
  desc: "CapEx e ammortamenti"
}, {
  id: 6,
  label: "Ipotesi",
  icon: "âš™ï¸",
  desc: "FiscalitÃ , WC, debito"
}, {
  id: 7,
  label: "Risultati",
  icon: "ðŸ“Š",
  desc: "CE, SP, CF, KPI"
}];
const eY = () => [0, 0, 0, 0, 0];
const eY1 = () => [1, 1, 1, 1, 1];
const DEFAULTS = {
  company: {
    name: "",
    sector: "",
    currency: "EUR",
    yearsCount: 3,
    scenario: "base",
    capitaleSociale: 10000,
    isExisting: false,
    companyType: "nuova_impresa",
    startYear: new Date().getFullYear(),
    sectorTemplate: "altro",
    bilpianoAnno0: null,
    bilpianoAnnoM1: null
  },
  revenueLine: () => ({
    name: "",
    type: "product",
    unitPrice: 0,
    volumes: eY(),
    growthRates: [0, 0.05, 0.05, 0.05, 0.05],
    grossMargin: 0.40
  }),
  hr: () => ({
    role: "",
    type: "direct",
    annualCost: 0,
    count: eY1(),
    growthRate: 0.03
  }),
  opex: () => ({
    name: "",
    category: "general",
    values: eY(),
    growthRate: 0.02,
    isPercentOfRevenue: false,
    percentOfRevenue: 0
  }),
  investment: () => ({
    name: "",
    type: "tangible",
    cost: 0,
    usefulLife: 5,
    year: 0
  }),
  assumptions: {
    vatRate: .22,
    iresRate: .245,
    irapRate: .0497,
    dso: 30,
    dpo: 60,
    dio: 30,
    interestRate: .04,
    debtAmount: eY(),
    debtRepayment: eY(),
    equityInjection: eY(),
    dividendPayout: 0,
    grantAmount: 0,
    grantYears: 5,
    tfrRate: 0.0741,
    taxCreditAmount: 0,
    taxCreditYears: 3,
    debtType: "manual",
    debtDuration: 5,
    openingCash: 0,
    openingDebt: 0,
    openingEquity: 0,
    openingFA: 0,        // Net fixed assets at start (immobilizzazioni nette)
    openingFALife: 5,    // Remaining useful life of existing assets
    openingAR: 0,        // Opening accounts receivable (crediti commerciali)
    openingAP: 0,        // Opening accounts payable (debiti commerciali)
    openingInventory: 0, // Opening inventory (rimanenze)
    openingTFR: 0,       // Opening TFR fund
    openingTaxPayable: 0,// Opening tax liabilities (debiti tributari)
    scenarioMultiplier: {
      base: 1,
      pessimistic: .85,
      optimistic: 1.15
    }
  }
};


// â•â•â• V3: SECTOR TEMPLATES â•â•â•
const SECTOR_TEMPLATES = {
  tech_software: { label: "Software / SaaS / IT", grossMargin: 0.72, dso: 45, dpo: 30, dio: 0, hrOnRevenue: 0.50, ebitdaMargin: 0.18, debtEquity: 0.8 },
  manifattura: { label: "Manifattura / Industria", grossMargin: 0.32, dso: 75, dpo: 60, dio: 45, hrOnRevenue: 0.25, ebitdaMargin: 0.11, debtEquity: 1.5 },
  commercio_ingrosso: { label: "Commercio ingrosso", grossMargin: 0.22, dso: 60, dpo: 45, dio: 30, hrOnRevenue: 0.12, ebitdaMargin: 0.06, debtEquity: 1.8 },
  commercio_dettaglio: { label: "Commercio dettaglio", grossMargin: 0.42, dso: 5, dpo: 45, dio: 30, hrOnRevenue: 0.22, ebitdaMargin: 0.08, debtEquity: 1.2 },
  ristorazione: { label: "Ristorazione / Food", grossMargin: 0.65, dso: 5, dpo: 30, dio: 10, hrOnRevenue: 0.35, ebitdaMargin: 0.12, debtEquity: 1.0 },
  edilizia: { label: "Edilizia / Costruzioni", grossMargin: 0.28, dso: 90, dpo: 90, dio: 20, hrOnRevenue: 0.30, ebitdaMargin: 0.08, debtEquity: 2.0 },
  consulenza: { label: "Consulenza / Servizi prof.", grossMargin: 0.80, dso: 60, dpo: 20, dio: 0, hrOnRevenue: 0.60, ebitdaMargin: 0.15, debtEquity: 0.5 },
  turismo: { label: "Turismo / Ospitalita", grossMargin: 0.55, dso: 15, dpo: 30, dio: 5, hrOnRevenue: 0.35, ebitdaMargin: 0.15, debtEquity: 1.5 },
  agricoltura: { label: "Agricoltura / Agroalimentare", grossMargin: 0.35, dso: 60, dpo: 45, dio: 60, hrOnRevenue: 0.20, ebitdaMargin: 0.10, debtEquity: 1.8 },
  logistica: { label: "Logistica / Trasporti", grossMargin: 0.30, dso: 60, dpo: 45, dio: 5, hrOnRevenue: 0.35, ebitdaMargin: 0.08, debtEquity: 2.0 },
  altro: { label: "Altro settore", grossMargin: 0.40, dso: 45, dpo: 45, dio: 15, hrOnRevenue: 0.30, ebitdaMargin: 0.10, debtEquity: 1.5 }
};

const COMPANY_TYPES = [
  { value: "startup_innovativa", label: "\uD83D\uDE80 Startup Innovativa", desc: "Nessun bilancio storico. Metriche burn rate e runway." },
  { value: "nuova_impresa", label: "\uD83C\uDF31 Nuova Impresa", desc: "Nessun bilancio precedente." },
  { value: "existing", label: "\uD83C\uDFE2 Azienda Esistente", desc: "Carica 1 o 2 bilanci. L'ultimo diventa Anno 0." },
  { value: "crisis", label: "\u26A0\uFE0F In Ristrutturazione", desc: "Piano di risanamento con bilancio storico." }
];

const BILANCIO_TEMPLATE = () => ({
  ricavi: 0, costiEsterni: 0, valoreAggiunto: 0, personale: 0,
  ebitda: 0, ammortamenti: 0, ebit: 0, interessiPassivi: 0,
  risultatoPrimaImposte: 0, imposte: 0, utileNetto: 0,
  immobilizzazioniNette: 0, creditiCommerciali: 0, rimanenze: 0, cassa: 0,
  capitaleSociale: 0, patrimonioNetto: 0,
  debitiFinanziari: 0, debitiCommerciali: 0, tfr: 0,
  dipendenti: 0, annoRiferimento: 0, fonte: ""
});

function getYearLabels(company) {
  const sy = company.startYear || new Date().getFullYear();
  const isEx = company.companyType === "existing" || company.companyType === "crisis";
  const hasBil = company.bilpianoAnno0 && company.bilpianoAnno0.ricavi > 0;
  const hasM1 = company.bilpianoAnnoM1 && company.bilpianoAnnoM1.ricavi > 0;
  const result = { forecast: [], full: [] };
  for (let i = 0; i < 5; i++) result.forecast.push(String(sy + i));
  if (isEx && hasBil) {
    if (hasM1) result.full.push({ year: sy - 2, label: String(sy - 2), type: "storico" });
    result.full.push({ year: sy - 1, label: String(sy - 1), type: "consuntivo" });
  }
  for (let i = 0; i < 5; i++) result.full.push({ year: sy + i, label: String(sy + i), type: "previsionale" });
  return result;
}

function getStepValidation(stepId, company, revenues, hrs, opexItems, investments) {
  switch(stepId) {
    case 0: return company.name ? "ok" : "empty";
    case 1: return revenues.some(r => r.unitPrice > 0 || r.volumes.some(v => v > 0)) ? "ok" : revenues.length > 1 ? "partial" : "empty";
    case 3: return hrs.some(h => h.annualCost > 0) ? "ok" : "empty";
    case 5: return investments.some(i => i.cost > 0) ? "ok" : "empty";
    default: return "ok";
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FORMATTING UTILS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const fmt = (v, d = 0) => {
  if (v == null || isNaN(v)) return "â€”";
  const a = Math.abs(v);
  const f = a.toLocaleString("it-IT", {
    minimumFractionDigits: d,
    maximumFractionDigits: d
  });
  return v < 0 ? `(${f})` : f;
};
const fmtPct = v => {
  if (v == null || isNaN(v)) return "â€”";
  return (v * 100).toFixed(1) + "%";
};
const fmtEur = (v, d = 0) => {
  if (v == null || isNaN(v)) return "â€”";
  return "â‚¬ " + fmt(v, d);
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CALCULATION ENGINE (verified with unit tests)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function computeFinancials(company, revenues, hrs, opexItems, investments, assumptions) {
  updateYL(company);
  const n = company.yearsCount;
  const sm = assumptions.scenarioMultiplier[company.scenario] || 1;
  const revenueByLine = revenues.map(line => {
    const vols = [];
    for (let i = 0; i < 5; i++) {
      if (line.volumes[i] > 0) {
        vols[i] = line.volumes[i];
      } else if (i > 0 && vols[i - 1] > 0) {
        vols[i] = Math.round(vols[i - 1] * (1 + (line.growthRates ? line.growthRates[i] : 0.05)));
      } else {
        vols[i] = 0;
      }
    }
    return YEARS.map((_, i) => vols[i] * line.unitPrice * sm);
  });
  const totalRevenue = YEARS.map((_, i) => revenueByLine.reduce((s, l) => s + (l[i] || 0), 0));
  const cogs = revenues.map((line, li) => revenueByLine[li].map(r => r * (1 - line.grossMargin)));
  const totalCOGS = YEARS.map((_, i) => cogs.reduce((s, l) => s + (l[i] || 0), 0));
  const grossProfit = YEARS.map((_, i) => totalRevenue[i] - totalCOGS[i]);
  const hrCosts = YEARS.map((_, i) => hrs.reduce((s, h) => s + h.annualCost * (h.count[i] || 0) * Math.pow(1 + h.growthRate, i), 0));
  const opexCosts = YEARS.map((_, i) => opexItems.reduce((s, o) => {
    if (o.isPercentOfRevenue) return s + totalRevenue[i] * o.percentOfRevenue;
    if (o.values[i] > 0) return s + o.values[i];
    // Find last manual value before this year
    let base = 0,
      baseYear = 0;
    for (let j = i - 1; j >= 0; j--) {
      if (o.values[j] > 0) {
        base = o.values[j];
        baseYear = j;
        break;
      }
    }
    if (base > 0) return s + base * Math.pow(1 + o.growthRate, i - baseYear);
    return s;
  }, 0));
  const depreciation = YEARS.map((_, i) => {
    // Depreciation from new investments
    let dep = investments.reduce((s, inv) => {
      if (i >= inv.year && inv.usefulLife > 0 && i - inv.year < inv.usefulLife) return s + inv.cost / inv.usefulLife;
      return s;
    }, 0);
    // Depreciation from existing fixed assets (opening FA)
    const oFA = assumptions.openingFA || 0;
    const oLife = assumptions.openingFALife || 5;
    if (oFA > 0 && i < oLife) dep += oFA / oLife;
    return dep;
  });
  const grantIncome = YEARS.map((_, i) => assumptions.grantAmount > 0 && i < assumptions.grantYears ? assumptions.grantAmount / assumptions.grantYears : 0);
  const ebitda = YEARS.map((_, i) => grossProfit[i] - hrCosts[i] - opexCosts[i] + grantIncome[i]);
  const ebit = YEARS.map((_, i) => ebitda[i] - depreciation[i]);
  const netDebtPre = YEARS.map((_, i) => {
    let d = assumptions.openingDebt || 0;
    for (let j = 0; j <= i; j++) d += (assumptions.debtAmount[j] || 0) - (assumptions.debtRepayment[j] || 0);
    return Math.max(0, d);
  });

  // Auto-ammortamento debito (francese: rata costante) - FIX v4: usa copia locale per non mutare state
  const localRepayment = [...assumptions.debtRepayment];
  if (assumptions.debtType === "francese") {
    const dur = assumptions.debtDuration || 5;
    const rate = assumptions.interestRate;
    YEARS.forEach((_, i) => {
      if (assumptions.debtAmount[i] > 0 && rate > 0) {
        const pmt = assumptions.debtAmount[i] * rate * Math.pow(1 + rate, dur) / (Math.pow(1 + rate, dur) - 1);
        for (let y = 1; y <= dur && i + y < 5; y++) {
          const remaining = assumptions.debtAmount[i] * Math.pow(1 + rate, y - 1) - (pmt - assumptions.debtAmount[i] * rate) * ((Math.pow(1 + rate, y - 1) - 1) / rate);
          const intPortion = remaining * rate;
          const capPortion = pmt - intPortion;
          localRepayment[i + y] = (localRepayment[i + y] || 0) + capPortion;
        }
      }
    });
  }

  // Ricalcola netDebt con localRepayment (include ammortamento francese)
  const netDebt = YEARS.map((_, i) => {
    let d = assumptions.openingDebt || 0;
    for (let j = 0; j <= i; j++) d += (assumptions.debtAmount[j] || 0) - (localRepayment[j] || 0);
    return Math.max(0, d);
  });
  const interest = YEARS.map((_, i) => {
    const prev = i > 0 ? netDebt[i - 1] : assumptions.openingDebt || 0;
    return prev * assumptions.interestRate;
  });
  const ebt = YEARS.map((_, i) => ebit[i] - interest[i]);
  const ires = YEARS.map((_, i) => Math.max(0, ebt[i] * assumptions.iresRate));
  // FIX v4: IRAP base = Valore Produzione - Costi Produzione (escluso personale per quota deducibile)
  const irapBase = YEARS.map((_, i) => totalRevenue[i] + grantIncome[i] - totalCOGS[i] - opexCosts[i] - depreciation[i]);
  const irap = YEARS.map((_, i) => Math.max(0, irapBase[i] * assumptions.irapRate));
  const totalTaxGross = YEARS.map((_, i) => ires[i] + irap[i]);
  // Credito d'imposta: riduce le imposte (non genera rimborso)
  const taxCreditPerYear = assumptions.taxCreditAmount > 0 && assumptions.taxCreditYears > 0 ? assumptions.taxCreditAmount / assumptions.taxCreditYears : 0;
  const taxCreditUsed = YEARS.map((_, i) => i < (assumptions.taxCreditYears || 3) ? Math.min(taxCreditPerYear, totalTaxGross[i]) : 0);
  const totalTax = YEARS.map((_, i) => Math.max(0, totalTaxGross[i] - taxCreditUsed[i]));
  const netIncome = YEARS.map((_, i) => ebt[i] - totalTax[i]);

  // TFR: giÃ  incluso in hrCosts, ma deve apparire come passivitÃ  BS
  const tfrShare = (assumptions.tfrRate || 0.0741) / (1 + (assumptions.tfrRate || 0.0741));
  const tfrAccrual = YEARS.map((_, i) => hrCosts[i] * tfrShare);
  const cumTFR = YEARS.map((_, i) => (assumptions.openingTFR || 0) + tfrAccrual.slice(0, i + 1).reduce((s, t) => s + t, 0));
  const dividends = YEARS.map((_, i) => Math.max(0, netIncome[i] * assumptions.dividendPayout));
  const ar = YEARS.map((_, i) => totalRevenue[i] * (1 + assumptions.vatRate) * assumptions.dso / 360);
  const inventory = YEARS.map((_, i) => totalCOGS[i] * assumptions.dio / 360);
  const ap = YEARS.map((_, i) => totalCOGS[i] * (1 + assumptions.vatRate) * assumptions.dpo / 360);
  const totalInvestments = YEARS.map((_, i) => investments.filter(inv => inv.year === i).reduce((s, inv) => s + inv.cost, 0));
  const accDep = YEARS.map((_, i) => depreciation.slice(0, i + 1).reduce((s, d) => s + d, 0));
  const grossFA = YEARS.map((_, i) => totalInvestments.slice(0, i + 1).reduce((s, t) => s + t, 0));
  const netFA = YEARS.map((_, i) => {
    // New investments net of depreciation
    let fa = grossFA[i] - (investments.reduce((s, inv) => {
      if (i >= inv.year && inv.usefulLife > 0) {
        const yearsDepr = Math.min(i - inv.year + 1, inv.usefulLife);
        return s + (inv.cost / inv.usefulLife) * yearsDepr;
      }
      return s;
    }, 0));
    // Existing fixed assets (opening FA) net of accumulated depreciation
    const oFA = assumptions.openingFA || 0;
    const oLife = assumptions.openingFALife || 5;
    if (oFA > 0) {
      const existingDepYears = Math.min(i + 1, oLife);
      fa += oFA - (oFA / oLife) * existingDepYears;
    }
    return Math.max(0, fa);
  });
  const equity = YEARS.map((_, i) => {
    let eq = assumptions.openingEquity || 0;
    for (let j = 0; j <= i; j++) eq += (assumptions.equityInjection[j] || 0) + netIncome[j] - dividends[j];
    return eq;
  });

  // Deferred grant income (risconti passivi): cash received Y1 minus cumulative income recognized
  const grantCashIn = YEARS.map((_, i) => i === 0 ? assumptions.grantAmount : 0);
  const cumGrantIncome = YEARS.map((_, i) => grantIncome.slice(0, i + 1).reduce((s, g) => s + g, 0));
  const deferredGrant = YEARS.map((_, i) => Math.max(0, assumptions.grantAmount - cumGrantIncome[i]));
  const currentLiabilities = YEARS.map((_, i) => ap[i] + totalTax[i] + (assumptions.openingTaxPayable || 0));
  const totalAssetsNoCash = YEARS.map((_, i) => ar[i] + inventory[i] + netFA[i]);
  const totalLiabEq = YEARS.map((_, i) => currentLiabilities[i] + deferredGrant[i] + netDebt[i] + cumTFR[i] + equity[i]);
  const rawCash = YEARS.map((_, i) => totalLiabEq[i] - totalAssetsNoCash[i]);
  // FIX v4: se cassa negativa, modella fido di cassa come passivita corrente
  const revolvingCredit = YEARS.map((_, i) => rawCash[i] < 0 ? Math.abs(rawCash[i]) : 0);
  const totalLiabEqAdj = YEARS.map((_, i) => totalLiabEq[i] + revolvingCredit[i]);
  const cash = YEARS.map((_, i) => Math.max(0, rawCash[i]));
  const totalAssets = YEARS.map((_, i) => totalAssetsNoCash[i] + cash[i]);
  const fundingGap = YEARS.map((_, i) => revolvingCredit[i]);

  // CF Operating: NI + Dep + WC change (relative to opening values for Y1) + grant cash adjustment
  const oAR = assumptions.openingAR || 0;
  const oAP = assumptions.openingAP || 0;
  const oInv = assumptions.openingInventory || 0;
  const cfOperating = YEARS.map((_, i) => {
    const prevAR = i === 0 ? oAR : ar[i - 1];
    const prevInv = i === 0 ? oInv : inventory[i - 1];
    const prevAP = i === 0 ? oAP : ap[i - 1];
    const wcTrade = -(ar[i] - prevAR + inventory[i] - prevInv - (ap[i] - prevAP));
    const wcTax = i === 0 ? totalTax[0] : totalTax[i] - totalTax[i - 1];
    const grantAdj = grantCashIn[i] - grantIncome[i];
    return netIncome[i] + depreciation[i] + tfrAccrual[i] + wcTrade + wcTax + grantAdj;
  });
  const cfInvesting = YEARS.map((_, i) => -totalInvestments[i]);
  // CF Financing: NO grant here (grant cash is captured via operating adjustment)
  const cfFinancing = YEARS.map((_, i) => (assumptions.debtAmount[i] || 0) - (localRepayment[i] || 0) + (assumptions.equityInjection[i] || 0) - dividends[i]);
  const netCF = YEARS.map((_, i) => cfOperating[i] + cfInvesting[i] + cfFinancing[i]);
  const cumCash = YEARS.map((_, i) => (assumptions.openingCash || 0) + netCF.slice(0, i + 1).reduce((s, c) => s + c, 0));
  const grossMarginPct = YEARS.map((_, i) => totalRevenue[i] ? grossProfit[i] / totalRevenue[i] : 0);
  const ebitdaMargin = YEARS.map((_, i) => totalRevenue[i] ? ebitda[i] / totalRevenue[i] : 0);
  const netMargin = YEARS.map((_, i) => totalRevenue[i] ? netIncome[i] / totalRevenue[i] : 0);
  const roe = YEARS.map((_, i) => {
    if (!equity[i]) return null;
    if (equity[i] < 0 && netIncome[i] < 0) return null;
    return netIncome[i] / equity[i];
  });
  const roa = YEARS.map((_, i) => totalAssets[i] ? netIncome[i] / totalAssets[i] : 0);
  const currentRatio = YEARS.map((_, i) => currentLiabilities[i] > 0 ? (ar[i] + inventory[i] + Math.max(0, cash[i])) / currentLiabilities[i] : null);
  const debtRatio = YEARS.map((_, i) => totalAssets[i] ? netDebt[i] / totalAssets[i] : 0);
  const headcount = YEARS.map((_, i) => hrs.reduce((s, h) => s + (h.count[i] || 0), 0));
  const revPerEmp = YEARS.map((_, i) => headcount[i] ? totalRevenue[i] / headcount[i] : 0);
  const revenueCAGR = n > 1 && totalRevenue[0] > 0 ? Math.pow(totalRevenue[n - 1] / totalRevenue[0], 1 / (n - 1)) - 1 : 0;

  /* â”€â”€â”€ KPI AVANZATI (richiesti da banche e investitori) â”€â”€â”€ */

  // DSCR = EBITDA / (Interessi + Quota capitale) â€” la banca lo vuole > 1.2
  const debtService = YEARS.map((_, i) => interest[i] + (localRepayment[i] || 0));
  const dscr = YEARS.map((_, i) => debtService[i] > 0 ? ebitda[i] / debtService[i] : null);

  // FIX v4: DSCR cash-based (EBA Guidelines / Codice Crisi d'Impresa art. 13)
  const dscrCash = YEARS.map((_, i) => debtService[i] > 0 ? cfOperating[i] / debtService[i] : null);

  // Interest Coverage Ratio = EBIT / Interessi â€” misura capacitÃ  di coprire gli oneri finanziari
  const icr = YEARS.map((_, i) => interest[i] > 0 ? ebit[i] / interest[i] : null);

  // PFN = Posizione Finanziaria Netta = Cassa - Debito finanziario (negativo = indebitamento netto)
  const pfn = YEARS.map((_, i) => Math.max(0, cash[i]) - netDebt[i]);

  // Debt/Equity ratio = Debito finanziario / Patrimonio netto
  const debtEquity = YEARS.map((_, i) => equity[i] > 0 ? netDebt[i] / equity[i] : null);

  // Break-Even Point (â‚¬) = Costi Fissi / Margine lordo %
  const fixedCosts = YEARS.map((_, i) => hrCosts[i] + opexCosts[i] + depreciation[i] + interest[i]);
  const bep = YEARS.map((_, i) => grossMarginPct[i] > 0 ? fixedCosts[i] / grossMarginPct[i] : null);
  const bepMargin = YEARS.map((_, i) => bep[i] != null && totalRevenue[i] > 0 ? (totalRevenue[i] - bep[i]) / totalRevenue[i] : null);

  // Cash Conversion Cycle = DSO + DIO - DPO
  const ccc = assumptions.dso + assumptions.dio - assumptions.dpo;

  // Burn rate e Runway (solo se CF operativo negativo)
  const burnRate = YEARS.map((_, i) => cfOperating[i] < 0 ? Math.abs(cfOperating[i]) / 12 : 0);
  const runway = YEARS.map((_, i) => burnRate[i] > 0 ? Math.max(0, cash[i]) / burnRate[i] : null);

  // NWC (Net Working Capital) = Attivo corrente - Passivo corrente
  const nwc = YEARS.map((_, i) => ar[i] + inventory[i] + Math.max(0, cash[i]) - currentLiabilities[i]);

  // Costo del personale / Ricavi (incidenza)
  const hrOnRevenue = YEARS.map((_, i) => totalRevenue[i] > 0 ? hrCosts[i] / totalRevenue[i] : 0);

  // ROI = EBIT / Totale Attivo â€” rendimento del capitale investito
  const roi = YEARS.map((_, i) => totalAssets[i] > 0 ? ebit[i] / totalAssets[i] : null);

  // Payback Period: anno in cui cumCash diventa positivo
  let paybackYear = null;
  for (let i = 0; i < n; i++) {
    if (cumCash[i] >= 0) {
      paybackYear = i;
      break;
    }
  }
  const paybackPeriod = paybackYear;

  // Art. 2447 CC: PN < 1/3 Capitale Sociale
  const art2447 = YEARS.map((_, i) => equity[i] < (company.capitaleSociale || 0) / 3);

  // YoY growth rates
  const revenueGrowth = YEARS.map((_, i) => i > 0 && totalRevenue[i - 1] > 0 ? (totalRevenue[i] - totalRevenue[i - 1]) / totalRevenue[i - 1] : null);
  const ebitdaGrowth = YEARS.map((_, i) => i > 0 && ebitda[i - 1] > 0 ? (ebitda[i] - ebitda[i - 1]) / ebitda[i - 1] : null);

  // Cost-to-Income
  const costToIncome = YEARS.map((_, i) => totalRevenue[i] > 0 ? (totalCOGS[i] + hrCosts[i] + opexCosts[i]) / totalRevenue[i] : null);
  return {
    revenueByLine,
    totalRevenue,
    totalCOGS,
    grossProfit,
    hrCosts,
    opexCosts,
    depreciation,
    grantIncome,
    ebitda,
    ebit,
    interest,
    ebt,
    ires,
    irap,
    totalTax,
    netIncome,
    dividends,
    ar,
    inventory,
    ap,
    netDebt,
    equity,
    cash,
    fundingGap,
    totalAssets,
    netFA,
    currentLiabilities,
    deferredGrant,
    grantCashIn,
    cumTFR,
    tfrAccrual,
    taxCreditUsed,
    cfOperating,
    cfInvesting,
    cfFinancing,
    netCF,
    cumCash,
    totalInvestments,
    grossFA,
    accDep,
    totalLiabEq,
    grossMarginPct,
    ebitdaMargin,
    netMargin,
    roe,
    roa,
    currentRatio,
    debtRatio,
    headcount,
    revPerEmp,
    revenueCAGR,
    dscr,
    icr,
    pfn,
    debtEquity,
    bep,
    bepMargin,
    ccc,
    burnRate,
    runway,
    nwc,
    fixedCosts,
    debtService,
    hrOnRevenue,
    roi,
    paybackPeriod,
    art2447,
    revenueGrowth,
    ebitdaGrowth,
    costToIncome,
    localRepayment,
    dscrCash,
    revolvingCredit,
    totalLiabEqAdj,
    irapBase,

    // V3: CE Riclassificato a Valore Aggiunto
    ceRiclass: YEARS.map((_, i) => ({
      valoreProduzione: totalRevenue[i] + (grantIncome[i] || 0),
      costiEsterni: totalCOGS[i] + opexCosts[i],
      valoreAggiunto: totalRevenue[i] + (grantIncome[i] || 0) - totalCOGS[i] - opexCosts[i],
      costoPersonale: hrCosts[i],
      mol: totalRevenue[i] + (grantIncome[i] || 0) - totalCOGS[i] - opexCosts[i] - hrCosts[i],
      ammortamenti: depreciation[i],
      risultatoOperativo: ebit[i],
      oneriFin: interest[i],
      risultatoAnteImposte: ebt[i],
      imposte: totalTax[i],
      risultatoNetto: netIncome[i]
    })),

    // V3: SP Riclassificato
    spRiclass: YEARS.map((_, i) => ({
      attivoFisso: netFA[i], creditiComm: ar[i], rimanenze: inventory[i],
      liquidita: Math.max(0, cash[i]),
      attivoCircolante: ar[i] + inventory[i] + Math.max(0, cash[i]),
      totaleAttivo: totalAssets[i],
      debitiComm: ap[i], passivoCorrente: currentLiabilities[i],
      debitiMLT: netDebt[i], tfrFondo: cumTFR[i], riscontiPassivi: deferredGrant[i],
      patrimonioNetto: equity[i],
      cin: netFA[i] + ar[i] + inventory[i] - currentLiabilities[i],
      ccn: ar[i] + inventory[i] + Math.max(0, cash[i]) - currentLiabilities[i]
    })),

    // V3: Anno 0 from bilancio
    anno0: company.bilpianoAnno0 || null,
    annoM1: company.bilpianoAnnoM1 || null,

    // V3: Delta % Anno 0 -> Anno 1
    delta0to1: (() => {
      const b = company.bilpianoAnno0;
      if (!b || !b.ricavi) return null;
      const pc = (nv, ov) => ov > 0 ? (nv - ov) / ov : null;
      return { ricavi: pc(totalRevenue[0], b.ricavi), ebitda: pc(ebitda[0], b.ebitda), utile: pc(netIncome[0], b.utileNetto), personale: pc(hrCosts[0], b.personale) };
    })(),

    // V3: Sector Benchmarks
    benchmarks: (() => {
      const tmpl = SECTOR_TEMPLATES[company.sectorTemplate] || SECTOR_TEMPLATES.altro;
      const li = n - 1;
      return { sector: tmpl, comparison: [
        { kpi: "Margine Lordo", actual: grossMarginPct[li], benchmark: tmpl.grossMargin, unit: "pct" },
        { kpi: "EBITDA Margin", actual: ebitdaMargin[li], benchmark: tmpl.ebitdaMargin, unit: "pct" },
        { kpi: "Incidenza HR/Ricavi", actual: hrOnRevenue[li], benchmark: tmpl.hrOnRevenue, unit: "pct", invert: true },
        { kpi: "Debt/Equity", actual: debtEquity[li], benchmark: tmpl.debtEquity, unit: "dec", invert: true },
        { kpi: "DSO (gg incasso)", actual: assumptions.dso, benchmark: tmpl.dso, unit: "gg", invert: true },
        { kpi: "DPO (gg pagamento)", actual: assumptions.dpo, benchmark: tmpl.dpo, unit: "gg" }
      ]};
    })()
  };
}
const sanitizeName = s => (s || "azienda").replace(/[^a-zA-Z0-9Ã€-Ãº_\- ]/g, "").replace(/\s+/g, "_").substring(0, 50);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MONTE CARLO SIMULATION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function runMonteCarlo(company, revenues, hrs, opexItems, investments, assumptions, iterations = 1000) {
  const results = { netIncome: [], ebitda: [], cumCash: [], dscr: [], revenue: [] };
  const n = company.yearsCount;
  const last = n - 1;
  
  for (let iter = 0; iter < iterations; iter++) {
    // Random perturbations: normal-ish distribution via Box-Muller
    const randNorm = (mean, std) => {
      const u1 = Math.random(), u2 = Math.random();
      return mean + std * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    };
    
    // Perturb revenues: volumes Â±25%, prices Â±10%
    const pertRevenues = revenues.map(r => ({
      ...r,
      volumes: r.volumes.map(v => Math.max(0, Math.round(v * randNorm(1, 0.15)))),
      unitPrice: Math.max(0, r.unitPrice * randNorm(1, 0.07)),
      grossMargin: Math.min(0.99, Math.max(0.01, r.grossMargin + randNorm(0, 0.05)))
    }));
    
    // Perturb HR costs Â±8%
    const pertHrs = hrs.map(h => ({
      ...h,
      annualCost: Math.max(0, h.annualCost * randNorm(1, 0.05))
    }));
    
    // Perturb OpEx Â±12%
    const pertOpex = opexItems.map(o => ({
      ...o,
      values: o.values.map(v => Math.max(0, v * randNorm(1, 0.08)))
    }));
    
    try {
      const f = computeFinancials(company, pertRevenues, pertHrs, pertOpex, investments, { ...assumptions });
      results.revenue.push(f.totalRevenue[last]);
      results.netIncome.push(f.netIncome[last]);
      results.ebitda.push(f.ebitda[last]);
      results.cumCash.push(f.cumCash[last]);
      if (f.dscr[last] != null) results.dscr.push(f.dscr[last]);
    } catch(e) { /* skip failed iterations */ }
  }
  
  const stats = (arr) => {
    if (!arr.length) return { mean: 0, p5: 0, p25: 0, p50: 0, p75: 0, p95: 0, min: 0, max: 0, std: 0, probPositive: 0 };
    const sorted = [...arr].sort((a, b) => a - b);
    const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
    const variance = arr.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / arr.length;
    return {
      mean, std: Math.sqrt(variance),
      p5: sorted[Math.floor(arr.length * 0.05)],
      p25: sorted[Math.floor(arr.length * 0.25)],
      p50: sorted[Math.floor(arr.length * 0.50)],
      p75: sorted[Math.floor(arr.length * 0.75)],
      p95: sorted[Math.floor(arr.length * 0.95)],
      min: sorted[0], max: sorted[sorted.length - 1],
      probPositive: arr.filter(v => v > 0).length / arr.length
    };
  };
  
  // Build histogram buckets for key metric
  const buildHist = (arr, buckets = 25) => {
    if (!arr.length) return [];
    const min = Math.min(...arr), max = Math.max(...arr);
    if (min === max) return [{ x: min, count: arr.length }];
    const step = (max - min) / buckets;
    const bins = Array.from({ length: buckets }, (_, i) => ({ x: min + step * (i + 0.5), count: 0 }));
    arr.forEach(v => { const idx = Math.min(buckets - 1, Math.floor((v - min) / step)); bins[idx].count++; });
    return bins;
  };
  
  return {
    revenue: { ...stats(results.revenue), hist: buildHist(results.revenue) },
    netIncome: { ...stats(results.netIncome), hist: buildHist(results.netIncome) },
    ebitda: { ...stats(results.ebitda), hist: buildHist(results.ebitda) },
    cumCash: { ...stats(results.cumCash), hist: buildHist(results.cumCash) },
    dscr: { ...stats(results.dscr), hist: buildHist(results.dscr) },
    iterations: results.revenue.length
  };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SENSITIVITY ANALYSIS (Tornado)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function runSensitivity(company, revenues, hrs, opexItems, investments, assumptions) {
  const n = company.yearsCount;
  const last = n - 1;
  const baseF = computeFinancials(company, revenues, hrs, opexItems, investments, assumptions);
  const baseEBITDA = baseF.ebitda[last];
  const baseNI = baseF.netIncome[last];
  const baseCash = baseF.cumCash[last];
  
  const factors = [
    { label: "Volumi vendita", pct: 0.20, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, volumes: r.volumes.map(v => Math.round(v * mult)) }))
    })},
    { label: "Prezzi unitari", pct: 0.15, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, unitPrice: r.unitPrice * mult }))
    })},
    { label: "Margine lordo", pct: 0.10, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, grossMargin: Math.min(0.99, r.grossMargin * mult) }))
    })},
    { label: "Costo personale", pct: 0.15, apply: (mult) => ({
      hrs: hrs.map(h => ({ ...h, annualCost: h.annualCost * mult }))
    })},
    { label: "Costi operativi", pct: 0.20, apply: (mult) => ({
      opexItems: opexItems.map(o => ({ ...o, values: o.values.map(v => v * mult) }))
    })},
    { label: "Tasso interesse", pct: 0.30, apply: (mult) => ({
      assumptions: { ...assumptions, interestRate: assumptions.interestRate * mult }
    })},
    { label: "DSO (gg incasso)", pct: 0.30, apply: (mult) => ({
      assumptions: { ...assumptions, dso: Math.round(assumptions.dso * mult) }
    })}
  ];
  
  return factors.map(f => {
    const upMods = f.apply(1 + f.pct);
    const downMods = f.apply(1 - f.pct);
    
    const upF = computeFinancials(company, 
      upMods.revenues || revenues, upMods.hrs || hrs, upMods.opexItems || opexItems,
      investments, upMods.assumptions || assumptions);
    const downF = computeFinancials(company,
      downMods.revenues || revenues, downMods.hrs || hrs, downMods.opexItems || opexItems,
      investments, downMods.assumptions || assumptions);
    
    return {
      label: f.label,
      pct: f.pct,
      ebitda: { up: upF.ebitda[last], down: downF.ebitda[last], base: baseEBITDA },
      netIncome: { up: upF.netIncome[last], down: downF.netIncome[last], base: baseNI },
      cumCash: { up: upF.cumCash[last], down: downF.cumCash[last], base: baseCash }
    };
  }).sort((a, b) => Math.abs(b.ebitda.up - b.ebitda.down) - Math.abs(a.ebitda.up - a.ebitda.down));
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BILANCIO IMPORT PARSER (PDF + Excel/CSV)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Parse a number from Italian format: "1.551.281" or "1.551.281,00" or "567.515"
function parseItalianNumber(str) {
  if (!str || typeof str !== "string") return 0;
  // Remove currency symbols, spaces, euro signs
  let s = str.replace(/[â‚¬\s]/g, "").trim();
  if (!s || s === "-" || s === "0") return 0;
  // Handle negative: (123) or -123
  const isNeg = s.startsWith("(") || s.startsWith("-");
  s = s.replace(/[()]/g, "").replace(/^-/, "");
  // Italian format: dots as thousands separators, comma as decimal
  // Check if it looks like Italian format (has dots followed by 3 digits)
  if (/^\d{1,3}(\.\d{3})*(,\d+)?$/.test(s)) {
    s = s.replace(/\./g, "").replace(",", ".");
  } else {
    // Fallback: try removing commas as thousands
    s = s.replace(/,/g, "");
  }
  const val = parseFloat(s);
  return isNaN(val) ? 0 : (isNeg ? -val : val);
}

// Extract text from PDF using pdf.js
async function extractPdfText(file) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const pages = [];
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    // Reconstruct lines by grouping items by Y coordinate
    const items = textContent.items.map(item => ({
      text: item.str,
      x: Math.round(item.transform[4]),
      y: Math.round(item.transform[5]),
      width: item.width
    }));
    // Group by Y (with tolerance of 3px)
    const lines = {};
    items.forEach(item => {
      const yKey = Math.round(item.y / 3) * 3;
      if (!lines[yKey]) lines[yKey] = [];
      lines[yKey].push(item);
    });
    // Sort lines top-to-bottom (higher Y = higher on page in PDF coords, so reverse)
    const sortedLines = Object.entries(lines)
      .sort(([a], [b]) => Number(b) - Number(a))
      .map(([_, items]) => {
        items.sort((a, b) => a.x - b.x);
        return items;
      });
    pages.push(sortedLines);
  }
  return pages;
}

// Main PDF bilancio parser â€” looks for specific patterns in the Italian "bilancio abbreviato"
function parseBilancioPdfData(pages) {
  const data = { _raw: {}, _source: "pdf" };
  
  // Flatten all pages into labeled lines: [{label, values}]
  const allLines = [];
  pages.forEach(page => {
    page.forEach(lineItems => {
      const fullText = lineItems.map(i => i.text).join(" ").trim();
      if (!fullText || fullText.length < 2) return;
      
      // Try to extract label (left part) and numeric values (right part)
      // In bilancio PDFs, typically: "Label text    123.456    78.901"
      const parts = [];
      let label = "";
      let nums = [];
      
      // Find all number-like tokens
      const tokens = fullText.split(/\s{2,}|\t/);
      if (tokens.length >= 2) {
        // First meaningful non-number token is label
        let labelParts = [];
        tokens.forEach(t => {
          const cleaned = t.trim();
          if (!cleaned) return;
          // Check if it looks like a number
          const testNum = cleaned.replace(/[â‚¬\s]/g, "");
          if (/^[-\(]?\d{1,3}([.\s]\d{3})*(,\d+)?\)?$/.test(testNum) || /^[-\(]?\d+\)?$/.test(testNum)) {
            nums.push(parseItalianNumber(cleaned));
          } else if (/^\d+$/.test(testNum) && parseInt(testNum) > 1900 && parseInt(testNum) < 2100) {
            // Year â€” skip
          } else {
            labelParts.push(cleaned);
          }
        });
        label = labelParts.join(" ").trim();
      } else {
        label = fullText;
      }
      
      // Also try splitting by individual items with X position
      if (nums.length === 0 && lineItems.length >= 2) {
        const sorted = [...lineItems].sort((a, b) => a.x - b.x);
        let labelItems = [];
        let numItems = [];
        // Items on the right half are likely numbers
        const midX = Math.max(...sorted.map(i => i.x)) * 0.45;
        sorted.forEach(item => {
          const t = item.text.trim();
          if (!t) return;
          const testNum = t.replace(/[â‚¬\s.]/g, "").replace(",", ".");
          if (item.x > midX && (/^\d/.test(t) || t.startsWith("-") || t.startsWith("("))) {
            const parsed = parseItalianNumber(t);
            if (parsed !== 0 || t === "0") numItems.push(parsed);
          } else {
            labelItems.push(t);
          }
        });
        if (numItems.length > 0 && nums.length === 0) {
          nums = numItems;
          if (labelItems.length > 0) label = labelItems.join(" ").trim();
        }
      }
      
      if (label) {
        allLines.push({ label, values: nums, fullText });
      }
    });
  });
  
  // Now match known bilancio patterns
  const find = (patterns, lines) => {
    for (const line of lines) {
      const l = line.label.toLowerCase().replace(/\s+/g, " ");
      for (const pat of patterns) {
        if (typeof pat === "string" ? l.includes(pat) : pat.test(l)) {
          const val = line.values[0]; // Current year (first column)
          if (val && val !== 0) return { value: val, prev: line.values[1] || 0, label: line.label };
        }
      }
    }
    return null;
  };
  
  // â”€â”€â”€ STATO PATRIMONIALE â”€â”€â”€
  // Attivo
  const totAttivo = find(["totale attivo"], allLines);
  if (totAttivo) data.totaleAttivo = totAttivo.value;
  
  const immImmat = find(["immobilizzazioni immateriali", /^i\s*-\s*immobilizzazioni immateriali/], allLines);
  if (immImmat) data.immobilizzazioniImmateriali = immImmat.value;
  
  const immMat = find(["immobilizzazioni materiali", /^ii\s*-\s*immobilizzazioni materiali/], allLines);
  if (immMat) data.immobilizzazioniMateriali = immMat.value;
  
  const totImm = find(["totale immobilizzazioni (b)", "totale immobilizzazioni"], allLines);
  if (totImm) data.immobilizzazioni = totImm.value;
  
  const disponLiquide = find(["disponibilitÃ  liquide", /^iv\s*-\s*disponibilit/], allLines);
  if (disponLiquide) data.cassa = disponLiquide.value;
  
  const totCrediti = find(["totale crediti"], allLines);
  const creditiEntro = find(["esigibili entro l'esercizio successivo"], allLines);
  if (creditiEntro && !totCrediti) data.creditiCommerciali = creditiEntro.value;
  if (totCrediti) data.creditiTotali = totCrediti.value;
  
  const rimanenze = find([/^i\s*-\s*rimanenze/, "rimanenze"], allLines);
  if (rimanenze) data.rimanenze = rimanenze.value;
  
  // Passivo
  const capitale = find(["capitale", /^i\s*-\s*capitale/], allLines);
  if (capitale) data.capitaleSociale = capitale.value;
  
  const totPN = find(["totale patrimonio netto"], allLines);
  if (totPN) data.patrimonioNetto = totPN.value;
  
  const utileEserc = find([/utile.*dell'esercizio/, /^ix\s*-\s*utile/], allLines);
  if (utileEserc) data.utileEsercizio = utileEserc.value;
  
  const tfr = find(["trattamento di fine rapporto", /^c\)\s*trattamento/], allLines);
  if (tfr) data.tfr = tfr.value;
  
  const totDebiti = find(["totale debiti"], allLines);
  if (totDebiti) data.debitiTotali = totDebiti.value;
  
  // Dettaglio debiti
  const debitiBanche = find(["debiti verso banche"], allLines);
  if (debitiBanche) data.debitiFinanziari = debitiBanche.value;
  
  const debitiFornitori = find(["debiti verso fornitori"], allLines);
  if (debitiFornitori) data.debitiCommerciali = debitiFornitori.value;
  
  const debitiSoci = find(["debiti verso soci"], allLines);
  if (debitiSoci) data.debitiVersoSoci = debitiSoci.value;
  
  const debitiTributari = find(["debiti tributari"], allLines);
  if (debitiTributari) data.debitiTributari = debitiTributari.value;
  
  // â”€â”€â”€ CONTO ECONOMICO â”€â”€â”€
  const ricavi = find(["ricavi delle vendite e delle prestazioni", /^1\)\s*ricavi/], allLines);
  if (ricavi) data.ricavi = ricavi.value;
  
  const valProduzione = find(["totale valore della produzione"], allLines);
  if (valProduzione) data.valoreProduzione = valProduzione.value;
  
  // Costi
  const materiePrime = find(["per materie prime", /^6\)\s*per materie/], allLines);
  if (materiePrime) data.materiePrime = materiePrime.value;
  
  const servizi = find(["per servizi", /^7\)\s*per servizi/], allLines);
  if (servizi) data.costiServizi = servizi.value;
  
  const godimento = find(["godimento di beni di terzi", /^8\)\s*per godimento/], allLines);
  if (godimento) data.godimentoBeni = godimento.value;
  
  const totPersonale = find(["totale costi per il personale"], allLines);
  const personale = find([/^9\)\s*per il personale/], allLines);
  if (totPersonale) data.personale = totPersonale.value;
  else if (personale) data.personale = personale.value;
  
  const salari = find(["salari e stipendi", /^a\)\s*salari/], allLines);
  if (salari) data.salariStipendi = salari.value;
  
  const oneriSociali = find(["oneri sociali", /^b\)\s*oneri sociali/], allLines);
  if (oneriSociali) data.oneriSociali = oneriSociali.value;
  
  const totAmm = find(["totale ammortamenti e svalutazioni"], allLines);
  if (totAmm) data.ammortamenti = totAmm.value;
  
  const ammImmat = find(["ammortamento delle immobilizzazioni immateriali", /^a\)\s*ammortamento.*immateriali/], allLines);
  if (ammImmat) data.ammortamentiImmateriali = ammImmat.value;
  
  const ammMat = find(["ammortamento delle immobilizzazioni materiali", /^b\)\s*ammortamento.*materiali/], allLines);
  if (ammMat) data.ammortamentiMateriali = ammMat.value;
  
  const oneriDiversi = find(["oneri diversi di gestione", /^14\)\s*oneri diversi/], allLines);
  if (oneriDiversi) data.oneriDiversi = oneriDiversi.value;
  
  const totCostiProd = find(["totale costi della produzione"], allLines);
  if (totCostiProd) data.costiProduzione = totCostiProd.value;
  
  const diffVP = find(["differenza tra valore e costi della produzione"], allLines);
  if (diffVP) data.margineOperativo = diffVP.value;
  
  const interessiPassivi = find(["totale interessi e altri oneri finanziari", "interessi e altri oneri finanziari"], allLines);
  if (interessiPassivi) data.interessiPassivi = interessiPassivi.value;
  
  const risultatoPrimaImposte = find(["risultato prima delle imposte"], allLines);
  if (risultatoPrimaImposte) data.risultatoPrimaImposte = risultatoPrimaImposte.value;
  
  const imposte = find(["totale delle imposte sul reddito"], allLines);
  if (imposte) data.imposte = imposte.value;
  
  const utileNetto = find([/^21\)\s*utile/, "utile (perdita) dell'esercizio"], allLines);
  if (utileNetto) data.utileNetto = utileNetto.value;
  
  // Contributi
  const contributi = find(["contributi in conto esercizio"], allLines);
  if (contributi) data.contributi = contributi.value;
  
  const altriRicavi = find(["totale altri ricavi e proventi"], allLines);
  if (altriRicavi) data.altriRicavi = altriRicavi.value;
  
  // Incrementi per lavori interni  
  const incremInterni = find(["incrementi di immobilizzazioni per lavori interni", /^4\)\s*incrementi/], allLines);
  if (incremInterni) data.incrementiInterni = incremInterni.value;
  
  // â”€â”€â”€ DATI ANAGRAFICI (dalla nota integrativa) â”€â”€â”€
  // Cerca "dipendenti" con numero
  const dipendenti = find(["impiegati", "totale dipendenti"], allLines);
  if (dipendenti) data.dipendenti = Math.round(Math.abs(dipendenti.value));
  
  // Cerca nella nota anche testo libero
  allLines.forEach(line => {
    const l = line.label.toLowerCase();
    // Dipendenti from text
    if (!data.dipendenti && (l.includes("dipendenti") || l.includes("organico")) && line.values.length > 0) {
      const v = Math.abs(line.values[0]);
      if (v > 0 && v < 1000) data.dipendenti = Math.round(v);
    }
    // Ragione sociale
    if (!data.ragioneSociale && (l.includes("sede in") || l.includes("ragione sociale"))) {
      // Try to find company name from nearby lines
    }
  });
  
  // Derive COGS if not explicit
  if (!data.cogs) {
    data.cogs = (data.materiePrime || 0) + (data.rimanenze || 0);
  }
  
  // Derive total operating costs (servizi + godimento + oneri diversi)
  data.costiOperativi = (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
  
  // Compute EBITDA
  if (data.margineOperativo && data.ammortamenti) {
    data.ebitda = data.margineOperativo + (data.ammortamenti || 0);
  }
  
  // Store raw for debug
  data._allLines = allLines.length;
  
  return data;
}

// Excel/CSV parser (improved)
function parseBilancioExcel(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const wb = XLSX.read(e.target.result, { type: "array" });
        const data = { _source: "excel" };
        
        wb.SheetNames.forEach(name => {
          const ws = wb.Sheets[name];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
          
          rows.forEach((row) => {
            const label = String(row[0] || "").toLowerCase().trim();
            // Try multiple columns for the value
            let val = 0;
            for (let c = 1; c <= 4; c++) {
              const candidate = parseItalianNumber(String(row[c] || ""));
              if (candidate !== 0) { val = candidate; break; }
            }
            
            if (label.includes("ricavi delle vendite") || (label.includes("ricavi") && label.includes("prestazioni"))) data.ricavi = val;
            else if (label.includes("totale valore della produzione")) data.valoreProduzione = val;
            else if (label.includes("totale costi della produzione")) data.costiProduzione = val;
            else if (label.includes("per materie prime")) data.materiePrime = val;
            else if (label.match(/^per servizi|^7\)/)) data.costiServizi = val;
            else if (label.includes("godimento")) data.godimentoBeni = val;
            else if (label.includes("totale costi per il personale")) data.personale = val;
            else if (label.includes("salari e stipendi")) data.salariStipendi = val;
            else if (label.includes("totale ammortamenti")) data.ammortamenti = val;
            else if (label.includes("oneri diversi")) data.oneriDiversi = val;
            else if (label.includes("differenza tra valore e costi")) data.margineOperativo = val;
            else if (label.includes("interessi e altri oneri")) data.interessiPassivi = val;
            else if (label.includes("utile") && label.includes("esercizio") && !label.includes("prima")) data.utileNetto = val;
            else if (label.includes("totale patrimonio netto")) data.patrimonioNetto = val;
            else if (label.includes("capitale") && !label.includes("circolante")) data.capitaleSociale = val;
            else if (label.includes("disponibilitÃ  liquide") && label.includes("totale")) data.cassa = val;
            else if (label.includes("debiti verso banche")) data.debitiFinanziari = val;
            else if (label.includes("debiti verso fornitori")) data.debitiCommerciali = val;
            else if (label.includes("totale debiti")) data.debitiTotali = val;
            else if (label.includes("totale attivo")) data.totaleAttivo = val;
            else if (label.includes("totale immobilizzazioni")) data.immobilizzazioni = val;
            else if (label.includes("trattamento di fine rapporto")) data.tfr = val;
            else if (label.includes("crediti verso clienti")) data.creditiCommerciali = val;
            else if (label.includes("totale crediti")) data.creditiTotali = val;
            else if (label.includes("dipendenti") || label.includes("organico")) {
              if (val > 0 && val < 1000) data.dipendenti = Math.round(val);
            }
          });
        });
        
        data.costiOperativi = (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
        if (!data.cogs) data.cogs = data.materiePrime || 0;
        if (data.margineOperativo && data.ammortamenti) data.ebitda = data.margineOperativo + data.ammortamenti;
        
        resolve(data);
      } catch (err) {
        reject(new Error("Impossibile leggere il file Excel: " + err.message));
      }
    };
    reader.onerror = () => reject(new Error("Errore lettura file"));
    reader.readAsArrayBuffer(file);
  });
}

// Unified parse function (detects file type)
async function parseBilancioFile(file) {
  const ext = file.name.toLowerCase().split(".").pop();
  
  if (ext === "pdf") {
    const pages = await extractPdfText(file);
    return parseBilancioPdfData(pages);
  } else if (["xlsx", "xls", "csv"].includes(ext)) {
    return await parseBilancioExcel(file);
  } else {
    throw new Error("Formato non supportato. Usa PDF, XLSX, XLS o CSV.");
  }
}

// Apply parsed bilancio data to the business plan form
function applyBilancioData(data, setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company) {
  // Company
  if (data.capitaleSociale) setCompany(c => ({ ...c, capitaleSociale: data.capitaleSociale }));
  
  /* â”€â”€â”€ REVENUE + GROSS MARGIN â”€â”€â”€
     Strategy: back-calculate grossMargin from actual EBITDA so the model
     reproduces the bilancio results correctly.
     
     For service companies (like software/consulting), "costi per servizi" (B.7)
     is effectively COGS, but it also gets mixed with other costs. Instead of
     guessing the COGS split, we derive grossMargin from:
       grossMargin = (EBITDA + HR + overheadOpEx) / ricavi
     This guarantees the model EBITDA matches the real bilancio.
  */
  const ricavi = data.ricavi || 0;
  if (ricavi > 0) {
    let grossMargin = 0.50; // default fallback
    
    // Best method: derive from actual EBITDA
    const realEBITDA = data.ebitda || (data.margineOperativo && data.ammortamenti 
      ? data.margineOperativo + data.ammortamenti : null);
    const overheadOpEx = (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
    const hrCost = data.personale || 0;
    
    if (realEBITDA) {
      // grossMargin = (EBITDA + HR + OpEx) / Ricavi
      const neededGrossProfit = realEBITDA + hrCost + overheadOpEx;
      grossMargin = Math.max(0.10, Math.min(0.98, neededGrossProfit / ricavi));
    } else if (data.costiServizi) {
      // Fallback: treat servizi as COGS
      const totalCOGS = (data.materiePrime || 0) + (data.costiServizi || 0) + (data.rimanenze || 0);
      grossMargin = Math.max(0.10, Math.min(0.95, 1 - totalCOGS / ricavi));
    } else if (data.materiePrime) {
      grossMargin = Math.max(0.10, Math.min(0.95, 1 - data.materiePrime / ricavi));
    }
    
    setRevenues([{
      ...DEFAULTS.revenueLine(),
      name: "Ricavi vendite e prestazioni (da bilancio)",
      type: "service",
      unitPrice: 1,
      volumes: [ricavi, 0, 0, 0, 0],
      growthRates: [0, 0.08, 0.08, 0.06, 0.06],
      grossMargin: Math.round(grossMargin * 1000) / 1000
    }]);
  }
  
  // HR
  if (data.personale) {
    const nDip = data.dipendenti || 1;
    const costoMedio = Math.round(data.personale / nDip);
    setHrs([{
      ...DEFAULTS.hr(),
      role: `Organico (${nDip} dipendenti da bilancio)`,
      type: "employee",
      annualCost: costoMedio,
      growthRate: 0.02,
      count: [nDip, nDip, nDip + 1, nDip + 1, nDip + 2]
    }]);
  }
  
  /* â”€â”€â”€ OPERATING COSTS â”€â”€â”€
     Only truly "overhead" costs go here: godimento beni (rent/leasing)
     and oneri diversi di gestione. Costi per servizi (B.7) is absorbed
     into the grossMargin calculation above, to avoid double-counting.
  */
  const opexItems = [];
  if (data.godimentoBeni) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Godimento beni di terzi (affitti, leasing)", category: "rent", values: [data.godimentoBeni, 0, 0, 0, 0], growthRate: 0.02 });
  }
  if (data.oneriDiversi) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Oneri diversi di gestione", category: "other", values: [data.oneriDiversi, 0, 0, 0, 0], growthRate: 0.02 });
  }
  // Fallback if no detail available
  if (opexItems.length === 0 && data.costiOperativi) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Costi operativi (da bilancio)", values: [data.costiOperativi, 0, 0, 0, 0], growthRate: 0.03 });
  }
  if (opexItems.length > 0) setOpexItems(opexItems);
  
  // Do NOT import existing immobilizzazioni as new investments!
  // Existing fixed assets are handled via openingFA in assumptions.
  // This avoids inflated depreciation. Only new future investments should go in the investments array.
  setInvestments([]);
  
  // Assumptions
  setAssumptions(a => {
    const newA = { ...a };
    // Opening balances (from bilancio = "Anno 0")
    if (data.cassa) newA.openingCash = data.cassa;
    if (data.debitiFinanziari) {
      newA.openingDebt = data.debitiFinanziari;
      newA.debtAmount = [0, 0, 0, 0, 0];
    }
    if (data.patrimonioNetto) newA.openingEquity = data.patrimonioNetto;
    if (data.tfr) newA.openingTFR = data.tfr;
    if (data.debitiTributari) newA.openingTaxPayable = data.debitiTributari;
    
    // Fixed assets: use net book value and estimate remaining life from actual depreciation
    const immTot = (data.immobilizzazioniImmateriali || 0) + (data.immobilizzazioniMateriali || 0);
    if (immTot > 0) {
      newA.openingFA = immTot;
      const annualDep = (data.ammortamentiImmateriali || 0) + (data.ammortamentiMateriali || 0) || (data.ammortamenti || 0);
      if (annualDep > 0) {
        newA.openingFALife = Math.max(2, Math.round(immTot / annualDep));
      } else {
        newA.openingFALife = 5;
      }
    }
    
    // Working capital opening values for correct delta calculations
    if (data.creditiCommerciali) newA.openingAR = data.creditiCommerciali;
    else if (data.creditiTotali) newA.openingAR = data.creditiTotali;
    if (data.debitiCommerciali) newA.openingAP = data.debitiCommerciali;
    if (data.rimanenze) newA.openingInventory = data.rimanenze;
    
    // Working capital days from actual data
    if (data.creditiCommerciali && data.ricavi) {
      newA.dso = Math.round((data.creditiCommerciali / data.ricavi) * 360);
    } else if (data.creditiTotali && data.ricavi) {
      newA.dso = Math.min(120, Math.round((data.creditiTotali / data.ricavi) * 360));
    }
    if (data.debitiCommerciali && data.costiProduzione) {
      newA.dpo = Math.round((data.debitiCommerciali / data.costiProduzione) * 360);
    }
    if (data.rimanenze && data.cogs) {
      newA.dio = Math.round((data.rimanenze / data.cogs) * 360);
    } else {
      newA.dio = 0;
    }
    
    // Interest rate from actual data
    if (data.interessiPassivi && data.debitiFinanziari && data.debitiFinanziari > 0) {
      newA.interestRate = Math.round((data.interessiPassivi / data.debitiFinanziari) * 1000) / 1000;
    }
    
    // Tax rate from actual data
    if (data.imposte && data.risultatoPrimaImposte && data.risultatoPrimaImposte > 0) {
      const effectiveRate = data.imposte / data.risultatoPrimaImposte;
      if (effectiveRate >= 0.15 && effectiveRate <= 0.45) {
        const scale = effectiveRate / 0.279;
        newA.iresRate = Math.round(0.24 * scale * 1000) / 1000;
        newA.irapRate = Math.round(0.039 * scale * 1000) / 1000;
      }
    }
    
    // Contributi from bilancio
    if (data.contributi && data.contributi > 0) {
      newA.grantAmount = data.contributi;
      newA.grantYears = 1;
    }
    
    return newA;
  });
  
  // V3: Populate bilpianoAnno0 from parsed bilancio
  setCompany(c => {
    const bil = BILANCIO_TEMPLATE();
    bil.ricavi = data.ricavi || 0;
    bil.costiEsterni = (data.materiePrime || 0) + (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
    bil.valoreAggiunto = bil.ricavi - bil.costiEsterni;
    bil.personale = data.personale || 0;
    bil.ebitda = data.ebitda || 0;
    bil.ammortamenti = data.ammortamenti || ((data.ammortamentiImmateriali || 0) + (data.ammortamentiMateriali || 0));
    bil.ebit = (data.margineOperativo || (bil.ebitda - bil.ammortamenti)) || 0;
    bil.interessiPassivi = data.interessiPassivi || 0;
    bil.risultatoPrimaImposte = data.risultatoPrimaImposte || 0;
    bil.imposte = data.imposte || 0;
    bil.utileNetto = data.utileNetto || 0;
    bil.immobilizzazioniNette = (data.immobilizzazioniImmateriali || 0) + (data.immobilizzazioniMateriali || 0);
    bil.creditiCommerciali = data.creditiCommerciali || data.creditiTotali || 0;
    bil.rimanenze = data.rimanenze || 0;
    bil.cassa = data.cassa || 0;
    bil.capitaleSociale = data.capitaleSociale || 0;
    bil.patrimonioNetto = data.patrimonioNetto || 0;
    bil.debitiFinanziari = data.debitiFinanziari || 0;
    bil.debitiCommerciali = data.debitiCommerciali || 0;
    bil.tfr = data.tfr || 0;
    bil.dipendenti = data.dipendenti || 0;
    bil.annoRiferimento = c.startYear ? c.startYear - 1 : new Date().getFullYear() - 1;
    bil.fonte = "pdf_import";
    return { ...c, bilpianoAnno0: bil, companyType: c.companyType === "nuova_impresa" ? "existing" : c.companyType };
  });
  
  return data;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EXPORT ENGINES
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions) {
  const {
    jsPDF
  } = window.jspdf;
  const doc = new jsPDF({
    orientation: "landscape",
    unit: "mm",
    format: "a4"
  });
  const n = company.yearsCount;
  const cols = ["Voce", ...YL.slice(0, n)];
  const pg = {
    w: 297,
    h: 210,
    mx: 14,
    my: 14
  };
  let y = pg.my;
  const addTitle = text => {
    if (y > pg.h - 30) {
      doc.addPage();
      y = pg.my;
    }
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(15, 36, 64);
    doc.text(text, pg.mx, y);
    y += 3;
    doc.setDrawColor(212, 175, 55);
    doc.setLineWidth(.5);
    doc.line(pg.mx, y, pg.w - pg.mx, y);
    y += 8;
  };
  const addTable = (title, rows, opts = {}) => {
    if (y > pg.h - 40) {
      doc.addPage();
      y = pg.my;
    }
    if (title) {
      doc.setFontSize(11);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(30, 58, 95);
      doc.text(title, pg.mx, y);
      y += 5;
    }
    doc.autoTable({
      startY: y,
      margin: {
        left: pg.mx,
        right: pg.mx
      },
      head: [cols],
      body: rows.map(r => [r.label, ...r.values.slice(0, n).map(v => r.pct ? fmtPct(v) : fmt(v, r.dec || 0))]),
      styles: {
        font: "helvetica",
        fontSize: 8,
        cellPadding: 2,
        lineColor: [229, 231, 235],
        lineWidth: .1
      },
      headStyles: {
        fillColor: [15, 36, 64],
        textColor: 255,
        fontStyle: "bold",
        fontSize: 8
      },
      alternateRowStyles: {
        fillColor: [249, 250, 251]
      },
      columnStyles: {
        0: {
          cellWidth: 55
        }
      },
      didParseCell: data => {
        if (data.section === "body" && data.column.index > 0) {
          data.cell.styles.halign = "right";
          data.cell.styles.font = "courier";
          const val = rows[data.row.index]?.values[data.column.index - 1];
          if (typeof val === "number" && val < 0) data.cell.styles.textColor = [220, 38, 38];
        }
        if (rows[data.row.index]?.bold && data.section === "body") {
          data.cell.styles.fontStyle = "bold";
          if (rows[data.row.index]?.highlight) data.cell.styles.fillColor = [237, 242, 252];
        }
      },
      ...opts
    });
    y = doc.lastAutoTable.finalY + 8;
  };

  // Cover
  doc.setFillColor(15, 36, 64);
  doc.rect(0, 0, pg.w, pg.h, "F");
  doc.setFillColor(212, 175, 55);
  doc.rect(0, pg.h - 3, pg.w, 3, "F");
  doc.setTextColor(255);
  doc.setFontSize(32);
  doc.setFont("helvetica", "bold");
  doc.text("PIANO ECONOMICO-FINANZIARIO", pg.w / 2, pg.h / 2 - 20, {
    align: "center"
  });
  doc.setFontSize(20);
  doc.setFont("helvetica", "normal");
  doc.text(company.name || "Azienda", pg.w / 2, pg.h / 2 + 5, {
    align: "center"
  });
  doc.setFontSize(12);
  doc.setTextColor(148, 163, 184);
  const scenarioLabel = {
    base: "Scenario Base",
    pessimistic: "Scenario Pessimistico",
    optimistic: "Scenario Ottimistico"
  }[company.scenario];
  doc.text(`${scenarioLabel} â€” ${n} anni â€” ${company.currency}`, pg.w / 2, pg.h / 2 + 18, {
    align: "center"
  });
  doc.text("Generato il " + new Date().toLocaleDateString("it-IT"), pg.w / 2, pg.h / 2 + 28, {
    align: "center"
  });

  // CE
  doc.addPage();
  y = pg.my;
  addTitle("CONTO ECONOMICO PREVISIONALE");
  const f = financials;
  addTable(null, [{
    label: "Ricavi totali",
    values: f.totalRevenue,
    bold: true,
    highlight: true
  }, {
    label: "  âˆ’ Costo del venduto",
    values: f.totalCOGS.map(v => -v)
  }, {
    label: "MARGINE LORDO",
    values: f.grossProfit,
    bold: true,
    highlight: true
  }, {
    label: "  Margine lordo %",
    values: f.grossMarginPct,
    pct: true
  }, {
    label: "  âˆ’ Costo personale",
    values: f.hrCosts.map(v => -v)
  }, {
    label: "  âˆ’ Costi operativi",
    values: f.opexCosts.map(v => -v)
  }, {
    label: "  + Contributi",
    values: f.grantIncome
  }, {
    label: "EBITDA",
    values: f.ebitda,
    bold: true,
    highlight: true
  }, {
    label: "  Margine EBITDA %",
    values: f.ebitdaMargin,
    pct: true
  }, {
    label: "  âˆ’ Ammortamenti",
    values: f.depreciation.map(v => -v)
  }, {
    label: "EBIT",
    values: f.ebit,
    bold: true
  }, {
    label: "  âˆ’ Interessi passivi",
    values: f.interest.map(v => -v)
  }, {
    label: "UTILE ANTE IMPOSTE",
    values: f.ebt,
    bold: true
  }, {
    label: "  âˆ’ IRES",
    values: f.ires.map(v => -v)
  }, {
    label: "  âˆ’ IRAP",
    values: f.irap.map(v => -v)
  }, ...(f.taxCreditUsed.some(v => v > 0) ? [{
    label: "  + Credito d'imposta",
    values: f.taxCreditUsed
  }] : []), {
    label: "UTILE NETTO",
    values: f.netIncome,
    bold: true,
    highlight: true
  }, {
    label: "  Margine netto %",
    values: f.netMargin,
    pct: true
  }]);

  // SP
  doc.addPage();
  y = pg.my;
  addTitle("STATO PATRIMONIALE PREVISIONALE");
  addTable("ATTIVO", [{
    label: "Cassa e disponibilitÃ ",
    values: f.cash.map(v => Math.max(0, v))
  }, {
    label: "Crediti commerciali",
    values: f.ar
  }, {
    label: "Rimanenze",
    values: f.inventory
  }, {
    label: "Immobilizzazioni nette",
    values: f.netFA
  }, {
    label: "TOTALE ATTIVO",
    values: f.totalAssets,
    bold: true,
    highlight: true
  }]);
  addTable("PASSIVO E PATRIMONIO NETTO", [{
    label: "Debiti commerciali",
    values: f.ap
  }, {
    label: "Debiti tributari",
    values: f.totalTax
  }, {
    label: "Risconti passivi (contributi)",
    values: f.deferredGrant
  }, {
    label: "Debito finanziario",
    values: f.netDebt
  }, {
    label: "Fondo TFR",
    values: f.cumTFR
  }, {
    label: "Patrimonio netto",
    values: f.equity,
    bold: true
  }, {
    label: "TOTALE PASSIVO",
    values: f.totalLiabEq,
    bold: true,
    highlight: true
  }]);
  if (f.fundingGap.some(v => v > 0)) {
    addTable("âš ï¸ FABBISOGNO FINANZIARIO", [{
      label: "Gap di cassa (copertura necessaria)",
      values: f.fundingGap,
      bold: true
    }]);
  }

  // CF
  doc.addPage();
  y = pg.my;
  addTitle("RENDICONTO FINANZIARIO PREVISIONALE");
  const wcChange = YEARS.map((_, i) => {
    const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
    const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
    return wcTrade + wcTax;
  });
  const grantAdj = YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]);
  addTable(null, [{
    label: "Utile netto",
    values: f.netIncome
  }, {
    label: "  + Ammortamenti",
    values: f.depreciation
  }, {
    label: "  + TFR accantonato",
    values: f.tfrAccrual
  }, {
    label: "  Â± Î” Capitale circolante",
    values: wcChange
  }, {
    label: "  Â± Rettifica contributi (cassa vs comp.)",
    values: grantAdj
  }, {
    label: "CF OPERATIVO",
    values: f.cfOperating,
    bold: true,
    highlight: true
  }, {
    label: "  âˆ’ Investimenti",
    values: f.cfInvesting
  }, {
    label: "CF INVESTIMENTO",
    values: f.cfInvesting,
    bold: true
  }, {
    label: "  + Nuovi finanziamenti",
    values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0)
  }, {
    label: "  âˆ’ Rimborso debito",
    values: YEARS.map((_, i) => -(assumptions.debtRepayment[i] || 0))
  }, {
    label: "  + Apporto equity",
    values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0)
  }, {
    label: "  âˆ’ Dividendi",
    values: f.dividends.map(v => -v)
  }, {
    label: "CF FINANZIAMENTO",
    values: f.cfFinancing,
    bold: true
  }, {
    label: "FLUSSO DI CASSA NETTO",
    values: f.netCF,
    bold: true,
    highlight: true
  }, {
    label: "Cassa cumulata",
    values: f.cumCash,
    bold: true
  }]);

  // KPI RedditivitÃ 
  addTitle("INDICATORI CHIAVE (KPI)");
  addTable("RedditivitÃ ", [{
    label: "Margine lordo %",
    values: f.grossMarginPct,
    pct: true
  }, {
    label: "Margine EBITDA %",
    values: f.ebitdaMargin,
    pct: true
  }, {
    label: "Margine netto %",
    values: f.netMargin,
    pct: true
  }, {
    label: "ROE",
    values: f.roe,
    pct: true
  }, {
    label: "ROI (Return on Investment)",
    values: f.roi,
    pct: true
  }, {
    label: "ROA",
    values: f.roa,
    pct: true
  }, {
    label: "Cost-to-Income",
    values: f.costToIncome,
    pct: true
  }, {
    label: "Incidenza personale/ricavi",
    values: f.hrOnRevenue,
    pct: true
  }, {
    label: "Crescita ricavi YoY",
    values: f.revenueGrowth,
    pct: true
  }]);
  addTable("SostenibilitÃ  finanziaria", [{
    label: "DSCR (Debt Service Coverage)",
    values: f.dscr,
    dec: 2
  }, {
    label: "ICR (Interest Coverage)",
    values: f.icr,
    dec: 1
  }, {
    label: "Current ratio",
    values: f.currentRatio,
    dec: 2
  }, {
    label: "Debt/Equity",
    values: f.debtEquity,
    dec: 2
  }, {
    label: "Rapporto indebitamento",
    values: f.debtRatio,
    pct: true
  }]);
  addTable("Break-Even e Struttura", [{
    label: "Costi fissi totali",
    values: f.fixedCosts
  }, {
    label: "Break-Even Point (â‚¬)",
    values: f.bep
  }, {
    label: "Margine di sicurezza",
    values: f.bepMargin,
    pct: true
  }, {
    label: "PFN (Posizione Fin. Netta)",
    values: f.pfn
  }, {
    label: "NWC (Cap. Circolante Netto)",
    values: f.nwc
  }, {
    label: "Organico",
    values: f.headcount
  }, {
    label: "Ricavo per dipendente",
    values: f.revPerEmp
  }]);

  // V4: Nota Integrativa
  doc.addPage();
  y = pg.my;
  addTitle("Nota Integrativa");
  const notaSections = generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions);
  notaSections.forEach(function(section) {
    if (y > pg.h - 30) { doc.addPage(); y = pg.my; }
    doc.setFontSize(11);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(30, 58, 95);
    doc.text(section.title, pg.mx, y);
    y += 6;
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(55, 65, 81);
    const lines = doc.splitTextToSize(section.text, pg.w - 2 * pg.mx);
    lines.forEach(function(line) {
      if (y > pg.h - 15) { doc.addPage(); y = pg.my; }
      doc.text(line, pg.mx, y);
      y += 4.5;
    });
    y += 4;
  });

  // V4: Disclaimer
  doc.addPage();
  y = pg.my;
  addTitle("Disclaimer e Metodologia");
  doc.setFontSize(9);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(107, 114, 128);
  var disclaimerText = "Il presente documento ha natura previsionale e si basa su ipotesi ragionevoli ma soggette a incertezza. " +
    "I risultati effettivi potrebbero differire significativamente dalle proiezioni. " +
    "Il piano e' stato redatto secondo i principi contabili OIC con metodo indiretto per il rendiconto finanziario (OIC 10). " +
    "La base imponibile IRAP e' calcolata secondo la normativa vigente. " +
    "Si raccomanda di integrare il presente piano con analisi di mercato, analisi competitiva e piano operativo. " +
    "Documento generato automaticamente in data " + new Date().toLocaleDateString("it-IT") + ".";
  var discLines = doc.splitTextToSize(disclaimerText, pg.w - 2 * pg.mx);
  discLines.forEach(function(line) { doc.text(line, pg.mx, y); y += 4.5; });

  // V4: Add page numbers to all pages
  var totalPages = doc.internal.getNumberOfPages();
  for (var p = 1; p <= totalPages; p++) {
    doc.setPage(p);
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(156, 163, 175);
    doc.text(sanitizeName(company.name) + " - Piano Economico Finanziario", pg.mx, pg.h - 5);
    doc.text("Pag. " + p + "/" + totalPages + " - Riservato e Confidenziale", pg.w - pg.mx - 60, pg.h - 5);
  }

  doc.save(`piano-economico-${sanitizeName(company.name)}.pdf`);
}
function exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions) {
  const n = company.yearsCount;
  const wb = XLSX.utils.book_new();
  const f = financials;
  const hdr = ["Voce", ...YL.slice(0, n)];
  const makeSheet = (name, sections) => {
    const data = [];
    sections.forEach(sec => {
      if (sec.title) {
        data.push([sec.title]);
        data.push(hdr);
      }
      sec.rows.forEach(r => {
        data.push([r.label, ...r.values.slice(0, n).map(v => r.pct ? fmtPct(v) : Math.round(v * 100) / 100)]);
      });
      data.push([]);
    });
    const ws = XLSX.utils.aoa_to_sheet(data);
    ws["!cols"] = [{
      wch: 35
    }, ...Array(n).fill({
      wch: 16
    })];
    XLSX.utils.book_append_sheet(wb, ws, name);
  };

  // Conto Economico
  makeSheet("Conto Economico", [{
    title: "CONTO ECONOMICO PREVISIONALE",
    rows: [{
      label: "Ricavi totali",
      values: f.totalRevenue
    }, {
      label: "(âˆ’) Costo del venduto",
      values: f.totalCOGS.map(v => -v)
    }, {
      label: "MARGINE LORDO",
      values: f.grossProfit
    }, {
      label: "Margine lordo %",
      values: f.grossMarginPct,
      pct: true
    }, {
      label: "(âˆ’) Costo personale",
      values: f.hrCosts.map(v => -v)
    }, {
      label: "(âˆ’) Costi operativi",
      values: f.opexCosts.map(v => -v)
    }, {
      label: "(+) Contributi",
      values: f.grantIncome
    }, {
      label: "EBITDA",
      values: f.ebitda
    }, {
      label: "Margine EBITDA %",
      values: f.ebitdaMargin,
      pct: true
    }, {
      label: "(âˆ’) Ammortamenti",
      values: f.depreciation.map(v => -v)
    }, {
      label: "EBIT",
      values: f.ebit
    }, {
      label: "(âˆ’) Interessi passivi",
      values: f.interest.map(v => -v)
    }, {
      label: "UTILE ANTE IMPOSTE (EBT)",
      values: f.ebt
    }, {
      label: "(âˆ’) IRES",
      values: f.ires.map(v => -v)
    }, {
      label: "(âˆ’) IRAP",
      values: f.irap.map(v => -v)
    }, {
      label: "UTILE NETTO",
      values: f.netIncome
    }, {
      label: "Margine netto %",
      values: f.netMargin,
      pct: true
    }]
  }]);

  // Stato Patrimoniale
  makeSheet("Stato Patrimoniale", [{
    title: "ATTIVO",
    rows: [{
      label: "Cassa e disponibilitÃ ",
      values: f.cash.map(v => Math.max(0, v))
    }, {
      label: "Crediti commerciali",
      values: f.ar
    }, {
      label: "Rimanenze",
      values: f.inventory
    }, {
      label: "Immobilizzazioni nette",
      values: f.netFA
    }, {
      label: "TOTALE ATTIVO",
      values: f.totalAssets
    }]
  }, {
    title: "PASSIVO E PATRIMONIO NETTO",
    rows: [{
      label: "Debiti commerciali",
      values: f.ap
    }, {
      label: "Debiti tributari",
      values: f.totalTax
    }, {
      label: "Risconti passivi (contributi)",
      values: f.deferredGrant
    }, {
      label: "Debito finanziario",
      values: f.netDebt
    }, {
      label: "Patrimonio netto",
      values: f.equity
    }, {
      label: "TOTALE PASSIVO E PN",
      values: f.totalLiabEq
    }, {
      label: "Fabbisogno finanziario",
      values: f.fundingGap
    }]
  }]);

  // Cash Flow
  const xlWcChange = YEARS.map((_, i) => {
    const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
    const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
    return wcTrade + wcTax;
  });
  const xlGrantAdj = YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]);
  makeSheet("Cash Flow", [{
    title: "RENDICONTO FINANZIARIO",
    rows: [{
      label: "Utile netto",
      values: f.netIncome
    }, {
      label: "(+) Ammortamenti",
      values: f.depreciation
    }, {
      label: "(Â±) Î” Capitale circolante",
      values: xlWcChange
    }, {
      label: "(Â±) Rettifica contributi (cassa vs comp.)",
      values: xlGrantAdj
    }, {
      label: "CF OPERATIVO",
      values: f.cfOperating
    }, {
      label: "CF INVESTIMENTO",
      values: f.cfInvesting
    }, {
      label: "(+) Nuovi finanziamenti",
      values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0)
    }, {
      label: "(âˆ’) Rimborso debito",
      values: YEARS.map((_, i) => -(assumptions.debtRepayment[i] || 0))
    }, {
      label: "(+) Apporto equity",
      values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0)
    }, {
      label: "(âˆ’) Dividendi",
      values: f.dividends.map(v => -v)
    }, {
      label: "CF FINANZIAMENTO",
      values: f.cfFinancing
    }, {
      label: "FLUSSO DI CASSA NETTO",
      values: f.netCF
    }, {
      label: "Cassa cumulata",
      values: f.cumCash
    }]
  }]);

  // KPI
  makeSheet("KPI", [{
    title: "REDDITIVITÃ€",
    rows: [{
      label: "Margine lordo %",
      values: f.grossMarginPct,
      pct: true
    }, {
      label: "Margine EBITDA %",
      values: f.ebitdaMargin,
      pct: true
    }, {
      label: "Margine netto %",
      values: f.netMargin,
      pct: true
    }, {
      label: "ROE",
      values: f.roe,
      pct: true
    }, {
      label: "ROA",
      values: f.roa,
      pct: true
    }, {
      label: "Incidenza personale/ricavi",
      values: f.hrOnRevenue,
      pct: true
    }]
  }, {
    title: "SOSTENIBILITÃ€ FINANZIARIA",
    rows: [{
      label: "DSCR (Debt Service Coverage)",
      values: f.dscr
    }, {
      label: "ICR (Interest Coverage)",
      values: f.icr
    }, {
      label: "Current ratio",
      values: f.currentRatio
    }, {
      label: "Debt/Equity",
      values: f.debtEquity
    }, {
      label: "Rapporto indebitamento",
      values: f.debtRatio,
      pct: true
    }]
  }, {
    title: "BREAK-EVEN E STRUTTURA",
    rows: [{
      label: "Costi fissi totali",
      values: f.fixedCosts
    }, {
      label: "Break-Even Point (â‚¬)",
      values: f.bep
    }, {
      label: "Margine di sicurezza",
      values: f.bepMargin,
      pct: true
    }, {
      label: "PFN (Posiz. Fin. Netta)",
      values: f.pfn
    }, {
      label: "NWC (Cap. Circolante Netto)",
      values: f.nwc
    }, {
      label: "Organico",
      values: f.headcount
    }, {
      label: "Ricavo per dipendente",
      values: f.revPerEmp
    }, {
      label: "CAGR Ricavi",
      values: YEARS.map(() => f.revenueCAGR),
      pct: true
    }]
  }]);

  // Dati input
  const inputData = [["DATI AZIENDA"], ["Nome", company.name], ["Settore", company.sector], ["Scenario", company.scenario], ["Anni", company.yearsCount], [], ["LINEE DI RICAVO"], ["Nome", "Tipo", "Prezzo unit.", "Margine lordo", ...YL.slice(0, n).map(y => y + " (vol.)"), ...YL.slice(0, n).map(y => y + " (crescita)")], ...revenues.map(r => [r.name, r.type, r.unitPrice, fmtPct(r.grossMargin), ...r.volumes.slice(0, n), ...(r.growthRates || [0, .05, .05, .05, .05]).slice(0, n).map(g => fmtPct(g))]), [], ["PERSONALE"], ["Ruolo", "Tipo", "Costo annuo", "Crescita", ...YL.slice(0, n).map(y => y + " (nÂ°)")], ...hrs.map(h => [h.role, h.type, h.annualCost, fmtPct(h.growthRate), ...h.count.slice(0, n)]), [], ["COSTI OPERATIVI"], ["Nome", "Categoria", "Metodo", "Valore/Tasso", ...YL.slice(0, n)], ...opexItems.map(o => [o.name, o.category, o.isPercentOfRevenue ? "%Ricavi" : "Fisso", o.isPercentOfRevenue ? fmtPct(o.percentOfRevenue) : fmtPct(o.growthRate), ...(o.isPercentOfRevenue ? Array(n).fill("% sui ricavi") : o.values.slice(0, n))]), [], ["INVESTIMENTI"], ["Nome", "Tipo", "Costo", "Vita utile", "Anno"], ...investments.map(inv => [inv.name, inv.type, inv.cost, inv.usefulLife, YL[inv.year]]), [], ["IPOTESI FINANZIARIE"], ["IRES", fmtPct(assumptions.iresRate)], ["IRAP", fmtPct(assumptions.irapRate)], ["IVA", fmtPct(assumptions.vatRate)], ["DSO (gg)", assumptions.dso], ["DPO (gg)", assumptions.dpo], ["DIO (gg)", assumptions.dio], ["Tasso interesse", fmtPct(assumptions.interestRate)], ["Payout dividendi", fmtPct(assumptions.dividendPayout)], ["Contributo", assumptions.grantAmount], ["Anni contributo", assumptions.grantYears]];
  const wsInput = XLSX.utils.aoa_to_sheet(inputData);
  wsInput["!cols"] = [{
    wch: 30
  }, {
    wch: 18
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }];
  XLSX.utils.book_append_sheet(wb, wsInput, "Dati Input");
  XLSX.writeFile(wb, `piano-economico-${sanitizeName(company.name)}.xlsx`);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UI COMPONENTS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const css = {
  input: {
    width: "100%",
    padding: "8px 12px",
    border: "1px solid #e5e7eb",
    borderRadius: 8,
    fontSize: 14,
    fontFamily: "'JetBrains Mono',monospace",
    background: "#fafafa",
    color: "#111827",
    outline: "none",
    boxSizing: "border-box"
  },
  label: {
    fontSize: 11,
    fontFamily: "'DM Sans',sans-serif",
    color: "#6b7280",
    fontWeight: 500,
    letterSpacing: ".02em",
    textTransform: "uppercase"
  },
  card: {
    background: "#fff",
    borderRadius: 16,
    border: "1px solid #e5e7eb",
    overflow: "hidden",
    boxShadow: "0 1px 3px rgba(0,0,0,.04)"
  }
};
function InputField({
  label,
  value,
  onChange,
  type = "number",
  step,
  min,
  suffix,
  placeholder,
  tooltip,
  style
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 4,
      flex: 1,
      ...style
    }
  }, label && /*#__PURE__*/React.createElement("label", {
    style: css.label,
    title: tooltip
  }, label, tooltip && /*#__PURE__*/React.createElement("span", {
    style: {
      cursor: "help",
      opacity: .5
    }
  }, " \u24D8")), /*#__PURE__*/React.createElement("div", {
    style: {
      position: "relative"
    }
  }, /*#__PURE__*/React.createElement("input", {
    type: type,
    value: value,
    step: step,
    min: min,
    placeholder: placeholder,
    onChange: e => onChange(type === "number" ? parseFloat(e.target.value) || 0 : e.target.value),
    style: {
      ...css.input,
      paddingRight: suffix ? 36 : 12
    },
    onFocus: e => {
      e.target.style.borderColor = "#2563eb";
      e.target.style.boxShadow = "0 0 0 3px rgba(37,99,235,.1)";
    },
    onBlur: e => {
      e.target.style.borderColor = "#e5e7eb";
      e.target.style.boxShadow = "none";
    }
  }), suffix && /*#__PURE__*/React.createElement("span", {
    style: {
      position: "absolute",
      right: 10,
      top: "50%",
      transform: "translateY(-50%)",
      fontSize: 11,
      color: "#9ca3af",
      fontFamily: "'DM Sans',sans-serif"
    }
  }, suffix)));
}
function SelectField({
  label,
  value,
  onChange,
  options
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 4,
      flex: 1
    }
  }, label && /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, label), /*#__PURE__*/React.createElement("select", {
    value: value,
    onChange: e => onChange(e.target.value),
    style: {
      padding: "8px 12px",
      border: "1px solid #e5e7eb",
      borderRadius: 8,
      fontSize: 14,
      fontFamily: "'DM Sans',sans-serif",
      background: "#fafafa",
      color: "#111827",
      outline: "none",
      cursor: "pointer"
    }
  }, options.map(o => /*#__PURE__*/React.createElement("option", {
    key: o.value,
    value: o.value
  }, o.label))));
}
function Card({
  title,
  children,
  accent,
  actions,
  collapsible,
  defaultOpen = true
}) {
  const [open, setOpen] = useState(defaultOpen);
  return /*#__PURE__*/React.createElement("div", {
    style: css.card
  }, title && /*#__PURE__*/React.createElement("div", {
    onClick: collapsible ? () => setOpen(!open) : undefined,
    style: {
      padding: "16px 20px",
      borderBottom: open ? "1px solid #f3f4f6" : "none",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      cursor: collapsible ? "pointer" : "default",
      background: accent ? "linear-gradient(135deg,#1e3a5f 0%,#0f2440 100%)" : "transparent"
    }
  }, /*#__PURE__*/React.createElement("h3", {
    style: {
      margin: 0,
      fontSize: 15,
      fontFamily: "'Playfair Display',serif",
      fontWeight: 700,
      color: accent ? "#fff" : "#111827"
    }
  }, title), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8,
      alignItems: "center"
    },
    onClick: e => e.stopPropagation()
  }, actions, collapsible && /*#__PURE__*/React.createElement("span", {
    style: {
      color: accent ? "#94a3b8" : "#9ca3af",
      fontSize: 12,
      transition: "transform .2s",
      transform: open ? "rotate(180deg)" : "rotate(0)"
    }
  }, " \u25BC"))), open && /*#__PURE__*/React.createElement("div", {
    style: {
      padding: 20
    },
    className: "fade-in"
  }, children));
}
function Btn({
  children,
  onClick,
  primary,
  small,
  danger,
  disabled
}) {
  return /*#__PURE__*/React.createElement("button", {
    onClick: onClick,
    disabled: disabled,
    style: {
      padding: small ? "6px 12px" : "10px 20px",
      borderRadius: 10,
      border: primary ? "none" : danger ? "1px solid #fca5a5" : "1px solid #d1d5db",
      background: primary ? "linear-gradient(135deg,#1e3a5f 0%,#2563eb 100%)" : danger ? "#fef2f2" : "#fff",
      color: primary ? "#fff" : danger ? "#dc2626" : "#374151",
      fontSize: small ? 12 : 14,
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: 600,
      cursor: disabled ? "not-allowed" : "pointer",
      transition: "all .2s",
      opacity: disabled ? .5 : 1
    }
  }, children);
}
function Tip({
  text
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "12px 16px",
      background: "#fffbeb",
      border: "1px solid #fde68a",
      borderRadius: 10,
      fontSize: 13,
      color: "#92400e",
      fontFamily: "'DM Sans',sans-serif",
      lineHeight: 1.6,
      marginBottom: 16
    }
  }, "\uD83D\uDCA1 ", text);
}
function YearHeader({
  n
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `220px repeat(${n},1fr)`,
      gap: 8,
      padding: "8px 0",
      borderBottom: "2px solid #1e3a5f",
      marginBottom: 4
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      letterSpacing: ".05em"
    }
  }, "Voce"), YL.slice(0, n).map((y, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      ...css.label,
      textAlign: "right",
      paddingRight: 8,
      letterSpacing: ".05em"
    }
  }, y)));
}
function YearRow({
  label,
  values,
  n,
  bold,
  highlight,
  pct,
  dec
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `220px repeat(${n},1fr)`,
      gap: 8,
      padding: "6px 0",
      borderBottom: "1px solid #f9fafb",
      alignItems: "center",
      background: highlight ? "rgba(37,99,235,.03)" : "transparent"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 13,
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: bold ? 700 : 400,
      color: bold ? "#111827" : "#4b5563",
      paddingLeft: bold ? 0 : 8
    }
  }, label), values.slice(0, n).map((v, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      fontSize: 13,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: bold ? 700 : 400,
      color: v < 0 ? "#dc2626" : bold ? "#111827" : "#374151",
      textAlign: "right",
      paddingRight: 8
    }
  }, pct ? fmtPct(v) : fmt(v, dec || 0))));
}
function Badge({
  children,
  color = "#2563eb"
}) {
  return /*#__PURE__*/React.createElement("span", {
    style: {
      display: "inline-block",
      padding: "2px 8px",
      borderRadius: 6,
      fontSize: 11,
      fontWeight: 600,
      fontFamily: "'DM Sans',sans-serif",
      background: color + "15",
      color,
      marginLeft: 6
    }
  }, children);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STEP COMPONENTS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function StepCompany({
  company: c,
  setCompany: set,
  setRevenues,
  setHrs,
  setOpexItems,
  setInvestments,
  setAssumptions
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, 
  // V3: Company Type Cards
  React.createElement(Card, { title: "Tipo di Impresa", accent: true },
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10 } },
      COMPANY_TYPES.map(ct => React.createElement("button", {
        key: ct.value,
        onClick: () => set({ ...c, companyType: ct.value }),
        style: { padding: "14px", border: c.companyType === ct.value ? "2px solid #2563eb" : "2px solid #e5e7eb",
          borderRadius: 10, background: c.companyType === ct.value ? "#eff6ff" : "#fff", cursor: "pointer", textAlign: "left", transition: "all .2s" }
      },
        React.createElement("div", { style: { fontSize: 13, fontWeight: 700, color: "#1e3a5f", marginBottom: 3 } }, ct.label),
        React.createElement("div", { style: { fontSize: 11, color: "#6b7280" } }, ct.desc)
      ))
    )
  ),
  // V3: Sector + Start Year + Timeline
  React.createElement(Card, { title: "Asse Temporale e Settore" },
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16, marginBottom: 12 } },
      React.createElement(InputField, { label: "Anno inizio piano", value: c.startYear || new Date().getFullYear(),
        onChange: v => set({ ...c, startYear: parseInt(v) || new Date().getFullYear() }), suffix: "", min: 2020, step: 1,
        tooltip: "L'Anno 1 del piano previsionale." }),
      React.createElement(SelectField, { label: "Settore (benchmark)", value: c.sectorTemplate || "altro",
        onChange: v => { const tmpl = SECTOR_TEMPLATES[v]; if (tmpl) { set({ ...c, sectorTemplate: v, sector: tmpl.label }); setAssumptions(a => ({ ...a, dso: tmpl.dso, dpo: tmpl.dpo, dio: tmpl.dio })); } },
        options: Object.keys(SECTOR_TEMPLATES).map(k => ({ value: k, label: SECTOR_TEMPLATES[k].label }))
      })
    ),
    React.createElement("div", { style: { display: "flex", gap: 4, flexWrap: "wrap" } },
      getYearLabels(c).full.map((yl, i) => React.createElement("div", { key: i, style: {
        padding: "8px 14px", borderRadius: 8, textAlign: "center", minWidth: 70,
        background: yl.type === "storico" ? "#f3f4f6" : yl.type === "consuntivo" ? "#fef3c7" : "#eff6ff",
        border: yl.type === "consuntivo" ? "2px solid #d97706" : yl.type === "previsionale" ? "2px solid #2563eb" : "1px solid #d1d5db"
      } },
        React.createElement("div", { style: { fontSize: 15, fontWeight: 700, color: yl.type === "consuntivo" ? "#92400e" : yl.type === "previsionale" ? "#1e3a5f" : "#9ca3af" } }, yl.label),
        React.createElement("div", { style: { fontSize: 9, color: "#6b7280", textTransform: "uppercase" } },
          yl.type === "storico" ? "Storico" : yl.type === "consuntivo" ? "Consuntivo" : "Previsionale")
      ))
    ),
    React.createElement(Note, null, "Il settore selezionato pre-imposta DSO, DPO, DIO nelle Ipotesi Finanziarie e attiva il confronto Benchmark nei Risultati.")
  ),
  // V3: Bilancio Anno 0 (solo per existing/crisis)
  (c.companyType === "existing" || c.companyType === "crisis") && React.createElement(Card, { title: "\uD83D\uDCC2 Bilancio Anno 0 (Consuntivo " + ((c.startYear || new Date().getFullYear()) - 1) + ")", accent: true },
    React.createElement(Tip, { text: "Inserisci i principali dati del bilancio depositato. I saldi patrimoniali popoleranno automaticamente i Saldi di Apertura. Il CE apparir\u00E0 nei Risultati come colonna consuntivo." }),
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 12 } },
      React.createElement("div", { style: { gridColumn: "1/4", fontWeight: 700, fontSize: 12, color: "#fef3c7", textTransform: "uppercase" } }, "Conto Economico"),
      ...(["ricavi", "costiEsterni", "personale", "ebitda", "ammortamenti", "utileNetto"].map(key => {
        const labels = { ricavi: "Ricavi", costiEsterni: "Costi Esterni", personale: "Personale", ebitda: "EBITDA", ammortamenti: "Ammortamenti", utileNetto: "Utile Netto" };
        return React.createElement(InputField, { key: key, label: labels[key], value: (c.bilpianoAnno0 || {})[key] || 0,
          onChange: v => {
            const bil = { ...(c.bilpianoAnno0 || BILANCIO_TEMPLATE()), annoRiferimento: (c.startYear || new Date().getFullYear()) - 1, fonte: "manuale" };
            bil[key] = v;
            set({ ...c, bilpianoAnno0: bil });
          }, suffix: "\u20AC" });
      })),
      React.createElement("div", { style: { gridColumn: "1/4", fontWeight: 700, fontSize: 12, color: "#fef3c7", textTransform: "uppercase", marginTop: 8 } }, "Stato Patrimoniale"),
      ...(["immobilizzazioniNette", "creditiCommerciali", "rimanenze", "cassa", "patrimonioNetto", "debitiFinanziari", "debitiCommerciali", "tfr"].map(key => {
        const labels = { immobilizzazioniNette: "Immobilizz. Nette", creditiCommerciali: "Crediti Comm.", rimanenze: "Rimanenze", cassa: "Cassa", patrimonioNetto: "Patrimonio Netto", debitiFinanziari: "Debiti Finanziari", debitiCommerciali: "Debiti Fornitori", tfr: "TFR" };
        return React.createElement(InputField, { key: key, label: labels[key], value: (c.bilpianoAnno0 || {})[key] || 0,
          onChange: v => {
            const bil = { ...(c.bilpianoAnno0 || BILANCIO_TEMPLATE()), annoRiferimento: (c.startYear || new Date().getFullYear()) - 1, fonte: "manuale" };
            bil[key] = v;
            // Auto-sync opening balances
            const newC = { ...c, bilpianoAnno0: bil };
            set(newC);
            if (["cassa","debitiFinanziari","patrimonioNetto","immobilizzazioniNette","creditiCommerciali","debitiCommerciali","rimanenze","tfr"].includes(key)) {
              const map = { cassa: "openingCash", debitiFinanziari: "openingDebt", patrimonioNetto: "openingEquity", immobilizzazioniNette: "openingFA", creditiCommerciali: "openingAR", debitiCommerciali: "openingAP", rimanenze: "openingInventory", tfr: "openingTFR" };
              setAssumptions(a => ({ ...a, [map[key]]: v }));
            }
          }, suffix: "\u20AC" });
      }))
    ),
    React.createElement(Note, null, "I dati patrimoniali sono sincronizzati automaticamente con i Saldi di Apertura nello step Ipotesi Finanziarie.")
  ),
  /*#__PURE__*/React.createElement(Tip, {
    text: "Inserisci i dati generali dell'impresa. Lo scenario influenza i ricavi: Pessimistico applica \u221215%, Ottimistico +15%."
  }),
  /*#__PURE__*/React.createElement(ImportBilancioPanel, {
    setCompany: set,
    setRevenues: setRevenues,
    setHrs: setHrs,
    setOpexItems: setOpexItems,
    setInvestments: setInvestments,
    setAssumptions: setAssumptions,
    company: c
  }),
  /*#__PURE__*/React.createElement(Card, {
    title: "Dati Azienda"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Nome Azienda",
    value: c.name,
    onChange: v => set({
      ...c,
      name: v
    }),
    type: "text",
    placeholder: "Es. INGENIA S.R.L."
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Settore",
    value: c.sector,
    onChange: v => set({
      ...c,
      sector: v
    }),
    type: "text",
    placeholder: "Es. Tecnologia"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Valuta",
    value: c.currency,
    onChange: v => set({
      ...c,
      currency: v
    }),
    options: [{
      value: "EUR",
      label: "â‚¬ Euro"
    }, {
      value: "USD",
      label: "$ Dollaro"
    }, {
      value: "GBP",
      label: "Â£ Sterlina"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Orizzonte temporale",
    value: c.yearsCount,
    onChange: v => set({
      ...c,
      yearsCount: parseInt(v)
    }),
    options: [{
      value: 3,
      label: "3 Anni"
    }, {
      value: 5,
      label: "5 Anni"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Scenario",
    value: c.scenario,
    onChange: v => set({
      ...c,
      scenario: v
    }),
    options: [{
      value: "base",
      label: "ðŸŽ¯ Base"
    }, {
      value: "pessimistic",
      label: "âš ï¸ Pessimistico (âˆ’15%)"
    }, {
      value: "optimistic",
      label: "ðŸš€ Ottimistico (+15%)"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Capitale Sociale",
    value: c.capitaleSociale,
    onChange: v => set({
      ...c,
      capitaleSociale: v
    }),
    suffix: "\u20AC",
    tooltip: "Usato per verifica Art. 2447 CC. Il versamento effettivo va inserito come Apporto Equity nel passo Ipotesi."
  })), /*#__PURE__*/React.createElement(Note, null, "Il ", /*#__PURE__*/React.createElement("strong", null, "Capitale Sociale"), " qui serve come riferimento legale per la verifica Art. 2447 c.c. (PN ", "<", " 1/3 CS = obbligo ricapitalizzazione). Il versamento effettivo in cassa va inserito come ", /*#__PURE__*/React.createElement("strong", null, "Apporto Equity Anno 1"), " nel passo Ipotesi Finanziarie. Per SRL ordinaria il minimo \xE8 \u20AC10.000, per SRLS \u20AC1.")), /*#__PURE__*/React.createElement(Card, {
    title: "Come funziona questo strumento"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      color: "#4b5563",
      lineHeight: 1.7
    }
  }, /*#__PURE__*/React.createElement("p", {
    style: {
      margin: "0 0 12px"
    }
  }, "Procedi passo per passo compilando ogni sezione. Al termine, nella sezione ", /*#__PURE__*/React.createElement("strong", null, "Risultati"), " troverai:"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 10
    }
  }, STEPS.map(s => /*#__PURE__*/React.createElement("div", {
    key: s.id,
    style: {
      padding: "8px 12px",
      background: "#f9fafb",
      borderRadius: 8,
      fontSize: 13
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      marginRight: 6
    }
  }, s.icon), /*#__PURE__*/React.createElement("strong", null, s.label), " \u2014 ", s.desc))))));
}
function StepRevenue({
  revenues: lines,
  setRevenues: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...lines, DEFAULTS.revenueLine()]);
  const rm = i => set(lines.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...lines];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updArr = (i, field, yi, v) => {
    const u = [...lines];
    u[i] = {
      ...u[i],
      [field]: u[i][field].map((x, j) => j === yi ? v : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Definisci ogni linea di ricavo separatamente (prodotti, servizi, abbonamenti). Margini lordi tipici: Servizi professionali 60-80%, Software/SaaS 70-90%, Commercio 20-40%, Manifattura 25-50%, Ristorazione 60-70%. Il tasso di crescita si applica ai volumi: 5-10% \xE8 conservativo, 15-30% \xE8 aggressivo (devi giustificarlo alla banca). Inserisci almeno il volume Anno 1: gli anni successivi vengono auto-calcolati."
  }), lines.map((l, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: l.name || `Linea di Ricavo ${i + 1}`,
    collapsible: true,
    defaultOpen: i === lines.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Nome",
    value: l.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Licenza Software"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: l.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "product",
      label: "Prodotto"
    }, {
      value: "service",
      label: "Servizio"
    }, {
      value: "subscription",
      label: "Abbonamento"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Prezzo unitario",
    value: l.unitPrice,
    onChange: v => upd(i, "unitPrice", v),
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Margine lordo",
    value: Math.round(l.grossMargin * 100),
    onChange: v => upd(i, "grossMargin", v / 100),
    suffix: "%",
    tooltip: "% ricavo che resta dopo COGS"
  })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "Volumi previsti per anno ", /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 400,
      textTransform: "none"
    }
  }, "(lascia 0 per auto-calcolo da crescita)")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: l.volumes[yi],
    onChange: v => updArr(i, "volumes", yi, v),
    min: 0
  })))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "Tasso di crescita annuo volumi"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: Math.round((l.growthRates ? l.growthRates[yi] : 0.05) * 100),
    onChange: v => updArr(i, "growthRates", yi, v / 100),
    suffix: "%"
  }))))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Linea di Ricavo"), lines.some(l => l.unitPrice > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Ricavi per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Linea"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y)), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, "Media")), lines.filter(l => l.unitPrice > 0).map((l, i) => {
    const revs = YEARS.slice(0, n).map((_, j) => {
      let v = l.volumes[j];
      if (!v && j > 0) {
        let prev = l.volumes[0];
        for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
        v = prev;
      }
      return v * l.unitPrice;
    });
    const avg = revs.reduce((s, v) => s + v, 0) / n;
    return /*#__PURE__*/React.createElement("div", {
      key: i,
      style: {
        display: "grid",
        gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
        gap: 4,
        padding: "5px 0",
        borderBottom: "1px solid #f3f4f6"
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        color: "#374151",
        fontWeight: 500
      }
    }, l.name || `Linea ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
      color: "#2563eb"
    }, l.type === "product" ? "Prod." : l.type === "service" ? "Serv." : "Abb.")), revs.map((v, j) => /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(v))), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#6b7280",
        fontStyle: "italic"
      }
    }, fmt(avg)));
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE RICAVI"), YEARS.slice(0, n).map((_, j) => {
    const tot = lines.reduce((s, l) => {
      let v = l.volumes[j];
      if (!v && j > 0) {
        let prev = l.volumes[0];
        for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
        v = prev;
      }
      return s + v * l.unitPrice;
    }, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(tot));
  }), /*#__PURE__*/React.createElement("span", null)))));
}
function StepProduction({
  revenues,
  investments,
  company: {
    yearsCount: n
  }
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Riepilogo automatico: COGS per linea di ricavo e piano ammortamenti degli investimenti. Per modificare i margini torna al passo Ricavi; per modificare gli investimenti vai al passo Investimenti."
  }), /*#__PURE__*/React.createElement(Card, {
    title: "Riepilogo Costi di Produzione (COGS)"
  }, revenues.length === 0 ? /*#__PURE__*/React.createElement("p", {
    style: {
      color: "#9ca3af"
    }
  }, "Nessuna linea di ricavo definita.") : /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 10
    }
  }, revenues.map((l, i) => /*#__PURE__*/React.createElement("div", {
    key: i,
    style: {
      padding: "12px 14px",
      background: "#f9fafb",
      borderRadius: 10
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: 8
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("strong", null, l.name || `Linea ${i + 1}`), /*#__PURE__*/React.createElement(Badge, {
    color: "#059669"
  }, l.type === "product" ? "Prodotto" : l.type === "service" ? "Servizio" : "Abbonamento")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 20,
      fontFamily: "'JetBrains Mono',monospace",
      fontSize: 13
    }
  }, /*#__PURE__*/React.createElement("span", null, "Margine: ", /*#__PURE__*/React.createElement("strong", {
    style: {
      color: "#059669"
    }
  }, Math.round(l.grossMargin * 100), "%")), /*#__PURE__*/React.createElement("span", null, "COGS: ", /*#__PURE__*/React.createElement("strong", {
    style: {
      color: "#dc2626"
    }
  }, Math.round((1 - l.grossMargin) * 100), "%")))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `120px repeat(${n},1fr)`,
      gap: 4,
      fontSize: 12,
      fontFamily: "'JetBrains Mono',monospace"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280",
      fontSize: 10,
      fontWeight: 600
    }
  }, "ANNO"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      color: "#6b7280",
      fontSize: 10,
      fontWeight: 600,
      textAlign: "right"
    }
  }, y)), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "Volumi"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#374151"
      }
    }, fmt(v));
  }), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "Ricavo"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(v * l.unitPrice));
  }), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "COGS"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(v * l.unitPrice * (1 - l.grossMargin)));
  })))))), investments.some(inv => inv.cost > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "Piano Ammortamenti"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Bene"), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, "Costo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), investments.filter(inv => inv.cost > 0).map((inv, k) => /*#__PURE__*/React.createElement("div", {
    key: k,
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "5px 0",
      borderBottom: "1px solid #f3f4f6"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      color: "#374151"
    }
  }, inv.name || `Inv. ${k + 1}`, /*#__PURE__*/React.createElement(Badge, null, inv.type === "tangible" ? "Mat." : "Immat.")), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      fontFamily: "'JetBrains Mono',monospace",
      textAlign: "right",
      color: "#374151"
    }
  }, fmt(inv.cost)), YEARS.slice(0, n).map((_, j) => {
    const dep = j >= inv.year && inv.usefulLife > 0 && j - inv.year < inv.usefulLife ? inv.cost / inv.usefulLife : 0;
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: dep > 0 ? "#374151" : "#d1d5db"
      }
    }, dep > 0 ? fmt(Math.round(dep)) : "â€”");
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE AMMORTAMENTI"), /*#__PURE__*/React.createElement("span", null), YEARS.slice(0, n).map((_, j) => {
    const tot = investments.reduce((s, inv) => j >= inv.year && inv.usefulLife > 0 && j - inv.year < inv.usefulLife ? s + inv.cost / inv.usefulLife : s, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right"
      }
    }, fmt(Math.round(tot)));
  })))));
}
function StepHR({
  hrs,
  setHrs: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...hrs, DEFAULTS.hr()]);
  const rm = i => set(hrs.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...hrs];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updC = (i, yi, v) => {
    const u = [...hrs];
    u[i] = {
      ...u[i],
      count: u[i].count.map((x, j) => j === yi ? Math.max(0, Math.round(v)) : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Costo annuo lordo = costo AZIENDA totale, NON la RAL del dipendente. Include: RAL + contributi INPS (~30%) + INAIL (~1%) + TFR (~7%) + eventuale welfare. Esempio: RAL \u20AC25.000 \u2192 costo azienda ~\u20AC35.000. Il tasso di crescita annuo si applica al costo (rinnovi CCNL, scatti anzianit\xE0). Tipo 'Diretto' = addetti alla produzione; 'Indiretto' = amministrativi, commerciali, management."
  }), hrs.map((h, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: h.role || `Risorsa ${i + 1}`,
    collapsible: true,
    defaultOpen: i === hrs.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Ruolo",
    value: h.role,
    onChange: v => upd(i, "role", v),
    type: "text",
    placeholder: "Es. Sviluppatore"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: h.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "direct",
      label: "Diretto (produz.)"
    }, {
      value: "indirect",
      label: "Indiretto (staff)"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Costo annuo lordo",
    value: h.annualCost,
    onChange: v => upd(i, "annualCost", v),
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Crescita annua",
    value: Math.round(h.growthRate * 100),
    onChange: v => upd(i, "growthRate", v / 100),
    suffix: "%"
  })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "N\xB0 persone per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: h.count[yi],
    onChange: v => updC(i, yi, v),
    min: 0,
    step: 1
  }))))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Risorsa"), hrs.some(h => h.annualCost > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Costi Personale per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Ruolo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), hrs.filter(h => h.annualCost > 0).map((h, i) => /*#__PURE__*/React.createElement("div", {
    key: i
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "5px 0",
      borderBottom: "1px solid #f3f4f6"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      color: "#374151",
      fontWeight: 500
    }
  }, h.role || `Risorsa ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
    color: h.type === "direct" ? "#059669" : "#6366f1"
  }, h.type === "direct" ? "Dir." : "Indir.")), YEARS.slice(0, n).map((_, j) => {
    const cost = h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(cost));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "2px 0 5px",
      borderBottom: "1px solid #f9fafb"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 10,
      color: "#9ca3af",
      paddingLeft: 8
    }
  }, "\xD7 ", "{", "n\xB0 persone", "}"), YEARS.slice(0, n).map((_, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      fontSize: 10,
      fontFamily: "'JetBrains Mono',monospace",
      textAlign: "right",
      color: "#9ca3af"
    }
  }, h.count[j] || 0, " pers. \xD7 ", fmt(Math.round(h.annualCost * Math.pow(1 + h.growthRate, j))), "/cad"))))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE PERSONALE"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(tot));
  })), hrs.some(h => h.type === "direct") && hrs.some(h => h.type === "indirect") && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "4px 0"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      color: "#059669"
    }
  }, "  di cui Diretti"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.filter(h => h.type === "direct").reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 11,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(tot));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "4px 0"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      color: "#6366f1"
    }
  }, "  di cui Indiretti"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.filter(h => h.type === "indirect").reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 11,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#6366f1"
      }
    }, fmt(tot));
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      marginTop: 8,
      borderTop: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      fontWeight: 600,
      color: "#374151"
    }
  }, "ORGANICO TOTALE"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.reduce((s, h) => s + (h.count[j] || 0), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        fontWeight: 700,
        color: "#374151"
      }
    }, tot, " persone");
  })))));
}
function StepOpEx({
  opexItems: items,
  setOpexItems: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...items, DEFAULTS.opex()]);
  const rm = i => set(items.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...items];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updV = (i, yi, v) => {
    const u = [...items];
    u[i] = {
      ...u[i],
      values: u[i].values.map((x, j) => j === yi ? v : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Costi operativi tipici PMI: Affitto (\u20AC300-800/mq anno uffici), Utenze (\u20AC3.000-15.000/anno), Assicurazioni (0,5-2% ricavi), Marketing/commerciale (3-10% ricavi per B2B, 10-20% B2C), Consulenze (commercialista, legale, IT), Software e licenze, Manutenzioni. Metodo fisso: inserisci il valore Anno 1, gli anni successivi cresceranno automaticamente col tasso indicato. Metodo % ricavi: calcolo automatico proporzionale."
  }), items.map((o, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: o.name || `Costo ${i + 1}`,
    collapsible: true,
    defaultOpen: i === items.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Descrizione",
    value: o.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Affitto ufficio"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Categoria",
    value: o.category,
    onChange: v => upd(i, "category", v),
    options: [{
      value: "general",
      label: "Generale"
    }, {
      value: "rent",
      label: "Affitto"
    }, {
      value: "marketing",
      label: "Marketing"
    }, {
      value: "utilities",
      label: "Utenze"
    }, {
      value: "insurance",
      label: "Assicurazione"
    }, {
      value: "other",
      label: "Altro"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Metodo",
    value: o.isPercentOfRevenue ? "percent" : "fixed",
    onChange: v => upd(i, "isPercentOfRevenue", v === "percent"),
    options: [{
      value: "fixed",
      label: "Importo fisso"
    }, {
      value: "percent",
      label: "% sui Ricavi"
    }]
  })), o.isPercentOfRevenue ? /*#__PURE__*/React.createElement(InputField, {
    label: "% sui ricavi",
    value: (o.percentOfRevenue * 100).toFixed(1),
    onChange: v => upd(i, "percentOfRevenue", v / 100),
    suffix: "%",
    step: 0.1
  }) : /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 8
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      display: "block"
    }
  }, "Importi per anno ", /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 400,
      textTransform: "none"
    }
  }, "(lascia 0 per auto-crescita da Anno 1)")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: o.values[yi],
    onChange: v => updV(i, yi, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement(InputField, {
    label: "Tasso di crescita annuo (se auto)",
    value: Math.round(o.growthRate * 100),
    onChange: v => upd(i, "growthRate", v / 100),
    suffix: "%",
    style: {
      maxWidth: 200
    }
  }))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Costo Operativo"), items.some(o => o.values[0] > 0 || o.isPercentOfRevenue) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Costi Operativi per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Voce"), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "center"
    }
  }, "Metodo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), items.filter(o => o.values[0] > 0 || o.isPercentOfRevenue).map((o, i) => {
    const vals = YEARS.slice(0, n).map((_, j) => {
      if (o.isPercentOfRevenue) return null; // can't calc without revenues
      if (o.values[j] > 0) return o.values[j];
      let base = 0,
        baseYear = 0;
      for (let k = j - 1; k >= 0; k--) {
        if (o.values[k] > 0) {
          base = o.values[k];
          baseYear = k;
          break;
        }
      }
      return base > 0 ? base * Math.pow(1 + o.growthRate, j - baseYear) : 0;
    });
    const catLabel = {
      general: "Gen.",
      rent: "Affitto",
      marketing: "Mktg",
      utilities: "Utenze",
      insurance: "Assic.",
      other: "Altro"
    }[o.category] || "";
    return /*#__PURE__*/React.createElement("div", {
      key: i,
      style: {
        display: "grid",
        gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
        gap: 4,
        padding: "5px 0",
        borderBottom: "1px solid #f3f4f6"
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        color: "#374151",
        fontWeight: 500
      }
    }, o.name || `Costo ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
      color: "#d97706"
    }, catLabel)), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 10,
        color: "#6b7280",
        textAlign: "center"
      }
    }, o.isPercentOfRevenue ? `${(o.percentOfRevenue * 100).toFixed(1)}% ric.` : `Fisso +${Math.round(o.growthRate * 100)}%`), vals.map((v, j) => /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: v != null ? "#dc2626" : "#9ca3af"
      }
    }, v != null ? fmt(Math.round(v)) : "% ric.")));
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE COSTI OP."), /*#__PURE__*/React.createElement("span", null), YEARS.slice(0, n).map((_, j) => {
    const tot = items.reduce((s, o) => {
      if (o.isPercentOfRevenue) return s; // skip % items (need revenue context)
      if (o.values[j] > 0) return s + o.values[j];
      let base = 0,
        baseYear = 0;
      for (let k = j - 1; k >= 0; k--) {
        if (o.values[k] > 0) {
          base = o.values[k];
          baseYear = k;
          break;
        }
      }
      return base > 0 ? s + base * Math.pow(1 + o.growthRate, j - baseYear) : s;
    }, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(Math.round(tot)));
  })), items.some(o => o.isPercentOfRevenue) && /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 10,
      color: "#9ca3af",
      fontStyle: "italic"
    }
  }, "* Le voci \"% sui ricavi\" saranno calcolate nei Risultati in base ai ricavi effettivi."))));
}
function StepInvestments({
  investments: invs,
  setInvestments: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...invs, DEFAULTS.investment()]);
  const rm = i => set(invs.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...invs];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "L'ammortamento \xE8 a quote costanti (SLN): Costo \xF7 Vita utile. Vite utili tipiche Italia: Macchinari 7-10 anni, Attrezzature 4-5 anni, Mobili e arredi 8 anni, Autovetture 4 anni, Software/brevetti 3-5 anni, Impianti 10-12 anni, Fabbricati 33 anni. Per beni Industria 4.0: vita utile minore se previsto dal piano Transizione 5.0. Il tipo (Materiale/Immateriale) \xE8 rilevante per i bandi agevolativi."
  }), invs.map((inv, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: inv.name || `Investimento ${i + 1}`,
    collapsible: true,
    defaultOpen: i === invs.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Descrizione",
    value: inv.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Macchinari"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: inv.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "tangible",
      label: "Materiale"
    }, {
      value: "intangible",
      label: "Immateriale"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Costo",
    value: inv.cost,
    onChange: v => upd(i, "cost", v),
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Vita utile",
    value: inv.usefulLife,
    onChange: v => upd(i, "usefulLife", v),
    suffix: "anni",
    min: 1,
    step: 1
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Anno acquisto",
    value: inv.year,
    onChange: v => upd(i, "year", parseInt(v)),
    options: YEARS.slice(0, n).map((_, i) => ({
      value: i,
      label: YL[i]
    }))
  })))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Investimento"));
}
function StepAssumptions({
  assumptions: a,
  setAssumptions: set,
  company: {
    yearsCount: n
  }
}) {
  const upd = (f, v) => set({
    ...a,
    [f]: v
  });
  const updA = (f, i, v) => {
    const arr = [...a[f]];
    arr[i] = v;
    set({
      ...a,
      [f]: arr
    });
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "IRES 24% e IRAP ~5% sono le aliquote standard italiane. IVA 22% ordinaria (10% ridotta, 4% minima). DSO = giorni medi di incasso clienti (PMI Italia: 60-90 gg, PA: fino a 60 gg per legge). DPO = giorni medi pagamento fornitori (tipico: 30-90 gg). DIO = giorni di giacenza magazzino (0 per servizi, 30-60 per commercio, 60-120 per manifattura). Un CCC (DSO+DIO-DPO) alto assorbe cassa e aumenta il fabbisogno di capitale circolante."
  }), /*#__PURE__*/React.createElement(Card, {
    title: "Fiscalit\xE0"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "IRES",
    value: (a.iresRate * 100).toFixed(1),
    onChange: v => upd("iresRate", v / 100),
    suffix: "%",
    tooltip: "24,5% standard"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "IRAP",
    value: (a.irapRate * 100).toFixed(1),
    onChange: v => upd("irapRate", v / 100),
    suffix: "%",
    tooltip: "4,97% standard"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "IVA",
    value: Math.round(a.vatRate * 100),
    onChange: v => upd("vatRate", v / 100),
    suffix: "%"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Capitale Circolante"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "DSO (gg incasso)",
    value: a.dso,
    onChange: v => upd("dso", v),
    suffix: "gg",
    tooltip: "Tempo medio incasso crediti"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "DPO (gg pagamento)",
    value: a.dpo,
    onChange: v => upd("dpo", v),
    suffix: "gg",
    tooltip: "Tempo medio pagamento fornitori"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "DIO (gg magazzino)",
    value: a.dio,
    onChange: v => upd("dio", v),
    suffix: "gg",
    tooltip: "Giacenza media magazzino"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Debito Finanziario"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Tasso di interesse",
    value: (a.interestRate * 100).toFixed(1),
    onChange: v => upd("interestRate", v / 100),
    suffix: "%"
  }), /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Nuovo debito per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.debtAmount[i],
    onChange: v => updA("debtAmount", i, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Rimborso debito per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.debtRepayment[i],
    onChange: v => updA("debtRepayment", i, v),
    suffix: "\u20AC"
  }))))), /*#__PURE__*/React.createElement(Card, {
    title: "Equity e Dividendi"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Apporto equity per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.equityInjection[i],
    onChange: v => updA("equityInjection", i, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement(InputField, {
    label: "Payout dividendi (% utile netto)",
    value: Math.round(a.dividendPayout * 100),
    onChange: v => upd("dividendPayout", v / 100),
    suffix: "%"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Contributi a Fondo Perduto"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Importo contributo",
    value: a.grantAmount,
    onChange: v => upd("grantAmount", v),
    suffix: "\u20AC",
    tooltip: "Es. bando PNRR, fondi regionali, Resto al Sud"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Anni di competenza",
    value: a.grantYears,
    onChange: v => upd("grantYears", v),
    suffix: "anni",
    min: 1,
    step: 1
  })), /*#__PURE__*/React.createElement(Note, null, "Il contributo a fondo perduto viene incassato nell'Anno 1 e riconosciuto a CE in quote costanti sugli anni di competenza. La parte non ancora riconosciuta appare come risconto passivo nello Stato Patrimoniale.")), /*#__PURE__*/React.createElement(Card, {
    title: "Credito d'Imposta (Transizione 5.0 / R&D / Formazione)"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Importo totale credito",
    value: a.taxCreditAmount,
    onChange: v => upd("taxCreditAmount", v),
    suffix: "\u20AC",
    tooltip: "Credito d'imposta maturato sugli investimenti eleggibili"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Anni di fruizione",
    value: a.taxCreditYears,
    onChange: v => upd("taxCreditYears", v),
    suffix: "anni",
    min: 1,
    step: 1,
    tooltip: "Tipico: 3 anni per Transizione 5.0, 3-5 per R&S"
  })), /*#__PURE__*/React.createElement(Note, null, "Il credito d'imposta NON \xE8 un contributo: non va a ricavo ma ", /*#__PURE__*/React.createElement("strong", null, "riduce le imposte"), " (IRES/IRAP). Se le imposte dell'anno sono inferiori al credito disponibile, la differenza non genera rimborso ma si perde. Transizione 5.0: 35-45% su beni strumentali 4.0; R&S: 10-20% su spese ammissibili; Formazione 4.0: 30-60% su costi formativi.")), /*#__PURE__*/React.createElement(Card, {
    title: "TFR \u2014 Trattamento di Fine Rapporto"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Aliquota TFR",
    value: (a.tfrRate * 100).toFixed(2),
    onChange: v => upd("tfrRate", v / 100),
    suffix: "%",
    tooltip: "Standard 7,41% della retribuzione annua lorda"
  })), /*#__PURE__*/React.createElement(Note, null, "Il TFR \xE8 gi\xE0 incluso nel \"costo azienda lordo\" che inserisci nel passo Personale. Qui lo evidenziamo perch\xE9 si accumula come ", /*#__PURE__*/React.createElement("strong", null, "passivit\xE0"), " in bilancio (il dipendente lo incassa solo alla cessazione del rapporto). Per aziende ", ">", " 50 dipendenti il TFR va versato all'INPS o a fondi pensione \u2014 in quel caso il costo \xE8 monetario e puoi impostare l'aliquota a 0%.")), /*#__PURE__*/React.createElement(Card, {
    title: "Tipo Ammortamento Debito"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(SelectField, {
    label: "Metodo",
    value: a.debtType,
    onChange: v => upd("debtType", v),
    options: [{
      value: "manual",
      label: "Manuale (inserisci rimborsi)"
    }, {
      value: "francese",
      label: "Alla francese (rata costante)"
    }]
  }), a.debtType === "francese" && /*#__PURE__*/React.createElement(InputField, {
    label: "Durata finanziamento",
    value: a.debtDuration,
    onChange: v => upd("debtDuration", v),
    suffix: "anni",
    min: 1,
    step: 1
  })), /*#__PURE__*/React.createElement(Note, null, "Ammortamento ", /*#__PURE__*/React.createElement("strong", null, "alla francese"), ": rata costante (quota capitale crescente + quota interessi decrescente). \xC8 il metodo pi\xF9 usato dalle banche italiane per mutui e finanziamenti. Se scegli \"Manuale\", inserisci tu i rimborsi anno per anno sopra.")),
    /*#__PURE__*/React.createElement(Card, { title: "Saldi di Apertura (da Bilancio)" },
      /*#__PURE__*/React.createElement(Tip, { text: "Valori dello stato patrimoniale di partenza (Anno 0). Se hai importato un bilancio, vengono compilati automaticamente. Per startup, lascia tutto a zero." }),
      /*#__PURE__*/React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 12 } },
        /*#__PURE__*/React.createElement(InputField, { label: "Cassa iniziale", value: a.openingCash || 0, onChange: v => upd("openingCash", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Debito finanziario", value: a.openingDebt || 0, onChange: v => upd("openingDebt", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Patrimonio netto", value: a.openingEquity || 0, onChange: v => upd("openingEquity", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Immobilizzazioni nette", value: a.openingFA || 0, onChange: v => upd("openingFA", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Vita utile residua", value: a.openingFALife || 5, onChange: v => upd("openingFALife", v), suffix: "anni", min: 1, step: 1 }),
        /*#__PURE__*/React.createElement(InputField, { label: "Crediti commerciali", value: a.openingAR || 0, onChange: v => upd("openingAR", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Debiti commerciali", value: a.openingAP || 0, onChange: v => upd("openingAP", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "TFR accantonato", value: a.openingTFR || 0, onChange: v => upd("openingTFR", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Rimanenze", value: a.openingInventory || 0, onChange: v => upd("openingInventory", v), suffix: "\u20AC" })
      )
    ));
}
function Gauge({
  label,
  value,
  format,
  thresholds,
  note,
  invert
}) {
  // thresholds: {green:x, yellow:y} â€” green if value>=green, yellow if >=yellow, red otherwise (invert reverses)
  let color = "#6b7280",
    bg = "#f3f4f6",
    icon = "âšª";
  if (value != null && !isNaN(value) && thresholds) {
    const {
      green,
      yellow
    } = thresholds;
    if (invert) {
      if (value <= green) {
        color = "#059669";
        bg = "#ecfdf5";
        icon = "ðŸŸ¢";
      } else if (value <= yellow) {
        color = "#d97706";
        bg = "#fffbeb";
        icon = "ðŸŸ¡";
      } else {
        color = "#dc2626";
        bg = "#fef2f2";
        icon = "ðŸ”´";
      }
    } else {
      if (value >= green) {
        color = "#059669";
        bg = "#ecfdf5";
        icon = "ðŸŸ¢";
      } else if (value >= yellow) {
        color = "#d97706";
        bg = "#fffbeb";
        icon = "ðŸŸ¡";
      } else {
        color = "#dc2626";
        bg = "#fef2f2";
        icon = "ðŸ”´";
      }
    }
  }
  const display = value == null || isNaN(value) ? "N/A" : format === "pct" ? fmtPct(value) : format === "dec2" ? fmt(value, 2) : format === "dec1" ? fmt(value, 1) : format === "eur" ? fmtEur(value) : format === "months" ? Math.round(value) + " mesi" : format === "days" ? value + " gg" : fmt(value);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "14px 16px",
      background: bg,
      borderRadius: 12,
      borderLeft: `4px solid ${color}`,
      display: "flex",
      flexDirection: "column",
      gap: 6
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      fontWeight: 600,
      color: "#6b7280",
      textTransform: "uppercase",
      letterSpacing: ".03em"
    }
  }, label), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11
    }
  }, icon)), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 22,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color
    }
  }, display), note && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      color: "#6b7280",
      lineHeight: 1.4,
      fontStyle: "italic"
    }
  }, note));
}
function HealthCheck({
  financials: f,
  n
}) {
  const warnings = [];
  const tips = [];
  const last = n - 1;

  // DSCR
  f.dscr.slice(0, n).forEach((v, i) => {
    if (v != null && v < 1) warnings.push(`Anno ${i + 1}: DSCR = ${fmt(v, 2)} â€” l'azienda non genera abbastanza cassa per servire il debito. La banca considererÃ  il prestito a rischio.`);
  });
  f.dscr.slice(0, n).forEach((v, i) => {
    if (v != null && v >= 1 && v < 1.2) tips.push(`Anno ${i + 1}: DSCR = ${fmt(v, 2)} â€” sufficiente ma sotto la soglia 1,2Ã— preferita dalle banche. Valuta di ridurre il debito o migliorare l'EBITDA.`);
  });

  // Margini
  if (f.grossMarginPct[last] < 0.25 && f.totalRevenue[last] > 0) warnings.push(`Margine lordo ${fmtPct(f.grossMarginPct[last])} basso. Sotto il 25% la PMI ha poco spazio per coprire i costi fissi. Rivedi pricing o costi di produzione.`);
  if (f.ebitdaMargin[last] < 0 && f.totalRevenue[last] > 0) warnings.push(`EBITDA negativo all'anno ${n}: l'attivitÃ  operativa non Ã¨ sostenibile. I costi fissi superano il margine lordo.`);

  // Equity negativo
  if (f.equity[last] < 0) warnings.push(`Patrimonio netto negativo (â‚¬ ${fmt(f.equity[last])}): causa di scioglimento ex art. 2484 c.c. Serve ricapitalizzazione o aumento dell'equity.`);

  // Art. 2447 CC: PN < 1/3 capitale sociale
  f.art2447.slice(0, n).forEach((v, i) => {
    if (v && f.equity[i] >= 0) warnings.push(`Anno ${i + 1}: Patrimonio netto (â‚¬ ${fmt(f.equity[i])}) inferiore a 1/3 del Capitale Sociale â€” obbligo di ricapitalizzazione ex art. 2447 c.c. L'assemblea deve deliberare riduzione CS o ricapitalizzazione.`);
  });

  // Payback
  if (f.paybackPeriod != null) tips.push(`Payback raggiunto nell'Anno ${f.paybackPeriod + 1}: l'investimento iniziale viene recuperato dalla cassa cumulata. ${f.paybackPeriod <= 1 ? "Ottimo, recupero veloce." : f.paybackPeriod <= 2 ? "Buon tempo di recupero." : "Tempo di recupero medio-lungo, accettabile per investimenti strutturali."}`);
  if (f.paybackPeriod == null && f.cumCash[last] < 0) warnings.push(`Payback NON raggiunto entro l'orizzonte del piano: la cassa cumulata resta negativa. L'investimento non si ripaga nei tempi previsti.`);

  // Tax credit
  if (f.taxCreditUsed.slice(0, n).some(v => v > 0)) tips.push(`Credito d'imposta utilizzato: â‚¬ ${fmt(f.taxCreditUsed.slice(0, n).reduce((s, v) => s + v, 0))} in ${n} anni. Risparmio fiscale effettivo.`);

  // Cash
  if (f.fundingGap.slice(0, n).some(v => v > 0)) warnings.push(`Gap di cassa rilevato: il piano non Ã¨ finanziariamente sostenibile senza copertura aggiuntiva (equity, finanziamento, o taglio costi).`);

  // BEP
  f.bepMargin.slice(0, n).forEach((v, i) => {
    if (v != null && v < 0) warnings.push(`Anno ${i + 1}: i ricavi (â‚¬ ${fmt(f.totalRevenue[i])}) sono sotto il break-even (â‚¬ ${fmt(f.bep[i])}). L'azienda opera in perdita strutturale.`);
  });

  // HR incidence
  if (f.hrOnRevenue[last] > 0.6 && f.totalRevenue[last] > 0) tips.push(`Incidenza personale/ricavi ${fmtPct(f.hrOnRevenue[last])} elevata (>60%). Tipica di startup, ma attenzione alla scalabilitÃ .`);

  // Burn rate
  f.runway.slice(0, n).forEach((v, i) => {
    if (v != null && v < 6) warnings.push(`Anno ${i + 1}: con il burn rate attuale la cassa si esaurisce in ${Math.round(v)} mesi. Runway critico (<6 mesi).`);
  });
  f.runway.slice(0, n).forEach((v, i) => {
    if (v != null && v >= 6 && v < 12) tips.push(`Anno ${i + 1}: runway di ${Math.round(v)} mesi. Sufficiente ma prevedi un piano B di finanziamento.`);
  });

  // Interest coverage
  f.icr.slice(0, n).forEach((v, i) => {
    if (v != null && v < 1.5) warnings.push(`Anno ${i + 1}: Interest Coverage Ratio = ${fmt(v, 1)}Ã— â€” la banca vuole almeno 1,5Ã—. L'EBIT copre a malapena gli interessi.`);
  });

  // D/E
  f.debtEquity.slice(0, n).forEach((v, i) => {
    if (v != null && v > 3) tips.push(`Anno ${i + 1}: Debt/Equity = ${fmt(v, 1)}Ã— â€” leva elevata (>3Ã—). I finanziatori potrebbero richiedere garanzie aggiuntive.`);
  });

  // Positive
  if (warnings.length === 0 && tips.length === 0) tips.push(`Il piano appare equilibrato. Tutti gli indicatori chiave sono entro soglie accettabili.`);
  if (warnings.length === 0 && tips.length === 0) return null;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 8
    }
  }, warnings.map((w, i) => /*#__PURE__*/React.createElement("div", {
    key: "w" + i,
    style: {
      padding: "10px 14px",
      background: "#fef2f2",
      border: "1px solid #fca5a5",
      borderRadius: 10,
      fontSize: 12,
      color: "#991b1b",
      lineHeight: 1.5
    }
  }, "\uD83D\uDD34 ", w)), tips.map((t, i) => /*#__PURE__*/React.createElement("div", {
    key: "t" + i,
    style: {
      padding: "10px 14px",
      background: "#fffbeb",
      border: "1px solid #fde68a",
      borderRadius: 10,
      fontSize: 12,
      color: "#92400e",
      lineHeight: 1.5
    }
  }, "\uD83D\uDCA1 ", t)));
}
function Note({
  children
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "10px 14px",
      background: "#f0f9ff",
      border: "1px solid #bae6fd",
      borderRadius: 10,
      fontSize: 11,
      color: "#0369a1",
      lineHeight: 1.5,
      marginTop: 8
    }
  }, "\uD83D\uDCD8 ", /*#__PURE__*/React.createElement("strong", null, "Nota:"), " ", children);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHART.JS WRAPPER COMPONENT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function ChartCanvas({ type, data, options, height = 280 }) {
  const canvasRef = useRef(null);
  const chartRef = useRef(null);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    if (chartRef.current) chartRef.current.destroy();
    
    const ctx = canvasRef.current.getContext("2d");
    chartRef.current = new Chart(ctx, {
      type,
      data,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: "top", labels: { font: { family: "'DM Sans',sans-serif", size: 11 }, padding: 12, usePointStyle: true } },
          tooltip: { backgroundColor: "#0f2440", titleFont: { family: "'DM Sans',sans-serif" }, bodyFont: { family: "'JetBrains Mono',monospace", size: 11 }, padding: 10, cornerRadius: 8,
            callbacks: { label: (ctx) => { const v = ctx.parsed.y ?? ctx.parsed; return ctx.dataset.label + ": â‚¬ " + fmt(v); } }
          }
        },
        scales: type !== "doughnut" && type !== "pie" && type !== "radar" ? {
          x: { grid: { display: false }, ticks: { font: { family: "'DM Sans',sans-serif", size: 11 } } },
          y: { grid: { color: "#f3f4f6" }, ticks: { font: { family: "'JetBrains Mono',monospace", size: 10 }, callback: v => fmt(v) } }
        } : undefined,
        ...options
      }
    });
    return () => { if (chartRef.current) chartRef.current.destroy(); };
  }, [type, JSON.stringify(data), JSON.stringify(options)]);
  
  return React.createElement("div", { style: { height, position: "relative" } },
    React.createElement("canvas", { ref: canvasRef })
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHARTS PANEL (Tab Grafici)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function ChartsPanel({ financials: f, company }) {
  const n = company.yearsCount;
  const labels = YL.slice(0, n);
  const colors = { blue: "#2563eb", green: "#059669", red: "#dc2626", amber: "#d97706", purple: "#7c3aed", cyan: "#06b6d4", pink: "#ec4899" };
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 20 } },
    // Revenue + EBITDA + Net Income trend
    React.createElement(Card, { title: "ðŸ“ˆ Trend Ricavi, EBITDA, Utile Netto" },
      React.createElement(ChartCanvas, {
        type: "line",
        height: 320,
        data: {
          labels,
          datasets: [
            { label: "Ricavi", data: f.totalRevenue.slice(0, n), borderColor: colors.blue, backgroundColor: colors.blue + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 },
            { label: "EBITDA", data: f.ebitda.slice(0, n), borderColor: colors.green, backgroundColor: colors.green + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 },
            { label: "Utile Netto", data: f.netIncome.slice(0, n), borderColor: colors.purple, backgroundColor: colors.purple + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 }
          ]
        }
      })
    ),
    // Cash Flow waterfall (stacked bar)
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 } },
      React.createElement(Card, { title: "ðŸ’° Cash Flow per AttivitÃ " },
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 280,
          data: {
            labels,
            datasets: [
              { label: "CF Operativo", data: f.cfOperating.slice(0, n), backgroundColor: colors.green + "cc" },
              { label: "CF Investimento", data: f.cfInvesting.slice(0, n), backgroundColor: colors.red + "cc" },
              { label: "CF Finanziamento", data: f.cfFinancing.slice(0, n), backgroundColor: colors.blue + "cc" }
            ]
          },
          options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": â‚¬ " + fmt(ctx.parsed.y) } } } }
        })
      ),
      React.createElement(Card, { title: "ðŸ¦ Cassa Cumulata vs Debito" },
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 280,
          data: {
            labels,
            datasets: [
              { label: "Cassa cumulata", data: f.cumCash.slice(0, n), backgroundColor: f.cumCash.slice(0, n).map(v => v >= 0 ? colors.green + "cc" : colors.red + "cc") },
              { label: "Debito finanziario", data: f.netDebt.slice(0, n).map(v => -v), backgroundColor: colors.amber + "cc" }
            ]
          }
        })
      )
    ),
    // Margins radar
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 } },
      React.createElement(Card, { title: "ðŸŽ¯ Composizione Costi (Ultimo Anno)" },
        React.createElement(ChartCanvas, {
          type: "doughnut",
          height: 260,
          data: {
            labels: ["COGS", "Personale", "Costi Op.", "Ammortamenti", "Interessi", "Imposte"],
            datasets: [{
              data: [f.totalCOGS[n-1], f.hrCosts[n-1], f.opexCosts[n-1], f.depreciation[n-1], f.interest[n-1], f.totalTax[n-1]].map(v => Math.max(0, v)),
              backgroundColor: [colors.red+"cc", colors.blue+"cc", colors.amber+"cc", colors.purple+"cc", colors.cyan+"cc", colors.pink+"cc"]
            }]
          },
          options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.label + ": â‚¬ " + fmt(ctx.parsed) } } } }
        })
      ),
      React.createElement(Card, { title: "ðŸ“Š Margini nel Tempo" },
        React.createElement(ChartCanvas, {
          type: "line",
          height: 260,
          data: {
            labels,
            datasets: [
              { label: "Margine Lordo %", data: f.grossMarginPct.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.blue, tension: 0.3, borderWidth: 2, pointRadius: 4 },
              { label: "EBITDA Margin %", data: f.ebitdaMargin.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.green, tension: 0.3, borderWidth: 2, pointRadius: 4 },
              { label: "Margine Netto %", data: f.netMargin.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.purple, tension: 0.3, borderWidth: 2, pointRadius: 4 }
            ]
          },
          options: { scales: { y: { grid: { color: "#f3f4f6" }, ticks: { callback: v => v + "%" } } }, plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": " + ctx.parsed.y.toFixed(1) + "%" } } } }
        })
      )
    ),
    // BEP vs Revenue
    React.createElement(Card, { title: "ðŸŽ¯ Ricavi vs Break-Even Point" },
      React.createElement(ChartCanvas, {
        type: "bar",
        height: 260,
        data: {
          labels,
          datasets: [
            { label: "Ricavi", data: f.totalRevenue.slice(0, n), backgroundColor: colors.green + "cc" },
            { label: "Break-Even", data: f.bep.slice(0, n).map(v => v || 0), backgroundColor: colors.red + "55", borderColor: colors.red, borderWidth: 2, type: "line", fill: false, tension: 0.3, pointRadius: 5 }
          ]
        }
      })
    )
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SENSITIVITY ANALYSIS PANEL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function SensitivityPanel({ company, revenues, hrs, opexItems, investments, assumptions }) {
  const [sensData, setSensData] = useState(null);
  const [metric, setMetric] = useState("ebitda");
  
  useEffect(() => {
    const timer = setTimeout(() => {
      try { setSensData(runSensitivity(company, revenues, hrs, opexItems, investments, assumptions)); }
      catch(e) { console.error(e); }
    }, 100);
    return () => clearTimeout(timer);
  }, [company, revenues, hrs, opexItems, investments, assumptions]);
  
  if (!sensData) return React.createElement("div", { className: "pulse", style: { textAlign: "center", padding: 40, color: "#6b7280" } }, "Calcolo analisi di sensitivitÃ ...");
  
  const metricLabels = { ebitda: "EBITDA", netIncome: "Utile Netto", cumCash: "Cassa Cumulata" };
  const base = sensData[0]?.[metric]?.base || 0;
  const maxRange = Math.max(...sensData.map(s => Math.abs(s[metric].up - s[metric].down)));
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: `L'analisi di sensitivitÃ  mostra come varia il risultato al variare di ogni singolo parametro (Â±%). I fattori piÃ¹ lunghi sono quelli con maggiore impatto.` }),
    React.createElement("div", { style: { display: "flex", gap: 8, marginBottom: 8 } },
      Object.entries(metricLabels).map(([k, v]) =>
        React.createElement("button", {
          key: k, onClick: () => setMetric(k),
          style: { padding: "6px 14px", borderRadius: 8, border: metric === k ? "2px solid #2563eb" : "1px solid #d1d5db", 
                   background: metric === k ? "#eff6ff" : "#fff", fontFamily: "'DM Sans',sans-serif", fontSize: 12, fontWeight: 600,
                   color: metric === k ? "#2563eb" : "#6b7280", cursor: "pointer" }
        }, v)
      )
    ),
    React.createElement(Card, { title: `ðŸŒªï¸ Tornado Chart â€” ${metricLabels[metric]} (Anno ${company.yearsCount})` },
      React.createElement("div", { style: { padding: "8px 0" } },
        React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: 10, color: "#6b7280", fontWeight: 600, marginBottom: 12, padding: "0 60px 0 160px" } },
          React.createElement("span", null, "â–¼ Scenario negativo"),
          React.createElement("span", null, `Base: â‚¬ ${fmt(base)}`),
          React.createElement("span", null, "Scenario positivo â–²")
        ),
        sensData.map((s, i) => {
          const d = s[metric];
          const low = Math.min(d.up, d.down);
          const high = Math.max(d.up, d.down);
          const range = high - low;
          const pctWidth = maxRange > 0 ? (range / maxRange) * 100 : 0;
          const isInverted = d.down > d.up; // e.g. cost increase hurts
          
          return React.createElement("div", { key: i, style: { display: "flex", alignItems: "center", marginBottom: 8 } },
            React.createElement("span", { style: { width: 150, fontSize: 12, fontWeight: 500, color: "#374151", textAlign: "right", paddingRight: 10, flexShrink: 0 } },
              s.label, React.createElement("span", { style: { color: "#9ca3af", fontSize: 10 } }, ` Â±${Math.round(s.pct * 100)}%`)
            ),
            React.createElement("div", { style: { flex: 1, height: 28, background: "#f3f4f6", borderRadius: 6, position: "relative", overflow: "hidden" } },
              // Base line
              React.createElement("div", { style: { position: "absolute", left: "50%", top: 0, bottom: 0, width: 2, background: "#374151", zIndex: 2 } }),
              // Negative side
              React.createElement("div", { style: {
                position: "absolute", right: "50%", top: 2, bottom: 2, borderRadius: 4,
                width: `${pctWidth / 2}%`, background: "#ef4444cc"
              } }),
              // Positive side
              React.createElement("div", { style: {
                position: "absolute", left: "50%", top: 2, bottom: 2, borderRadius: 4,
                width: `${pctWidth / 2}%`, background: "#22c55ecc"
              } })
            ),
            React.createElement("span", { style: { width: 90, fontSize: 10, fontFamily: "'JetBrains Mono',monospace", color: "#6b7280", paddingLeft: 8, flexShrink: 0 } },
              `Î” â‚¬ ${fmt(Math.abs(range))}`)
          );
        })
      ),
      React.createElement(Note, null, "Il grafico mostra la variazione del ", metricLabels[metric], " al variare di ogni singolo parametro. I fattori in cima al tornado hanno il maggiore impatto e meritano l'analisi piÃ¹ attenta nella preparazione del business plan.")
    )
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MONTE CARLO PANEL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function MonteCarloPanel({ company, revenues, hrs, opexItems, investments, assumptions }) {
  const [mcData, setMcData] = useState(null);
  const [running, setRunning] = useState(false);
  const [mcMetric, setMcMetric] = useState("netIncome");
  const [iterations, setIterations] = useState(500);
  
  const run = useCallback(() => {
    setRunning(true);
    setTimeout(() => {
      try {
        const result = runMonteCarlo(company, revenues, hrs, opexItems, investments, assumptions, iterations);
        setMcData(result);
      } catch(e) { console.error(e); }
      setRunning(false);
    }, 50);
  }, [company, revenues, hrs, opexItems, investments, assumptions, iterations]);
  
  const metricLabels = { revenue: "Ricavi", ebitda: "EBITDA", netIncome: "Utile Netto", cumCash: "Cassa Cumulata", dscr: "DSCR" };
  const d = mcData?.[mcMetric];
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: "La simulazione Monte Carlo genera centinaia di scenari casuali variando simultaneamente volumi, prezzi, margini e costi. Mostra la distribuzione probabilistica dei risultati per valutare il rischio reale del piano." }),
    React.createElement("div", { style: { display: "flex", gap: 12, alignItems: "center", flexWrap: "wrap" } },
      React.createElement(InputField, { label: "Iterazioni", value: iterations, onChange: v => setIterations(Math.max(100, Math.min(5000, v))), style: { maxWidth: 140 } }),
      React.createElement(Btn, { primary: true, onClick: run, disabled: running }, running ? "â³ Calcolo..." : "ðŸŽ² Avvia Simulazione"),
      mcData && React.createElement("span", { style: { fontSize: 12, color: "#059669", fontWeight: 600 } }, `âœ“ ${mcData.iterations} simulazioni completate`)
    ),
    mcData && React.createElement(React.Fragment, null,
      React.createElement("div", { style: { display: "flex", gap: 8, marginTop: 8 } },
        Object.entries(metricLabels).map(([k, v]) =>
          React.createElement("button", {
            key: k, onClick: () => setMcMetric(k),
            style: { padding: "6px 14px", borderRadius: 8, border: mcMetric === k ? "2px solid #7c3aed" : "1px solid #d1d5db",
                     background: mcMetric === k ? "#f5f3ff" : "#fff", fontFamily: "'DM Sans',sans-serif", fontSize: 12, fontWeight: 600,
                     color: mcMetric === k ? "#7c3aed" : "#6b7280", cursor: "pointer" }
          }, v)
        )
      ),
      d && React.createElement(Card, { title: `ðŸŽ² Distribuzione ${metricLabels[mcMetric]} (Anno ${company.yearsCount})` },
        // Histogram
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 260,
          data: {
            labels: d.hist.map(b => fmt(b.x)),
            datasets: [{
              label: "Frequenza",
              data: d.hist.map(b => b.count),
              backgroundColor: d.hist.map(b => b.x >= 0 ? "#22c55eaa" : "#ef4444aa"),
              borderRadius: 3
            }]
          },
          options: {
            plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.parsed.y} simulazioni`, title: items => `â‚¬ ${items[0].label}` } } },
            scales: { x: { display: false }, y: { title: { display: true, text: "Frequenza" } } }
          }
        }),
        // Stats cards
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 10, marginTop: 16 } },
          [
            { label: "Media", value: d.mean, color: "#2563eb" },
            { label: "Mediana (P50)", value: d.p50, color: "#7c3aed" },
            { label: "P5 (worst 5%)", value: d.p5, color: "#dc2626" },
            { label: "P95 (best 5%)", value: d.p95, color: "#059669" }
          ].map(s => React.createElement("div", { key: s.label, style: { padding: 12, background: s.color + "08", borderRadius: 10, borderLeft: `3px solid ${s.color}` } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, s.label),
            React.createElement("div", { style: { fontSize: 16, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: s.color, marginTop: 4 } },
              mcMetric === "dscr" ? fmt(s.value, 2) + "Ã—" : "â‚¬ " + fmt(s.value))
          ))
        ),
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 10, marginTop: 10 } },
          React.createElement("div", { style: { padding: 12, background: d.probPositive >= 0.7 ? "#ecfdf5" : d.probPositive >= 0.5 ? "#fffbeb" : "#fef2f2", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Prob. Positivo"),
            React.createElement("div", { style: { fontSize: 22, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: d.probPositive >= 0.7 ? "#059669" : d.probPositive >= 0.5 ? "#d97706" : "#dc2626" } },
              (d.probPositive * 100).toFixed(0) + "%")
          ),
          React.createElement("div", { style: { padding: 12, background: "#f3f4f6", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Dev. Standard"),
            React.createElement("div", { style: { fontSize: 16, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: "#374151", marginTop: 4 } },
              mcMetric === "dscr" ? fmt(d.std, 2) : "â‚¬ " + fmt(d.std))
          ),
          React.createElement("div", { style: { padding: 12, background: "#f3f4f6", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Range (P5-P95)"),
            React.createElement("div", { style: { fontSize: 14, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: "#374151", marginTop: 4 } },
              mcMetric === "dscr" ? `${fmt(d.p5, 2)} â€” ${fmt(d.p95, 2)}` : `â‚¬ ${fmt(d.p5)} â€” â‚¬ ${fmt(d.p95)}`)
          )
        ),
        React.createElement(Note, null,
          d.probPositive >= 0.8 ? `Con una probabilitÃ  dell'${(d.probPositive*100).toFixed(0)}% di risultato positivo, il piano mostra buona resilienza al rischio.` :
          d.probPositive >= 0.6 ? `La probabilitÃ  del ${(d.probPositive*100).toFixed(0)}% di risultato positivo Ã¨ discreta ma presenta rischi significativi. Considera margini di sicurezza piÃ¹ ampi.` :
          `Solo il ${(d.probPositive*100).toFixed(0)}% delle simulazioni ha esito positivo. Il piano presenta un livello di rischio elevato.`,
          " Il range P5-P95 indica l'intervallo in cui cadrÃ  il risultato nel 90% dei casi."
        )
      )
    )
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SCENARIO COMPARISON PANEL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function ScenarioComparePanel({ company, revenues, hrs, opexItems, investments, assumptions, savedScenarios, onSaveScenario }) {
  const n = company.yearsCount;
  const last = n - 1;
  
  // Compute all 3 scenarios
  const scenarios = useMemo(() => {
    const mults = { base: 1, pessimistic: assumptions.scenarioMultiplier?.pessimistic || 0.85, optimistic: assumptions.scenarioMultiplier?.optimistic || 1.15 };
    return Object.entries(mults).map(([key, mult]) => {
      const scenComp = { ...company, scenario: key };
      const scenAssump = { ...assumptions, scenarioMultiplier: { ...assumptions.scenarioMultiplier, [key]: mult } };
      const f = computeFinancials(scenComp, revenues, hrs, opexItems, investments, scenAssump);
      return { key, label: key === "base" ? "ðŸŽ¯ Base" : key === "pessimistic" ? "âš ï¸ Pessimistico" : "ðŸš€ Ottimistico", mult, financials: f };
    });
  }, [company, revenues, hrs, opexItems, investments, assumptions]);
  
  const metrics = [
    { label: "Ricavi", key: "totalRevenue" },
    { label: "EBITDA", key: "ebitda" },
    { label: "Utile Netto", key: "netIncome" },
    { label: "Cassa Cumulata", key: "cumCash" },
    { label: "DSCR", key: "dscr", dec: 2, suffix: "Ã—" },
    { label: "Margine EBITDA %", key: "ebitdaMargin", pct: true },
    { label: "ROE", key: "roe", pct: true },
    { label: "PFN", key: "pfn" },
    { label: "Current Ratio", key: "currentRatio", dec: 2 },
    { label: "Break-Even (â‚¬)", key: "bep" }
  ];
  
  const colors = { base: "#2563eb", pessimistic: "#dc2626", optimistic: "#059669" };
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: `Confronto side-by-side dei tre scenari: Pessimistico (âˆ’${Math.round((1-assumptions.scenarioMultiplier?.pessimistic||0.85)*100)}% ricavi), Base, Ottimistico (+${Math.round((assumptions.scenarioMultiplier?.optimistic||1.15-1)*100)}% ricavi). Gli scenari modificano solo i volumi di vendita; costi e ipotesi restano invariati.` }),
    
    // Chart comparison
    React.createElement(Card, { title: "ðŸ“Š Confronto Scenari â€” Ricavi e Utile Netto" },
      React.createElement(ChartCanvas, {
        type: "bar",
        height: 300,
        data: {
          labels: YL.slice(0, n),
          datasets: scenarios.flatMap(s => [
            { label: `Ricavi ${s.label}`, data: s.financials.totalRevenue.slice(0, n), backgroundColor: colors[s.key] + "66", borderColor: colors[s.key], borderWidth: 1 },
          ])
        },
        options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": â‚¬ " + fmt(ctx.parsed.y) } } } }
      })
    ),
    
    // KPI comparison table
    React.createElement(Card, { title: "ðŸ“‹ Tabella Comparativa (Anno " + n + ")", accent: true },
      React.createElement("div", { style: { overflowX: "auto" } },
        React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13, fontFamily: "'DM Sans',sans-serif" } },
          React.createElement("thead", null,
            React.createElement("tr", null,
              React.createElement("th", { style: { textAlign: "left", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, textTransform: "uppercase", color: "#6b7280" } }, "KPI"),
              scenarios.map(s => React.createElement("th", { key: s.key, style: { textAlign: "right", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, textTransform: "uppercase", color: colors[s.key], fontWeight: 700 } }, s.label))
            )
          ),
          React.createElement("tbody", null,
            metrics.map((m, i) => React.createElement("tr", { key: m.key, style: { background: i % 2 === 0 ? "#f9fafb" : "transparent" } },
              React.createElement("td", { style: { padding: "8px 12px", fontWeight: 500, color: "#374151" } }, m.label),
              scenarios.map(s => {
                const v = s.financials[m.key]?.[last];
                return React.createElement("td", { key: s.key, style: { padding: "8px 12px", textAlign: "right", fontFamily: "'JetBrains Mono',monospace", fontWeight: 600, color: v < 0 ? "#dc2626" : "#374151" } },
                  m.pct ? fmtPct(v) : m.dec ? fmt(v, m.dec) + (m.suffix || "") : "â‚¬ " + fmt(v));
              })
            ))
          )
        )
      )
    ),
    
    // Saved scenarios
    savedScenarios.length > 0 && React.createElement(Card, { title: "ðŸ“‚ Scenari Salvati" },
      React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 8 } },
        savedScenarios.map((s, i) => React.createElement("div", { key: i, style: { padding: "10px 14px", background: "#f9fafb", borderRadius: 8, display: "flex", justifyContent: "space-between", alignItems: "center" } },
          React.createElement("div", null,
            React.createElement("strong", null, s.name), " â€” ",
            React.createElement("span", { style: { fontSize: 12, color: "#6b7280" } }, `Ricavi: â‚¬ ${fmt(s.revenue)} | EBITDA: â‚¬ ${fmt(s.ebitda)} | Utile: â‚¬ ${fmt(s.netIncome)}`)
          ),
          React.createElement("span", { style: { fontSize: 11, color: "#9ca3af" } }, s.date)
        ))
      )
    ),
    
    React.createElement(Btn, { primary: true, onClick: () => {
      const name = prompt("Nome scenario:", company.name + " - " + new Date().toLocaleDateString("it-IT"));
      if (name) onSaveScenario({
        name,
        date: new Date().toLocaleDateString("it-IT"),
        revenue: scenarios[0].financials.totalRevenue[last],
        ebitda: scenarios[0].financials.ebitda[last],
        netIncome: scenarios[0].financials.netIncome[last]
      });
    } }, "ðŸ’¾ Salva Scenario Corrente")
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BILANCIO IMPORT PANEL (for Step 0)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function ImportBilancioPanel({ setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company }) {
  const [status, setStatus] = useState(null);
  const [parsedData, setParsedData] = useState(null);
  const [errorMsg, setErrorMsg] = useState(null);
  const inputRef = useRef(null);
  
  const handleFile = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    setStatus("loading");
    setErrorMsg(null);
    try {
      const data = await parseBilancioFile(file);
      setParsedData(data);
      setStatus("parsed");
    } catch(err) {
      setStatus("error");
      setErrorMsg(err.message);
    }
    e.target.value = "";
  };
  
  const applyData = () => {
    if (!parsedData) return;
    applyBilancioData(parsedData, setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company);
    setStatus("applied");
  };
  
  // Organize parsed data for display
  const displaySections = parsedData ? [
    { title: "ðŸ“Š Conto Economico", items: [
      ["Ricavi vendite", parsedData.ricavi],
      ["Valore produzione", parsedData.valoreProduzione],
      ["Materie prime", parsedData.materiePrime],
      ["Costi servizi", parsedData.costiServizi],
      ["Godimento beni", parsedData.godimentoBeni],
      ["Personale", parsedData.personale],
      ["Ammortamenti", parsedData.ammortamenti],
      ["Oneri diversi", parsedData.oneriDiversi],
      ["EBITDA (calc.)", parsedData.ebitda],
      ["Margine operativo", parsedData.margineOperativo],
      ["Interessi passivi", parsedData.interessiPassivi],
      ["Imposte", parsedData.imposte],
      ["Utile netto", parsedData.utileNetto],
    ].filter(([_, v]) => v) },
    { title: "ðŸ›ï¸ Stato Patrimoniale", items: [
      ["Capitale sociale", parsedData.capitaleSociale],
      ["Patrimonio netto", parsedData.patrimonioNetto],
      ["Immobilizzazioni immat.", parsedData.immobilizzazioniImmateriali],
      ["Immobilizzazioni mat.", parsedData.immobilizzazioniMateriali],
      ["Cassa", parsedData.cassa],
      ["Crediti commerciali", parsedData.creditiCommerciali || parsedData.creditiTotali],
      ["Rimanenze", parsedData.rimanenze],
      ["Debiti vs banche", parsedData.debitiFinanziari],
      ["Debiti vs fornitori", parsedData.debitiCommerciali],
      ["Debiti totali", parsedData.debitiTotali],
      ["TFR", parsedData.tfr],
    ].filter(([_, v]) => v) },
    { title: "ðŸ‘¥ Organico", items: [
      ["Dipendenti", parsedData.dipendenti],
      ["Costo medio", parsedData.personale && parsedData.dipendenti ? Math.round(parsedData.personale / parsedData.dipendenti) : null],
    ].filter(([_, v]) => v) }
  ].filter(s => s.items.length > 0) : [];
  
  return React.createElement(Card, { title: "ðŸ“¥ Importa Bilancio Esistente (PDF o Excel)" },
    React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 12 } },
      React.createElement("p", { style: { fontSize: 13, color: "#4b5563", lineHeight: 1.6 } },
        "Carica un bilancio in formato ", React.createElement("strong", null, "PDF"), " o ", React.createElement("strong", null, "Excel"),
        " (.pdf, .xlsx, .xls, .csv) per pre-compilare automaticamente il piano economico. Il parser riconosce le voci standard del bilancio CEE italiano (abbreviato e ordinario)."),
      React.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } },
        React.createElement("input", { ref: inputRef, type: "file", accept: ".pdf,.xlsx,.xls,.csv", onChange: handleFile, style: { display: "none" } }),
        React.createElement(Btn, { primary: true, onClick: () => inputRef.current.click() }, "ðŸ“‚ Carica Bilancio (PDF/Excel)"),
        status === "loading" && React.createElement("span", { className: "pulse", style: { fontSize: 12, color: "#6b7280" } }, "â³ Analisi del documento in corso..."),
        status === "applied" && React.createElement("span", { style: { fontSize: 12, color: "#059669", fontWeight: 600 } }, "âœ… Dati importati con successo!"),
        status === "error" && React.createElement("span", { style: { fontSize: 12, color: "#dc2626", fontWeight: 600 } }, "âŒ ", errorMsg)
      ),
      
      // Parsed data display
      parsedData && status === "parsed" && React.createElement("div", { style: { padding: 16, background: "#f9fafb", borderRadius: 12, border: "1px solid #e5e7eb" } },
        React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 } },
          React.createElement("div", { style: { fontSize: 14, fontWeight: 700, color: "#1e3a5f" } }, "ðŸ“‹ Dati estratti dal bilancio"),
          React.createElement("span", { style: { fontSize: 10, color: "#9ca3af", background: "#f3f4f6", padding: "2px 8px", borderRadius: 4 } },
            `Fonte: ${parsedData._source === "pdf" ? "PDF" : "Excel"} | ${parsedData._allLines || "?"} voci analizzate`)
        ),
        displaySections.map((section, si) => React.createElement("div", { key: si, style: { marginBottom: 12 } },
          React.createElement("div", { style: { fontSize: 11, fontWeight: 700, color: "#6b7280", textTransform: "uppercase", letterSpacing: ".03em", marginBottom: 6 } }, section.title),
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))", gap: 6 } },
            section.items.map(([k, v], i) => React.createElement("div", { key: i, style: { padding: "6px 10px", background: "#fff", borderRadius: 6, border: "1px solid #e5e7eb" } },
              React.createElement("span", { style: { fontSize: 10, color: "#6b7280", display: "block" } }, k),
              React.createElement("span", { style: { fontSize: 13, fontFamily: "'JetBrains Mono',monospace", fontWeight: 600, color: v < 0 ? "#dc2626" : "#111827" } },
                typeof v === "number" && k !== "Dipendenti" ? fmtEur(v) : v)
            ))
          )
        )),
        // Computed KPI preview
        parsedData.ricavi && parsedData.margineOperativo && React.createElement("div", { style: { marginTop: 8, padding: "8px 12px", background: "#eff6ff", borderRadius: 8 } },
          React.createElement("span", { style: { fontSize: 11, fontWeight: 600, color: "#1e3a5f" } }, "KPI calcolati: "),
          React.createElement("span", { style: { fontSize: 11, color: "#374151", fontFamily: "'JetBrains Mono',monospace" } },
            `Margine op. ${parsedData.ricavi ? ((parsedData.margineOperativo / parsedData.ricavi) * 100).toFixed(1) : "?"}%`,
            parsedData.ebitda || (parsedData.margineOperativo && parsedData.ammortamenti) ? ` | EBITDA ${fmtEur((parsedData.ebitda || parsedData.margineOperativo + parsedData.ammortamenti))} (${(((parsedData.ebitda || parsedData.margineOperativo + parsedData.ammortamenti) / parsedData.ricavi) * 100).toFixed(1)}%)` : "",
            parsedData.utileNetto ? ` | Utile netto ${fmtEur(parsedData.utileNetto)} (${((parsedData.utileNetto / parsedData.ricavi) * 100).toFixed(1)}%)` : "",
            parsedData.patrimonioNetto && parsedData.utileNetto ? ` | ROE ${((parsedData.utileNetto / parsedData.patrimonioNetto) * 100).toFixed(1)}%` : ""
          ),
          // Show derived gross margin explanation
          React.createElement("div", { style: { fontSize: 10, color: "#6b7280", marginTop: 4 } },
            (() => {
              const realEBITDA = parsedData.ebitda || (parsedData.margineOperativo && parsedData.ammortamenti ? parsedData.margineOperativo + parsedData.ammortamenti : 0);
              const overhead = (parsedData.godimentoBeni || 0) + (parsedData.oneriDiversi || 0);
              const hr = parsedData.personale || 0;
              if (realEBITDA && parsedData.ricavi) {
                const gm = ((realEBITDA + hr + overhead) / parsedData.ricavi * 100).toFixed(1);
                return `ðŸ’¡ Margine lordo derivato: ${gm}% (calcolato da EBITDA reale ${fmtEur(realEBITDA)} + personale ${fmtEur(hr)} + overhead ${fmtEur(overhead)} / ricavi). I costi per servizi (B.7) sono assorbiti nel margine lordo.`;
              }
              return "";
            })()
          )
        ),
        React.createElement("div", { style: { marginTop: 12, display: "flex", gap: 8 } },
          React.createElement(Btn, { primary: true, onClick: applyData }, "âœ… Applica al Piano Economico"),
          React.createElement(Btn, { onClick: () => { setParsedData(null); setStatus(null); } }, "âŒ Annulla")
        )
      ),
      
      React.createElement(Note, null,
        "Formati supportati: ", React.createElement("strong", null, "PDF"), " (bilancio depositato, XBRL convertito), ",
        React.createElement("strong", null, "Excel"), " (esportazioni da TeamSystem, Zucchetti, Buffetti, altri gestionali). ",
        "Il parser cerca automaticamente le voci CEE: ricavi (A.1), costi per servizi (B.7), personale (B.9), ammortamenti (B.10), ",
        "patrimonio netto, debiti finanziari, crediti, disponibilitÃ  liquide, ecc. Per PDF, viene estratto il testo e analizzato con pattern matching. ",
        "Verifica sempre i dati estratti prima di applicarli al piano."
      )
    )
  );
}
/* ═══════ V4: EXECUTIVE SUMMARY & NOTA INTEGRATIVA GENERATORS ═══════ */
function generateExecutiveSummary(company, f, n, revenues, investments, hrs) {
  const last = n - 1;
  const rev0 = f.totalRevenue[0];
  const revN = f.totalRevenue[last];
  const cagr = (f.revenueCAGR * 100).toFixed(1);
  const ebitdaM = (f.ebitdaMargin[last] * 100).toFixed(1);
  const ebitdaV = fmtEur(f.ebitda[last]);
  const profitYear = f.netIncome.findIndex(v => v > 0);
  const dscrLast = f.dscr[last] !== null ? f.dscr[last].toFixed(2) : "N/A";
  const headLast = f.headcount[last];
  const totalInv = investments.reduce((s, inv) => s + inv.cost, 0);
  const bepLast = f.bep[last] ? fmtEur(f.bep[last]) : "N/A";
  const bepM = f.bepMargin[last] !== null ? (f.bepMargin[last] * 100).toFixed(0) + "%" : "N/A";
  
  let text = company.name + " opera nel settore " + (company.sector || "non specificato") + ". ";
  text += "Il piano previsionale copre " + n + " anni (" + YL[0] + "-" + YL[last] + "). ";
  text += "I ricavi passano da " + fmtEur(rev0) + " a " + fmtEur(revN) + " con un CAGR del " + cagr + "%. ";
  text += "L'EBITDA margin a regime raggiunge il " + ebitdaM + "% (" + ebitdaV + "). ";
  if (profitYear >= 0) text += "L'utile netto diventa positivo dall'anno " + (profitYear + 1) + " (" + YL[profitYear] + "). ";
  else text += "Il piano non raggiunge il break-even dell'utile netto nel periodo considerato. ";
  text += "Il DSCR a regime e' pari a " + dscrLast + (parseFloat(dscrLast) >= 1.2 ? " (adeguato per le banche)." : " (sotto la soglia bancaria di 1,2x).") + " ";
  text += "L'organico a regime prevede " + headLast + " risorse. ";
  text += "Gli investimenti totali ammontano a " + fmtEur(totalInv) + ". ";
  text += "Il Break-Even Point a regime e' " + bepLast + " con un margine di sicurezza del " + bepM + ".";
  return text;
}

function generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions) {
  const sections = [];
  // 1. Criteri di redazione
  sections.push({
    title: "1. Criteri di redazione",
    text: "Il presente piano economico-finanziario e' stato redatto secondo i principi contabili italiani (OIC). " +
      "Le imposte sono calcolate con aliquota IRES " + (assumptions.iresRate * 100).toFixed(1) + "% e IRAP " + (assumptions.irapRate * 100).toFixed(2) + "%. " +
      "La base imponibile IRAP e' calcolata come differenza tra Valore della Produzione e Costi della Produzione (esclusa la quota deducibile del costo del personale). " +
      "Le proiezioni coprono " + n + " anni (" + YL[0] + " - " + YL[n-1] + ")."
  });
  // 2. Ipotesi sui ricavi
  const revLines = revenues.map(r => r.name + " (" + r.type + ", prezzo unit. " + fmtEur(r.unitPrice) + ", margine lordo " + (r.grossMargin * 100).toFixed(0) + "%)").join("; ");
  sections.push({
    title: "2. Ipotesi sui ricavi",
    text: "Il piano prevede le seguenti linee di ricavo: " + revLines + ". " +
      "I volumi sono stimati sulla base di analisi di mercato e benchmark di settore" +
      (company.sector ? " (" + company.sector + ")" : "") + "."
  });
  // 3. Struttura dei costi
  const hrRoles = hrs.map(h => h.role + " (" + h.type + ", " + fmtEur(h.annualCost) + "/anno)").join("; ");
  sections.push({
    title: "3. Struttura dei costi",
    text: "Il costo del personale include: " + hrRoles + ". " +
      "Il TFR e' accantonato al tasso del " + ((assumptions.tfrRate || 0.0741) * 100).toFixed(2) + "%. " +
      "I costi operativi comprendono " + opexItems.length + " voci tra fissi e variabili."
  });
  // 4. Piano investimenti
  const invList = investments.map(inv => inv.name + " (" + fmtEur(inv.cost) + ", ammortamento " + inv.usefulLife + " anni)").join("; ");
  sections.push({
    title: "4. Piano investimenti e ammortamenti",
    text: "Gli investimenti previsti sono: " + invList + ". " +
      "L'ammortamento e' calcolato con il metodo a quote costanti (SLN). " +
      "Il totale investimenti ammonta a " + fmtEur(investments.reduce((s, i) => s + i.cost, 0)) + "."
  });
  // 5. Struttura finanziaria
  sections.push({
    title: "5. Struttura finanziaria",
    text: "Capitale Circolante: DSO " + assumptions.dso + "gg, DPO " + assumptions.dpo + "gg, DIO " + assumptions.dio + "gg (CCC: " + f.ccc + "gg). " +
      "Tasso di interesse: " + (assumptions.interestRate * 100).toFixed(2) + "%. " +
      (assumptions.debtType === "francese" ? "Ammortamento debito con metodo francese (rata costante), durata " + (assumptions.debtDuration || 5) + " anni. " : "") +
      (assumptions.grantAmount > 0 ? "Contributo a fondo perduto: " + fmtEur(assumptions.grantAmount) + " ripartito su " + assumptions.grantYears + " anni. " : "")
  });
  // 6. Analisi dei rischi
  const warnings = [];
  if (f.art2447.some(v => v)) warnings.push("Rischio art. 2447 CC (patrimonio netto sotto 1/3 capitale sociale)");
  if (f.dscr.some(v => v !== null && v < 1.2)) warnings.push("DSCR sotto soglia 1,2x in almeno un anno");
  if (f.fundingGap.some(v => v > 0)) warnings.push("Gap di cassa rilevato: necessario fido bancario o copertura aggiuntiva");
  sections.push({
    title: "6. Analisi dei rischi",
    text: warnings.length > 0 ? "Si segnalano le seguenti criticita': " + warnings.join("; ") + "." : "Non si rilevano criticita' significative nel periodo di piano."
  });
  return sections;
}

function StepResults({
  financials: f,
  company,
  assumptions,
  revenues,
  hrs,
  opexItems,
  investments,
  savedScenarios,
  onSaveScenario
}) {
  const n = company.yearsCount;
  const [tab, setTab] = useState("summary");
  const tabs = [{
    id: "summary",
    label: "📝 Sintesi"
  }, {
    id: "dashboard",
    label: "ðŸ“Š Dashboard"
  }, {
    id: "benchmark",
    label: "\uD83C\uDFAF Benchmark"
  }, {
        id: "charts",
    label: "ðŸ“ˆ Grafici"
  }, {
    id: "is",
    label: "Conto Economico"
  }, {
    id: "bs",
    label: "Stato Patrimoniale"
  }, {
    id: "cf",
    label: "Cash Flow"
  }, {
    id: "kpi",
    label: "KPI Avanzati"
  }, {
    id: "sensitivity",
    label: "ðŸŒªï¸ SensitivitÃ "
  }, {
    id: "montecarlo",
    label: "ðŸŽ² Monte Carlo"
  }, {
    id: "scenarios",
    label: "ðŸ”€ Scenari"
  }, {
    id: "nota",
    label: "📋 Nota Integrativa"
  }, {
    id: "multiScenario",
    label: "⚖️ Confronto"
  }];
  const Div = () => /*#__PURE__*/React.createElement("div", {
    style: {
      height: 1,
      background: "#e5e7eb",
      margin: "4px 0"
    }
  });
  const hasFundingGap = f.fundingGap.slice(0, n).some(v => v > 0);
  const last = n - 1;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 4,
      background: "#f3f4f6",
      padding: 4,
      borderRadius: 12,
      flexWrap: "wrap",
      overflowX: "auto"
    }
  }, tabs.map(t => /*#__PURE__*/React.createElement("button", {
    key: t.id,
    onClick: () => setTab(t.id),
    style: {
      flex: 1,
      padding: "10px 12px",
      border: "none",
      borderRadius: 8,
      background: tab === t.id ? "#fff" : "transparent",
      minWidth: 90,
      color: tab === t.id ? "#111827" : "#6b7280",
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: 600,
      fontSize: 12,
      cursor: "pointer",
      boxShadow: tab === t.id ? "0 1px 3px rgba(0,0,0,.08)" : "none",
      transition: "all .2s"
    }
  }, t.label))), tab === "dashboard" && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/
  // V3: Delta Anno 0 -> Previsionale warnings
  f.delta0to1 && React.createElement(Card, { title: "\u26A0\uFE0F Ponte Storico \u2192 Previsionale" },
    React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 6 } },
      [["Ricavi", f.delta0to1.ricavi], ["EBITDA", f.delta0to1.ebitda], ["Utile", f.delta0to1.utile], ["Personale", f.delta0to1.personale]]
        .filter(([_, d]) => d !== null && Math.abs(d) > 0.30)
        .map(([label, delta], i) =>
          React.createElement("div", { key: i, style: { padding: "8px 12px", background: Math.abs(delta) > 0.50 ? "#fee2e2" : "#fef3c7", borderRadius: 8, border: "1px solid " + (Math.abs(delta) > 0.50 ? "#fca5a5" : "#fcd34d"), fontSize: 12 } },
            "\u26A0\uFE0F " + label + ": " + (delta > 0 ? "+" : "") + (delta * 100).toFixed(0) + "% da consuntivo a previsionale. " + (Math.abs(delta) > 0.50 ? "Giustificare nella Nota Metodologica." : "Verificare coerenza.")
          )
        )
    ),
    React.createElement(Note, null, "Variazioni superiori al \u00B130% tra consuntivo e previsionale richiedono giustificazioni per la banca.")
  ),
React.createElement(Card, {
    title: "\uD83C\uDFE5 Health Check \u2014 Diagnosi del Piano",
    accent: true
  }, /*#__PURE__*/React.createElement(HealthCheck, {
    financials: f,
    n: n
  })), /*#__PURE__*/React.createElement(Card, {
    title: "Cruscotto Finanziario \u2014 Ultimo Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: "DSCR",
    value: f.dscr[last],
    format: "dec2",
    thresholds: {
      green: 1.3,
      yellow: 1
    },
    note: "Debt Service Coverage. La banca vuole \u2265 1,2\xD7"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine EBITDA",
    value: f.ebitdaMargin[last],
    format: "pct",
    thresholds: {
      green: 0.15,
      yellow: 0.05
    },
    note: "Sostenibilit\xE0 operativa. Ideale >15%"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine netto",
    value: f.netMargin[last],
    format: "pct",
    thresholds: {
      green: 0.05,
      yellow: 0
    },
    note: "Redditivit\xE0 finale. Positivo = crea valore"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Current Ratio",
    value: f.currentRatio[last],
    format: "dec2",
    thresholds: {
      green: 1.5,
      yellow: 1
    },
    note: "Liquidit\xE0 a breve. <1 = rischio insolvenza"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Debt/Equity",
    value: f.debtEquity[last],
    format: "dec2",
    thresholds: {
      green: 1,
      yellow: 2
    },
    invert: true,
    note: "Leva finanziaria. <1\xD7 = conservativo"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "ROE",
    value: f.roe[last],
    format: "pct",
    thresholds: {
      green: 0.08,
      yellow: 0
    },
    note: "Rendimento del capitale proprio"
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "Break-Even Analysis"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: `BEP Anno ${n}`,
    value: f.bep[last],
    format: "eur",
    thresholds: null,
    note: "Fatturato minimo per coprire tutti i costi fissi"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine di sicurezza",
    value: f.bepMargin[last],
    format: "pct",
    thresholds: {
      green: 0.2,
      yellow: 0.05
    },
    note: "Quanto i ricavi superano il BEP. >20% = buono"
  })), /*#__PURE__*/React.createElement(Note, null, "Il Break-Even Point (BEP) indica il fatturato necessario per raggiungere l'utile zero. Si calcola come: Costi Fissi \xF7 Margine Lordo %. Un margine di sicurezza ", ">", " 20% significa che i ricavi possono calare del 20% prima di andare in perdita.")), /*#__PURE__*/React.createElement(Card, {
    title: "Posizione Finanziaria e Liquidit\xE0"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: `PFN Anno ${n}`,
    value: f.pfn[last],
    format: "eur",
    thresholds: {
      green: 0,
      yellow: -50000
    },
    note: "Posiz. Fin. Netta. Negativa = indebitamento netto"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Ciclo di Cassa",
    value: f.ccc,
    format: "days",
    thresholds: {
      green: 30,
      yellow: 60
    },
    invert: true,
    note: `DSO(${company.yearsCount > 0 ? Math.round(f.ccc + 60 - 30) + "" : ""}) + DIO - DPO`
  })), /*#__PURE__*/React.createElement(Note, null, "La PFN (Posizione Finanziaria Netta) \xE8 la differenza tra liquidit\xE0 e debiti finanziari. \xC8 il primo indicatore che la banca guarda. Se negativa, l'azienda \xE8 esposta; se positiva, ha riserve. Il Ciclo di Cassa (CCC) indica quanti giorni passano tra il pagamento dei fornitori e l'incasso dai clienti."))), f.burnRate.slice(0, n).some(v => v > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDD25 Burn Rate e Runway"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 12
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement("div", {
    key: i,
    style: {
      textAlign: "center"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 600,
      color: "#6b7280",
      textTransform: "uppercase",
      marginBottom: 4
    }
  }, YL[i]), f.burnRate[i] > 0 ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 18,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: "#dc2626"
    }
  }, fmtEur(f.burnRate[i]), "/mese"), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      color: f.runway[i] < 6 ? "#dc2626" : f.runway[i] < 12 ? "#d97706" : "#059669",
      fontWeight: 600,
      marginTop: 4
    }
  }, f.runway[i] != null ? Math.round(f.runway[i]) + " mesi di runway" : "â€”")) : /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      color: "#059669",
      fontWeight: 600
    }
  }, "CF Operativo positivo \u2713")))), /*#__PURE__*/React.createElement(Note, null, "Il burn rate indica quanta cassa viene consumata mensilmente quando il CF operativo \xE8 negativo. Il runway \xE8 il numero di mesi prima che la cassa si esaurisca. Sotto 6 mesi \xE8 critico: serve un'azione immediata (taglio costi, finanziamento, o accelerazione ricavi).")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "CAGR Ricavi"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.revenueCAGR >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtPct(f.revenueCAGR))), /*#__PURE__*/React.createElement(Card, {
    title: `Utile Netto Y${n}`
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.netIncome[last] >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtEur(f.netIncome[last]))), /*#__PURE__*/React.createElement(Card, {
    title: `Cassa Y${n}`
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.cash[last] >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtEur(Math.max(0, f.cash[last])))), /*#__PURE__*/React.createElement(Card, {
    title: "Payback Period"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.paybackPeriod != null ? "#059669" : "#dc2626",
      padding: 4
    }
  }, f.paybackPeriod != null ? `Anno ${f.paybackPeriod + 1}` : "Non raggiunto"))), /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCDD Executive Summary"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      color: "#374151",
      lineHeight: 1.8
    }
  }, /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "Il piano prevede ", /*#__PURE__*/React.createElement("strong", null, "ricavi di \u20AC ", fmt(f.totalRevenue[last])), " all'Anno ", n, f.revenueCAGR > 0 ? `, con un CAGR del ${fmtPct(f.revenueCAGR)}` : "", ".", f.ebitdaMargin[last] >= 0.1 ? ` L'EBITDA margin del ${fmtPct(f.ebitdaMargin[last])} indica una buona efficienza operativa.` : f.ebitdaMargin[last] >= 0 ? ` L'EBITDA margin del ${fmtPct(f.ebitdaMargin[last])} Ã¨ contenuto ma positivo.` : ` L'EBITDA Ã¨ negativo: il business non copre i costi operativi.`), /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, f.netIncome[last] >= 0 ? `L'utile netto di â‚¬ ${fmt(f.netIncome[last])} ` : `La perdita netta di â‚¬ ${fmt(Math.abs(f.netIncome[last]))} `, f.netMargin[last] >= 0.05 ? "rappresenta un margine netto sano. " : f.netMargin[last] >= 0 ? "Ã¨ positivo ma marginale. " : "richiede interventi strutturali. ", f.equity[last] > 0 ? `Il patrimonio netto di â‚¬ ${fmt(f.equity[last])} garantisce soliditÃ  patrimoniale.` : `Il patrimonio netto negativo (â‚¬ ${fmt(f.equity[last])}) richiede ricapitalizzazione urgente.`), /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, f.dscr[last] != null ? `Il DSCR di ${fmt(f.dscr[last], 2)}Ã— ${f.dscr[last] >= 1.2 ? "supera la soglia bancaria di 1,2Ã—, rendendo il piano finanziabile." : "Ã¨ sotto la soglia bancaria di 1,2Ã—, rendendo problematico l'accesso al credito."} ` : "", f.pfn[last] >= 0 ? `La Posizione Finanziaria Netta positiva (â‚¬ ${fmt(f.pfn[last])}) indica autosufficienza finanziaria.` : `La PFN negativa (â‚¬ ${fmt(f.pfn[last])}) evidenzia dipendenza dal credito bancario.`), f.paybackPeriod != null && /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "L'investimento si ripaga nell'", /*#__PURE__*/React.createElement("strong", null, "Anno ", f.paybackPeriod + 1), ", ", f.paybackPeriod <= 1 ? "un tempo eccellente che rassicura gli investitori." : "un orizzonte coerente con la tipologia di investimento."), f.taxCreditUsed.some(v => v > 0) && /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "Il credito d'imposta porta un risparmio fiscale complessivo di ", /*#__PURE__*/React.createElement("strong", null, "\u20AC ", fmt(f.taxCreditUsed.slice(0, n).reduce((s, v) => s + v, 0))), ", migliorando la redditivit\xE0 netta."), f.bepMargin[last] != null && f.bepMargin[last] > 0 && /*#__PURE__*/React.createElement("p", null, "Il margine di sicurezza del ", fmtPct(f.bepMargin[last]), " rispetto al break-even conferma la resilienza del modello a shock di domanda.")))), tab === "is" && /*#__PURE__*/React.createElement(Card, {
    title: "Conto Economico Previsionale",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Ricavi totali",
    values: f.totalRevenue,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costo del venduto",
    values: f.totalCOGS.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "MARGINE LORDO",
    values: f.grossProfit,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine lordo %",
    values: f.grossMarginPct,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costo personale",
    values: f.hrCosts.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costi operativi",
    values: f.opexCosts.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Contributi",
    values: f.grantIncome,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "EBITDA",
    values: f.ebitda,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine EBITDA %",
    values: f.ebitdaMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Ammortamenti",
    values: f.depreciation.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "EBIT",
    values: f.ebit,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Interessi passivi",
    values: f.interest.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Utile ante imposte (EBT)",
    values: f.ebt,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 IRES",
    values: f.ires.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 IRAP",
    values: f.irap.map(v => -v),
    n: n
  }), f.taxCreditUsed.some(v => v > 0) && /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Credito d'imposta",
    values: f.taxCreditUsed,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "UTILE NETTO",
    values: f.netIncome,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine netto %",
    values: f.netMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il Conto Economico mostra se l'attivit\xE0 \xE8 redditizia. L'EBITDA misura la capacit\xE0 di generare cassa dalla gestione operativa. Se l'EBITDA \xE8 negativo, il modello di business ha un problema strutturale indipendentemente dal finanziamento.")), tab === "bs" && /*#__PURE__*/React.createElement(Card, {
    title: "Stato Patrimoniale Previsionale",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase",
      letterSpacing: ".05em"
    }
  }, "ATTIVO"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cassa e disponibilit\xE0",
    values: f.cash.map(v => Math.max(0, v)),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crediti commerciali",
    values: f.ar,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Rimanenze",
    values: f.inventory,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Immobilizzazioni nette",
    values: f.netFA,
    n: n
  }), hasFundingGap && /*#__PURE__*/React.createElement(YearRow, {
    label: "  Fabbisogno (scoperto)",
    values: f.fundingGap,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "TOTALE ATTIVO",
    values: f.totalLiabEq.map(v => Math.abs(v)),
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 12
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase",
      letterSpacing: ".05em"
    }
  }, "PASSIVO E PATRIMONIO NETTO"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debiti commerciali",
    values: f.ap,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debiti tributari",
    values: f.totalTax,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Risconti passivi (contributi)",
    values: f.deferredGrant,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debito finanziario",
    values: f.netDebt,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Fondo TFR",
    values: f.cumTFR,
    n: n
  }), f.revolvingCredit && f.revolvingCredit.some(function(v) { return v > 0; }) && /*#__PURE__*/React.createElement(YearRow, {
    label: "\u26A0\uFE0F Fido di cassa (revolving)",
    values: f.revolvingCredit,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Patrimonio netto",
    values: f.equity,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "TOTALE PASSIVO E PN",
    values: f.totalLiabEq,
    n: n,
    bold: true,
    highlight: true
  }), hasFundingGap && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "\u26A0\uFE0F Fabbisogno finanziario",
    values: f.fundingGap,
    n: n,
    bold: true
  })), /*#__PURE__*/React.createElement(Note, null, "Lo Stato Patrimoniale fotografa la struttura finanziaria dell'azienda. La banca controlla: (1) che il PN sia positivo, (2) che il rapporto Debito/Equity sia ", "<", " 3\xD7, (3) che il current ratio sia ", ">", " 1. Un PN negativo \xE8 causa legale di scioglimento.")), tab === "cf" && /*#__PURE__*/React.createElement(Card, {
    title: "Rendiconto Finanziario (metodo indiretto OIC 10)",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 operativa"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Utile netto",
    values: f.netIncome,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Ammortamenti",
    values: f.depreciation,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + TFR accantonato (non-cash)",
    values: f.tfrAccrual,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \xB1 \u0394 Capitale circolante",
    values: YEARS.map((_, i) => {
      const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
      const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
      return wcTrade + wcTax;
    }),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \xB1 Rettifica contributi",
    values: YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "CF OPERATIVO",
    values: f.cfOperating,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 8
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 di investimento"), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Investimenti",
    values: f.cfInvesting,
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 8
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 di finanziamento"), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Nuovi finanziamenti",
    values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Rimborso debito",
    values: YEARS.map((_, i) => -(assumptions.debtRepayment[i] || 0)),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Apporto equity",
    values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Dividendi",
    values: f.dividends.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "CF FINANZIAMENTO",
    values: f.cfFinancing,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "FLUSSO DI CASSA NETTO",
    values: f.netCF,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cassa cumulata",
    values: f.cumCash,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il Cash Flow mostra se l'azienda genera o brucia cassa. Un CF Operativo negativo per pi\xF9 anni indica che il business non si auto-sostiene. Il CF Finanziamento (debiti + equity) copre il fabbisogno iniziale, ma alla banca interessa che il CF Operativo diventi positivo.")), tab === "kpi" && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "Indici di Redditivit\xE0",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine lordo %",
    values: f.grossMarginPct,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine EBITDA %",
    values: f.ebitdaMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine netto %",
    values: f.netMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROE (Return on Equity)",
    values: f.roe,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROI (Return on Investment)",
    values: f.roi,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROA (Return on Assets)",
    values: f.roa,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cost-to-Income",
    values: f.costToIncome,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Incidenza personale/ricavi",
    values: f.hrOnRevenue,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crescita ricavi YoY",
    values: f.revenueGrowth,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crescita EBITDA YoY",
    values: f.ebitdaGrowth,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il margine lordo dipende dal pricing e dai costi diretti. L'EBITDA margin mostra l'efficienza operativa complessiva. ROE ", ">", " 8% \xE8 buono per una PMI; se il ROE \xE8 N/A, il patrimonio netto \xE8 negativo o in perdita.")), /*#__PURE__*/React.createElement(Card, {
    title: "Indici di Sostenibilit\xE0 Finanziaria (richiesti dalle banche)"
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "DSCR",
    values: f.dscr,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "DSCR Cash-based (EBA)",
    values: f.dscrCash,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ICR (Interest Coverage)",
    values: f.icr,
    n: n,
    dec: 1
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Current ratio",
    values: f.currentRatio,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debt/Equity",
    values: f.debtEquity,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Rapporto indebitamento",
    values: f.debtRatio,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il ", /*#__PURE__*/React.createElement("strong", null, "DSCR"), " (Debt Service Coverage Ratio) \xE8 il rapporto tra EBITDA e servizio del debito (interessi + quote capitale). Le banche italiane richiedono DSCR \u2265 1,2\xD7 per erogare credito. L'", /*#__PURE__*/React.createElement("strong", null, "ICR"), " misura quante volte l'EBIT copre gli interessi. Il ", /*#__PURE__*/React.createElement("strong", null, "Debt/Equity"), " mostra la leva: sopra 3\xD7 i finanziatori richiedono garanzie personali o reali.")), /*#__PURE__*/React.createElement(Card, {
    title: "Analisi Break-Even e Capitale Circolante"
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Costi fissi totali",
    values: f.fixedCosts,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Break-Even Point (\u20AC)",
    values: f.bep,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine di sicurezza",
    values: f.bepMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "PFN",
    values: f.pfn,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "NWC (Cap. Circolante Netto)",
    values: f.nwc,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Organico",
    values: f.headcount,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Ricavo per dipendente",
    values: f.revPerEmp,
    n: n
  }), /*#__PURE__*/React.createElement(Note, null, "Il ", /*#__PURE__*/React.createElement("strong", null, "BEP"), " indica il fatturato minimo per pareggiare. Il ", /*#__PURE__*/React.createElement("strong", null, "margine di sicurezza"), " \xE8 quanto i ricavi superano il BEP: se ", "<", " 10%, basta un piccolo calo delle vendite per andare in perdita. La ", /*#__PURE__*/React.createElement("strong", null, "PFN"), " positiva indica che l'azienda ha pi\xF9 liquidit\xE0 che debiti \u2014 condizione ideale per negoziare con le banche. Il ", /*#__PURE__*/React.createElement("strong", null, "NWC"), " positivo indica che l'attivo corrente copre i debiti a breve."))),
    
    /* â”€â”€â”€ NEW TABS (at top level, outside KPI div) â”€â”€â”€ */
    tab === "benchmark" && React.createElement(Card, { title: "\uD83C\uDFAF Confronto con Benchmark di Settore" },
      React.createElement(Tip, { text: "Confronto KPI del piano con i valori mediani del settore selezionato nello step Azienda." }),
      f.benchmarks && f.benchmarks.comparison && React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13 } },
        React.createElement("thead", null,
          React.createElement("tr", null,
            React.createElement("th", { style: { textAlign: "left", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11 } }, "KPI"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, color: "#1e3a5f" } }, "Tuo Piano (ultimo anno)"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, color: "#6b7280" } }, "Mediana Settore"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f" } }, "")
          )
        ),
        React.createElement("tbody", null,
          f.benchmarks.comparison.map((b, i) => {
            const isGood = b.invert ? (b.actual <= b.benchmark * 1.1) : (b.actual >= b.benchmark * 0.9);
            const isBad = b.invert ? (b.actual > b.benchmark * 1.5) : (b.actual < b.benchmark * 0.5);
            const fVal = b.unit === "pct" ? fmtPct(b.actual) : b.unit === "gg" ? ((b.actual||0) + " gg") : ((b.actual||0).toFixed(1) + "\u00D7");
            const fBen = b.unit === "pct" ? fmtPct(b.benchmark) : b.unit === "gg" ? (b.benchmark + " gg") : (b.benchmark.toFixed(1) + "\u00D7");
            return React.createElement("tr", { key: i, style: { background: i % 2 === 0 ? "#f9fafb" : "#fff" } },
              React.createElement("td", { style: { padding: "10px 12px", fontWeight: 600, color: "#374151" } }, b.kpi),
              React.createElement("td", { style: { textAlign: "center", padding: "10px 12px", fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: isGood ? "#059669" : isBad ? "#dc2626" : "#d97706" } }, fVal),
              React.createElement("td", { style: { textAlign: "center", padding: "10px 12px", fontFamily: "'JetBrains Mono',monospace", color: "#6b7280" } }, fBen),
              React.createElement("td", { style: { textAlign: "center", fontSize: 18 } }, isGood ? "\u2705" : isBad ? "\u274C" : "\u26A0\uFE0F")
            );
          })
        )
      ),
      React.createElement(Note, null, "Benchmark indicativi basati su dati aggregati ISTAT/Cerved per il settore selezionato. Possono variare per dimensione e area geografica.")
    ),
    tab === "charts" && React.createElement(ChartsPanel, { financials: f, company }),
    tab === "sensitivity" && React.createElement(SensitivityPanel, { company, revenues, hrs, opexItems, investments, assumptions }),
    tab === "montecarlo" && React.createElement(MonteCarloPanel, { company, revenues, hrs, opexItems, investments, assumptions }),
    tab === "scenarios" && React.createElement(ScenarioComparePanel, { company, revenues, hrs, opexItems, investments, assumptions, savedScenarios: savedScenarios || [], onSaveScenario: onSaveScenario || (() => {}) }),

    /* V4: Executive Summary Tab */
    tab === "summary" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      React.createElement(Card, { title: "Executive Summary", accent: true },
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 12, marginBottom: 16 } },
          React.createElement("div", { style: { padding: 16, background: "#eff6ff", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "Ricavi " + YL[last]),
            React.createElement("div", { style: { fontSize: 22, fontWeight: 700, color: "#1e40af" } }, fmtEur(f.totalRevenue[last]))
          ),
          React.createElement("div", { style: { padding: 16, background: "#f0fdf4", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "EBITDA Margin"),
            React.createElement("div", { style: { fontSize: 22, fontWeight: 700, color: "#16a34a" } }, (f.ebitdaMargin[last] * 100).toFixed(1) + "%")
          ),
          React.createElement("div", { style: { padding: 16, background: f.netIncome[last] >= 0 ? "#f0fdf4" : "#fef2f2", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "Utile Netto " + YL[last]),
            React.createElement("div", { style: { fontSize: 22, fontWeight: 700, color: f.netIncome[last] >= 0 ? "#16a34a" : "#dc2626" } }, fmtEur(f.netIncome[last]))
          ),
          React.createElement("div", { style: { padding: 16, background: (f.dscr[last] || 0) >= 1.2 ? "#f0fdf4" : "#fef3c7", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "DSCR"),
            React.createElement("div", { style: { fontSize: 22, fontWeight: 700, color: (f.dscr[last] || 0) >= 1.2 ? "#16a34a" : "#d97706" } }, f.dscr[last] !== null ? f.dscr[last].toFixed(2) + "x" : "N/A")
          )
        ),
        React.createElement("div", { style: { lineHeight: 1.7, color: "#374151", fontSize: 14 } },
          generateExecutiveSummary(company, f, n, revenues, investments, hrs)
        )
      )
    ),

    /* V4: Nota Integrativa Tab */
    tab === "nota" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions).map(function(section, idx) {
        return React.createElement(Card, { key: idx, title: section.title },
          React.createElement("div", { style: { lineHeight: 1.7, color: "#374151", fontSize: 14 } }, section.text)
        );
      })
    ),

    /* V4: Multi-Scenario Comparison Tab */
    tab === "multiScenario" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      React.createElement(Card, { title: "Confronto Scenari", accent: true },
        (savedScenarios && savedScenarios.length > 0) ?
          React.createElement("div", { style: { overflowX: "auto" } },
            React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13 } },
              React.createElement("thead", null,
                React.createElement("tr", null,
                  React.createElement("th", { style: { textAlign: "left", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#f9fafb" } }, "KPI"),
                  React.createElement("th", { style: { textAlign: "right", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#eff6ff", fontWeight: 700 } }, "Base (corrente)"),
                  savedScenarios.map(function(sc, si) {
                    return React.createElement("th", { key: si, style: { textAlign: "right", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#f9fafb" } }, sc.name || ("Scenario " + (si + 1)));
                  })
                )
              ),
              React.createElement("tbody", null,
                [
                  ["Ricavi " + YL[last], fmtEur(f.totalRevenue[last]), function(sf) { return fmtEur(sf.totalRevenue[last]); }],
                  ["EBITDA " + YL[last], fmtEur(f.ebitda[last]), function(sf) { return fmtEur(sf.ebitda[last]); }],
                  ["EBITDA Margin", (f.ebitdaMargin[last] * 100).toFixed(1) + "%", function(sf) { return (sf.ebitdaMargin[last] * 100).toFixed(1) + "%"; }],
                  ["Utile Netto " + YL[last], fmtEur(f.netIncome[last]), function(sf) { return fmtEur(sf.netIncome[last]); }],
                  ["DSCR", f.dscr[last] !== null ? f.dscr[last].toFixed(2) + "x" : "N/A", function(sf) { return sf.dscr[last] !== null ? sf.dscr[last].toFixed(2) + "x" : "N/A"; }],
                  ["Cassa Cumulata", fmtEur(f.cumCash[last]), function(sf) { return fmtEur(sf.cumCash[last]); }],
                  ["PFN", fmtEur(f.pfn[last]), function(sf) { return fmtEur(sf.pfn[last]); }],
                  ["Organico", String(f.headcount[last]), function(sf) { return String(sf.headcount[last]); }]
                ].map(function(row, ri) {
                  return React.createElement("tr", { key: ri },
                    React.createElement("td", { style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", fontWeight: 600 } }, row[0]),
                    React.createElement("td", { style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", textAlign: "right", fontWeight: 700, color: "#1e40af" } }, row[1]),
                    savedScenarios.map(function(sc, si) {
                      var scFin = computeFinancials(sc.company || company, sc.revenues || revenues, sc.hrs || hrs, sc.opexItems || opexItems, sc.investments || investments, sc.assumptions || assumptions);
                      return React.createElement("td", { key: si, style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", textAlign: "right" } }, row[2](scFin));
                    })
                  );
                })
              )
            )
          )
        :
          React.createElement("div", { style: { textAlign: "center", padding: 40, color: "#9ca3af" } },
            React.createElement("div", { style: { fontSize: 40, marginBottom: 12 } }, "\u2696\uFE0F"),
            React.createElement("div", { style: { fontSize: 14 } }, "Nessuno scenario salvato. Vai alla tab \"Scenari\" per salvare scenari (Base, Pessimistico, Ottimistico) e confrontarli qui.")
          )
      )
    )

    );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAIN APP
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function App() {
  const [step, setStep] = useState(0);
  const [company, setCompany] = useState(DEFAULTS.company);
  const [revenues, setRevenues] = useState([DEFAULTS.revenueLine()]);
  const [hrs, setHrs] = useState([DEFAULTS.hr()]);
  const [opexItems, setOpexItems] = useState([DEFAULTS.opex()]);
  const [investments, setInvestments] = useState([DEFAULTS.investment()]);
  const [assumptions, setAssumptions] = useState(DEFAULTS.assumptions);
  const [savedScenarios, setSavedScenarios] = useState([]);
  const fileRef = useRef(null);
  updateYL(company);
  const financials = useMemo(() => computeFinancials(company, revenues, hrs, opexItems, investments, assumptions), [company, revenues, hrs, opexItems, investments, assumptions]);
  const exportJSON = () => {
    const data = {
      version: "1.0",
      type: "piano-economico",
      company,
      revenues,
      hrs,
      opexItems,
      investments,
      assumptions,
      generatedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json"
    });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `piano-economico-${sanitizeName(company.name)}.json`;
    a.click();
  };
  const importJSON = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.company) setCompany({
          ...DEFAULTS.company,
          ...data.company
        });
        if (data.revenues) setRevenues(data.revenues);
        if (data.hrs) setHrs(data.hrs);
        if (data.opexItems) setOpexItems(data.opexItems);
        if (data.investments) setInvestments(data.investments);
        if (data.assumptions) {
          const merged = {
            ...DEFAULTS.assumptions,
            ...data.assumptions
          };
          // Deep merge nested objects
          if (data.assumptions.scenarioMultiplier) merged.scenarioMultiplier = {
            ...DEFAULTS.assumptions.scenarioMultiplier,
            ...data.assumptions.scenarioMultiplier
          };
          // Ensure arrays have correct length
          ["debtAmount", "debtRepayment", "equityInjection"].forEach(k => {
            if (!Array.isArray(merged[k]) || merged[k].length < 5) merged[k] = [...(merged[k] || []), ...[0, 0, 0, 0, 0]].slice(0, 5);
          });
          setAssumptions(merged);
        }
        alert("âœ… Piano importato correttamente!");
      } catch (err) {
        alert("âŒ Errore: file non valido. Usa un file .json generato da questa app.");
      }
    };
    reader.readAsText(file);
    e.target.value = "";
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      minHeight: "100vh"
    }
  }, /*#__PURE__*/React.createElement("header", {
    style: {
      background: "linear-gradient(135deg,#0f2440 0%,#1e3a5f 50%,#1a365d 100%)",
      padding: "16px 32px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      borderBottom: "3px solid #d4af37"
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h1", {
    style: {
      margin: 0,
      fontSize: 22,
      fontFamily: "'Playfair Display',serif",
      fontWeight: 900,
      color: "#fff"
    }
  }, "Piano Economico"), /*#__PURE__*/React.createElement("p", {
    style: {
      margin: "2px 0 0",
      fontSize: 12,
      color: "#94a3b8",
      fontWeight: 500
    }
  }, company.name || "Nuova Azienda", company.scenario !== "base" && /*#__PURE__*/React.createElement(Badge, {
    color: "#d4af37"
  }, company.scenario === "pessimistic" ? "Pessimistico" : "Ottimistico"))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8,
      flexWrap: "wrap"
    }
  }, /*#__PURE__*/React.createElement("input", {
    ref: fileRef,
    type: "file",
    accept: ".json",
    onChange: importJSON,
    style: {
      display: "none"
    }
  }), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => fileRef.current.click()
  }, "\uD83D\uDCC2 Importa JSON"), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: exportJSON
  }, "\uD83D\uDCBE Esporta JSON"), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD7 Esporta Excel"), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD5 Esporta PDF"))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      maxWidth: 1200,
      margin: "0 auto",
      padding: "0 16px",
      gap: 24
    }
  }, /*#__PURE__*/React.createElement("nav", {
    style: {
      width: 200,
      flexShrink: 0,
      paddingTop: 24,
      position: "sticky",
      top: 0,
      height: "fit-content"
    }
  }, STEPS.map(s => {
    const vld = s.id < 7 ? getStepValidation(s.id, company, revenues, hrs, opexItems, investments) : "ok";
    const dotCol = vld === "ok" ? "#059669" : vld === "partial" ? "#d97706" : "#d1d5db";
    return React.createElement("button", {
    key: s.id,
    onClick: () => setStep(s.id),
    style: {
      display: "flex", alignItems: "center", gap: 10, width: "100%",
      padding: "12px 16px", border: "none", borderRadius: 10, marginBottom: 4,
      background: step === s.id ? "#fff" : "transparent",
      boxShadow: step === s.id ? "0 2px 8px rgba(0,0,0,.06)" : "none",
      cursor: "pointer", textAlign: "left", transition: "all .2s"
    }
  }, React.createElement("span", { style: { fontSize: 18 } }, s.icon),
  React.createElement("div", { style: { flex: 1 } },
    React.createElement("div", { style: { fontSize: 13, fontWeight: step === s.id ? 700 : 500, color: step === s.id ? "#1e3a5f" : "#6b7280" } }, s.label),
    React.createElement("div", { style: { fontSize: 10, color: "#9ca3af", marginTop: 1 } }, s.id + 1, "/", STEPS.length)
  ),
  React.createElement("div", { style: { width: 8, height: 8, borderRadius: "50%", background: dotCol, flexShrink: 0 } })
  ); }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 16,
      padding: 14,
      background: "#fff",
      borderRadius: 12,
      border: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 10,
      color: "#6b7280",
      fontWeight: 600,
      textTransform: "uppercase",
      marginBottom: 8,
      letterSpacing: ".05em"
    }
  }, "Anteprima Anno 1"), [["Ricavi", financials.totalRevenue[0]], ["EBITDA", financials.ebitda[0]], ["Utile", financials.netIncome[0]], ["Cassa", financials.cumCash[0]]].map(([l, v]) => /*#__PURE__*/React.createElement("div", {
    key: l,
    style: {
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12,
      marginBottom: 4
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, l), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 600,
      color: v >= 0 ? "#059669" : "#dc2626"
    }
  }, fmt(v)))), financials.dscr[0] != null && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8,
      paddingTop: 8,
      borderTop: "1px solid #f3f4f6",
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, "DSCR"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: financials.dscr[0] >= 1.2 ? "#059669" : financials.dscr[0] >= 1 ? "#d97706" : "#dc2626"
    }
  }, fmt(financials.dscr[0], 2), "\xD7")), financials.bepMargin[0] != null && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12,
      marginTop: 2
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, "vs BEP"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 600,
      color: financials.bepMargin[0] >= 0.1 ? "#059669" : financials.bepMargin[0] >= 0 ? "#d97706" : "#dc2626"
    }
  }, fmtPct(financials.bepMargin[0])))), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 12,
      padding: 14,
      background: "#f0f9ff",
      borderRadius: 12,
      border: "1px solid #bae6fd",
      fontSize: 11,
      color: "#0369a1",
      lineHeight: 1.5
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Esporta come:"), /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCD7 Excel \u2014 foglio modificabile", /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCD5 PDF \u2014 report stampabile", /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCBE JSON \u2014 ricarica qui")), /*#__PURE__*/React.createElement("main", {
    style: {
      flex: 1,
      paddingTop: 24,
      paddingBottom: 80,
      minWidth: 0
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "fade-in"
  }, step === 0 && /*#__PURE__*/React.createElement(StepCompany, {
    company: company,
    setCompany: setCompany,
    setRevenues: setRevenues,
    setHrs: setHrs,
    setOpexItems: setOpexItems,
    setInvestments: setInvestments,
    setAssumptions: setAssumptions
  }), step === 1 && /*#__PURE__*/React.createElement(StepRevenue, {
    revenues: revenues,
    setRevenues: setRevenues,
    company: company
  }), step === 2 && /*#__PURE__*/React.createElement(StepProduction, {
    revenues: revenues,
    investments: investments,
    company: company
  }), step === 3 && /*#__PURE__*/React.createElement(StepHR, {
    hrs: hrs,
    setHrs: setHrs,
    company: company
  }), step === 4 && /*#__PURE__*/React.createElement(StepOpEx, {
    opexItems: opexItems,
    setOpexItems: setOpexItems,
    company: company
  }), step === 5 && /*#__PURE__*/React.createElement(StepInvestments, {
    investments: investments,
    setInvestments: setInvestments,
    company: company
  }), step === 6 && /*#__PURE__*/React.createElement(StepAssumptions, {
    assumptions: assumptions,
    setAssumptions: setAssumptions,
    company: company
  }), step === 7 && /*#__PURE__*/React.createElement(StepResults, {
    financials: financials,
    company: company,
    assumptions: assumptions,
    revenues: revenues,
    hrs: hrs,
    opexItems: opexItems,
    investments: investments,
    savedScenarios: savedScenarios,
    onSaveScenario: (s) => setSavedScenarios(prev => [...prev, s])
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      marginTop: 32,
      paddingTop: 20,
      borderTop: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement(Btn, {
    onClick: () => setStep(Math.max(0, step - 1)),
    disabled: step === 0
  }, "\u2190 Indietro"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8
    }
  }, step === 7 && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Btn, {
    onClick: () => exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD7 Excel"), /*#__PURE__*/React.createElement(Btn, {
    onClick: () => exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD5 PDF")), step < STEPS.length - 1 ? /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: () => {
      // V4: Validazione prima dei risultati
      if (step === 6) {
        const warns = [];
        if (revenues.every(r => r.volumes.every(v => !v || v === 0))) warns.push("Nessun ricavo inserito");
        if (hrs.every(h => h.count.every(c => !c || c === 0))) warns.push("Nessuna risorsa nel personale");
        if (investments.length === 0 || investments.every(inv => !inv.cost || inv.cost === 0)) warns.push("Nessun investimento inserito");
        if (warns.length > 0 && !confirm("Dati incompleti:\n\n\u2022 " + warns.join("\n\u2022 ") + "\n\nI risultati potrebbero non essere significativi.\nVuoi procedere comunque?")) return;
      }
      setStep(step + 1);
    }
  }, "Avanti \u2192") : /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: exportJSON
  }, "\uD83D\uDCBE Salva Piano"))))));
}
ReactDOM.render(/*#__PURE__*/React.createElement(App, null), document.getElementById("root"));
</script>
</body>
</html>
