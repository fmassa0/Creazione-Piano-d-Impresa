<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Piano Economico v5.2 ‚Äî Generatore Business Plan</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
body{font-family:'DM Sans',sans-serif;background:linear-gradient(180deg,#f8fafc 0%,#eef2f7 100%);min-height:100vh;color:#111827}
input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{opacity:1}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:#f1f5f9}::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:3px}
.fade-in{animation:fadeIn .3s ease}@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
.pulse{animation:pulse 2s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}
@media(max-width:900px){
  .v4-sidebar{display:none!important}
  .v4-content{margin-left:0!important;padding:12px!important}
  .v4-mobile-tabs{display:flex!important}
}
@media(max-width:600px){
  .v4-content [style*="gridTemplateColumns"]{grid-template-columns:1fr!important}
  .v4-card{padding:12px!important}
}
.v4-mobile-tabs{display:none;overflow-x:auto;gap:4px;padding:8px 0;border-bottom:1px solid #e5e7eb;margin-bottom:12px}
.v4-mobile-tabs button{flex-shrink:0;padding:6px 12px;font-size:11px;white-space:nowrap;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer}
.v4-mobile-tabs button.active{background:#1e40af;color:#fff;border-color:#1e40af}
.step-enter{animation:stepEnter .35s cubic-bezier(.4,0,.2,1)}
@keyframes stepEnter{from{opacity:0;transform:translateX(16px)}to{opacity:1;transform:translateX(0)}}
.v4-progress{height:3px;background:#e5e7eb;border-radius:2px;overflow:hidden}
.v4-progress-bar{height:100%;background:linear-gradient(90deg,#1e40af,#3b82f6);border-radius:2px;transition:width .4s cubic-bezier(.4,0,.2,1)}
.v4-warn-badge{display:inline-flex;align-items:center;gap:4px;padding:6px 12px;background:#fefce8;border:1px solid #fde68a;border-radius:8px;font-size:12px;color:#92400e;margin-top:8px}
.v4-onboard-overlay{position:fixed;inset:0;background:rgba(15,36,64,.7);backdrop-filter:blur(4px);z-index:1000;display:flex;align-items:center;justify-content:center}
.v4-onboard-card{background:#fff;border-radius:20px;padding:40px;max-width:520px;width:90%;text-align:center;box-shadow:0 24px 48px rgba(0,0,0,.15);animation:stepEnter .5s cubic-bezier(.4,0,.2,1)}
.v4-onboard-card h2{font-family:'Playfair Display',serif;font-size:26px;color:#0f2440;margin-bottom:8px}
.v4-onboard-card p{color:#6b7280;font-size:14px;line-height:1.6;margin-bottom:20px}
.v4-onboard-btn{padding:12px 32px;background:linear-gradient(135deg,#0f2440,#1e40af);color:#fff;border:none;border-radius:12px;font-size:15px;font-weight:600;cursor:pointer;transition:transform .15s}
.v4-onboard-btn:hover{transform:scale(1.03)}
</style>
</head>
<body>
<div id="root"></div>
<script>
const {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef
} = React;

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   CONSTANTS
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
const YEARS = [0, 1, 2, 3, 4];
let YL = ["Anno 1", "Anno 2", "Anno 3", "Anno 4", "Anno 5"];
function updateYL(company) {
  const sy = company && company.startYear ? company.startYear : new Date().getFullYear();
  YL[0] = String(sy); YL[1] = String(sy+1); YL[2] = String(sy+2); YL[3] = String(sy+3); YL[4] = String(sy+4);
}
// V5.1: Fix encoding UTF-8, DSCR CADS, sval.crediti OIC15, debiti prev. D13, metriche EBA, interessi Y1, RAL‚ÜîCosto sync
// V5.2: Fix PDF grafici (var f), SP quadratura (arNetto+sval CF), B9 decomposizione, DSCR CADS negativo, Bilancio Civilistico 2424/2425
// V5.0: Sprint 1 - Fix motore calcolo (IRES 24%, perdite fiscali, IRAP cuneo, TFR da RAL, PN 10 voci, amm.to 50%)
// V4.6: Multi-lingua (IT/EN) expanded
const I18N = {
  it: {
    appTitle: "Piano Economico",
    stepAzienda: "Azienda", stepRicavi: "Ricavi", stepProduzione: "Produzione",
    stepPersonale: "Personale", stepCosti: "Costi Op.", stepInvestimenti: "Investimenti",
    stepIpotesi: "Ipotesi", stepRisultati: "Risultati",
    descAzienda: "Info generali e scenario", descRicavi: "Linee di prodotto/servizio",
    descProduzione: "Costi diretti e margini", descPersonale: "Organico e costi HR",
    descCosti: "Affitti, utenze, marketing", descInvestimenti: "CapEx e ammortamenti",
    descIpotesi: "Fiscalit\u00E0, WC, debito", descRisultati: "CE, SP, CF, KPI",
    avanti: "Avanti \u2192", indietro: "\u2190 Indietro",
    exportPdf: "\uD83D\uDCD5 PDF", exportExcel: "\uD83D\uDCD7 Excel",
    exportJson: "\uD83D\uDCBE Salva Piano", importJson: "\uD83D\uDCC2 Importa JSON",
    exportPdfFull: "\uD83D\uDCD5 Esporta PDF", exportExcelFull: "\uD83D\uDCD7 Esporta Excel",
    exportJsonFull: "\uD83D\uDCBE Esporta JSON", importJsonFull: "\uD83D\uDCC2 Importa JSON",
    salvaPiano: "\uD83D\uDCBE Salva Piano",
    ricaviTotali: "Ricavi totali", costoVenduto: "Costo del venduto",
    margineLordo: "MARGINE LORDO", ebitda: "EBITDA", utileNetto: "Utile netto",
    ce: "Conto Economico", sp: "Stato Patrimoniale", cf: "Rendiconto Finanziario",
    kpi: "KPI", benchmark: "Benchmark", sintesi: "Sintesi",
    anteprimaAnno1: "Anteprima Anno 1", ricavi: "Ricavi", cassa: "Cassa", utile: "Utile",
    datiIncompleti: "Dati incompleti",
    warnVolumi: "Tutti i volumi ricavi sono a zero",
    warnPersonale: "Nessuna risorsa nel personale",
    warnInvestimenti: "Nessun investimento inserito",
    warnProcedere: "I risultati potrebbero non essere significativi. Procedere?",
    warnMargineAlto: "Margine lordo molto alto per il settore",
    warnMargineBasso: "Margine lordo molto basso per il settore",
    warnCrescitaAlta: "Tasso di crescita aggressivo (>30%)",
    warnHrAlto: "Incidenza personale/ricavi elevata rispetto al settore",
    warnDsoAlto: "DSO molto alto: fabbisogno di WC elevato",
    warnDebitoAlto: "Indebitamento elevato rispetto agli investimenti",
    onboardTitle: "Benvenuto nel Piano Economico",
    onboardDesc: "Compila passo per passo le informazioni della tua azienda. Al termine avrai un business plan completo con CE, SP, Cash Flow, KPI e benchmark, pronto per la banca o per un bando agevolato.",
    onboardBtn: "Inizia il piano \u2192",
    lang: "it"
  },
  en: {
    appTitle: "Financial Plan",
    stepAzienda: "Company", stepRicavi: "Revenue", stepProduzione: "Production",
    stepPersonale: "Personnel", stepCosti: "OpEx", stepInvestimenti: "Investments",
    stepIpotesi: "Assumptions", stepRisultati: "Results",
    descAzienda: "General info & scenario", descRicavi: "Product/service lines",
    descProduzione: "Direct costs & margins", descPersonale: "Headcount & HR costs",
    descCosti: "Rent, utilities, marketing", descInvestimenti: "CapEx & depreciation",
    descIpotesi: "Tax, WC, debt", descRisultati: "P&L, BS, CF, KPIs",
    avanti: "Next \u2192", indietro: "\u2190 Back",
    exportPdf: "\uD83D\uDCD5 PDF", exportExcel: "\uD83D\uDCD7 Excel",
    exportJson: "\uD83D\uDCBE Save Plan", importJson: "\uD83D\uDCC2 Import JSON",
    exportPdfFull: "\uD83D\uDCD5 Export PDF", exportExcelFull: "\uD83D\uDCD7 Export Excel",
    exportJsonFull: "\uD83D\uDCBE Export JSON", importJsonFull: "\uD83D\uDCC2 Import JSON",
    salvaPiano: "\uD83D\uDCBE Save Plan",
    ricaviTotali: "Total Revenue", costoVenduto: "Cost of goods sold",
    margineLordo: "GROSS MARGIN", ebitda: "EBITDA", utileNetto: "Net income",
    ce: "Income Statement", sp: "Balance Sheet", cf: "Cash Flow Statement",
    kpi: "KPIs", benchmark: "Benchmark", sintesi: "Summary",
    anteprimaAnno1: "Year 1 Preview", ricavi: "Revenue", cassa: "Cash", utile: "Net Income",
    datiIncompleti: "Incomplete data",
    warnVolumi: "All revenue volumes are zero",
    warnPersonale: "No personnel resources entered",
    warnInvestimenti: "No investments entered",
    warnProcedere: "Results may not be meaningful. Continue?",
    warnMargineAlto: "Gross margin very high for the sector",
    warnMargineBasso: "Gross margin very low for the sector",
    warnCrescitaAlta: "Aggressive growth rate (>30%)",
    warnHrAlto: "Personnel/revenue ratio high vs sector",
    warnDsoAlto: "Very high DSO: large WC requirement",
    warnDebitoAlto: "High debt relative to investments",
    onboardTitle: "Welcome to the Financial Planner",
    onboardDesc: "Fill in your company details step by step. You will get a complete business plan with P&L, Balance Sheet, Cash Flow, KPIs and benchmarks, ready for banks or grant applications.",
    onboardBtn: "Start planning \u2192",
    lang: "en"
  }
};
function getSteps(lng) {
  var tr = I18N[lng] || I18N.it;
  return [
    { id: 0, label: tr.stepAzienda, icon: "\uD83C\uDFE2", desc: tr.descAzienda },
    { id: 1, label: tr.stepRicavi, icon: "\uD83D\uDCC8", desc: tr.descRicavi },
    { id: 2, label: tr.stepProduzione, icon: "\uD83C\uDFED", desc: tr.descProduzione },
    { id: 3, label: tr.stepPersonale, icon: "\uD83D\uDC65", desc: tr.descPersonale },
    { id: 4, label: tr.stepCosti, icon: "\uD83D\uDCBC", desc: tr.descCosti },
    { id: 5, label: tr.stepInvestimenti, icon: "\uD83D\uDD27", desc: tr.descInvestimenti },
    { id: 6, label: tr.stepIpotesi, icon: "\u2699\uFE0F", desc: tr.descIpotesi },
    { id: 7, label: tr.stepRisultati, icon: "\uD83D\uDCCA", desc: tr.descRisultati }
  ];
}

const STEPS = [{
  id: 0,
  label: "Azienda",
  icon: "üè¢",
  desc: "Info generali e scenario"
}, {
  id: 1,
  label: "Ricavi",
  icon: "üìà",
  desc: "Linee di prodotto/servizio"
}, {
  id: 2,
  label: "Produzione",
  icon: "üè≠",
  desc: "Costi diretti e margini"
}, {
  id: 3,
  label: "Personale",
  icon: "üë•",
  desc: "Organico e costi HR"
}, {
  id: 4,
  label: "Costi Op.",
  icon: "üíº",
  desc: "Affitti, utenze, marketing"
}, {
  id: 5,
  label: "Investimenti",
  icon: "üîë",
  desc: "CapEx e ammortamenti"
}, {
  id: 6,
  label: "Ipotesi",
  icon: "‚öôÔ∏è",
  desc: "Fiscalit√†, WC, debito"
}, {
  id: 7,
  label: "Risultati",
  icon: "üìä¬†",
  desc: "CE, SP, CF, KPI"
}];
const eY = () => [0, 0, 0, 0, 0];
const eY1 = () => [1, 1, 1, 1, 1];
const DEFAULTS = {
  company: {
    name: "",
    sector: "",
    currency: "EUR",
    yearsCount: 3,
    scenario: "base",
    capitaleSociale: 10000,
    isExisting: false,
    companyType: "nuova_impresa",
    startYear: new Date().getFullYear(),
    sectorTemplate: "altro",
    bilpianoAnno0: null,
    bilpianoAnnoM1: null
  },
  revenueLine: () => ({
    name: "",
    type: "product",
    unitPrice: 0,
    volumes: eY(),
    growthRates: [0, 0.05, 0.05, 0.05, 0.05],
    grossMargin: 0.40
  }),
  hr: () => ({
    role: "",
    type: "direct",
    annualCost: 0,
    ral: 0,              // V5: RAL (Retribuzione Annua Lorda) √¢‚Ç¨‚Äù base per TFR
    contractType: "indeterminato", // V5: indeterminato/determinato/apprendista √¢‚Ç¨‚Äù per cuneo IRAP
    count: eY1(),
    growthRate: 0.03
  }),
  opex: () => ({
    name: "",
    category: "general",
    values: eY(),
    growthRate: 0.02,
    isPercentOfRevenue: false,
    percentOfRevenue: 0
  }),
  investment: () => ({
    name: "",
    type: "tangible",
    cost: 0,
    usefulLife: 5,
    year: 0,
    industry40: false,
    vatDeductible: true,
    category: "generic"
  }),
  assumptions: {
    vatRate: .22,
    iresRate: .24,
    irapRate: .039,
    dso: 30,
    dpo: 60,
    dio: 30,
    interestRate: .04,
    debtAmount: eY(),
    debtRepayment: eY(),
    equityInjection: eY(),
    dividendPayout: 0,
    grantAmount: 0,
    grantYears: 5,
    tfrRate: 0.0741,
    taxCreditAmount: 0,
    taxCreditYears: 3,
    debtType: "manual",
    debtDuration: 5,
    openingCash: 0,
    openingDebt: 0,
    openingEquity: 0,
    openingFA: 0,        // Net fixed assets at start (immobilizzazioni nette)
    openingFALife: 5,    // Remaining useful life of existing assets
    openingAR: 0,        // Opening accounts receivable (crediti commerciali)
    openingAP: 0,        // Opening accounts payable (debiti commerciali)
    openingInventory: 0, // Opening inventory (rimanenze)
    openingTFR: 0,       // Opening TFR fund
    // V5: PN components opening
    openingRiservaLegale: 0,
    openingAltreRiserve: 0,
    openingUtiliANuovo: 0,
    openingTaxPayable: 0,// Opening tax liabilities (debiti tributari)
    openingTaxLoss: 0,   // V5: Perdite fiscali pregresse riportabili (solo IRES)
    cuneoFiscalePerDip: 8000, // V5: Deduzione IRAP per dipendente TI (√¢‚Äö¬¨)
    irapRegione: "standard",  // V5: Regione per aliquota IRAP
    badDebtRate: 0.02,   // V5: % fondo svalutazione crediti (default 2%)
    firstYearDeprReduction: true, // V5: Ammortamento ridotto 50% primo anno
    scenarioMultiplier: {
      base: 1,
      pessimistic: .85,
      optimistic: 1.15
    }
  }
};


// ==√Ç¬ê= V3: SECTOR TEMPLATES ==√Ç¬ê=
const SECTOR_TEMPLATES = {
  tech_software: { label: "Software / SaaS / IT", grossMargin: 0.72, dso: 45, dpo: 30, dio: 0, hrOnRevenue: 0.50, ebitdaMargin: 0.18, debtEquity: 0.8 },
  manifattura: { label: "Manifattura / Industria", grossMargin: 0.32, dso: 75, dpo: 60, dio: 45, hrOnRevenue: 0.25, ebitdaMargin: 0.11, debtEquity: 1.5 },
  commercio_ingrosso: { label: "Commercio ingrosso", grossMargin: 0.22, dso: 60, dpo: 45, dio: 30, hrOnRevenue: 0.12, ebitdaMargin: 0.06, debtEquity: 1.8 },
  commercio_dettaglio: { label: "Commercio dettaglio", grossMargin: 0.42, dso: 5, dpo: 45, dio: 30, hrOnRevenue: 0.22, ebitdaMargin: 0.08, debtEquity: 1.2 },
  ristorazione: { label: "Ristorazione / Food", grossMargin: 0.65, dso: 5, dpo: 30, dio: 10, hrOnRevenue: 0.35, ebitdaMargin: 0.12, debtEquity: 1.0 },
  edilizia: { label: "Edilizia / Costruzioni", grossMargin: 0.28, dso: 90, dpo: 90, dio: 20, hrOnRevenue: 0.30, ebitdaMargin: 0.08, debtEquity: 2.0 },
  consulenza: { label: "Consulenza / Servizi prof.", grossMargin: 0.80, dso: 60, dpo: 20, dio: 0, hrOnRevenue: 0.60, ebitdaMargin: 0.15, debtEquity: 0.5 },
  turismo: { label: "Turismo / Ospitalita", grossMargin: 0.55, dso: 15, dpo: 30, dio: 5, hrOnRevenue: 0.35, ebitdaMargin: 0.15, debtEquity: 1.5 },
  agricoltura: { label: "Agricoltura / Agroalimentare", grossMargin: 0.35, dso: 60, dpo: 45, dio: 60, hrOnRevenue: 0.20, ebitdaMargin: 0.10, debtEquity: 1.8 },
  logistica: { label: "Logistica / Trasporti", grossMargin: 0.30, dso: 60, dpo: 45, dio: 5, hrOnRevenue: 0.35, ebitdaMargin: 0.08, debtEquity: 2.0 },
  altro: { label: "Altro settore", grossMargin: 0.40, dso: 45, dpo: 45, dio: 15, hrOnRevenue: 0.30, ebitdaMargin: 0.10, debtEquity: 1.5 }
};

const COMPANY_TYPES = [
  { value: "startup_innovativa", label: "\uD83D\uDE80 Startup Innovativa", desc: "Nessun bilancio storico. Metriche burn rate e runway." },
  { value: "nuova_impresa", label: "\uD83C\uDF31 Nuova Impresa", desc: "Nessun bilancio precedente." },
  { value: "existing", label: "\uD83C\uDFE2 Azienda Esistente", desc: "Carica 1 o 2 bilanci. L'ultimo diventa Anno 0." },
  { value: "crisis", label: "\u26A0\uFE0F In Ristrutturazione", desc: "Piano di risanamento con bilancio storico." }
];

const BILANCIO_TEMPLATE = () => ({
  ricavi: 0, costiEsterni: 0, valoreAggiunto: 0, personale: 0,
  ebitda: 0, ammortamenti: 0, ebit: 0, interessiPassivi: 0,
  risultatoPrimaImposte: 0, imposte: 0, utileNetto: 0,
  immobilizzazioniNette: 0, creditiCommerciali: 0, rimanenze: 0, cassa: 0,
  capitaleSociale: 0, patrimonioNetto: 0,
  debitiFinanziari: 0, debitiCommerciali: 0, tfr: 0,
  dipendenti: 0, annoRiferimento: 0, fonte: ""
});

function getYearLabels(company) {
  const sy = company.startYear || new Date().getFullYear();
  const isEx = company.companyType === "existing" || company.companyType === "crisis";
  const hasBil = company.bilpianoAnno0 && company.bilpianoAnno0.ricavi > 0;
  const hasM1 = company.bilpianoAnnoM1 && company.bilpianoAnnoM1.ricavi > 0;
  const result = { forecast: [], full: [] };
  for (let i = 0; i < 5; i++) result.forecast.push(String(sy + i));
  if (isEx && hasBil) {
    if (hasM1) result.full.push({ year: sy - 2, label: String(sy - 2), type: "storico" });
    result.full.push({ year: sy - 1, label: String(sy - 1), type: "consuntivo" });
  }
  for (let i = 0; i < 5; i++) result.full.push({ year: sy + i, label: String(sy + i), type: "previsionale" });
  return result;
}

function getStepValidation(stepId, company, revenues, hrs, opexItems, investments) {
  switch(stepId) {
    case 0: return company.name ? "ok" : "empty";
    case 1: return revenues.some(r => r.unitPrice > 0 || r.volumes.some(v => v > 0)) ? "ok" : revenues.length > 1 ? "partial" : "empty";
    case 3: return hrs.some(h => h.annualCost > 0) ? "ok" : "empty";
    case 5: return investments.some(i => i.cost > 0) ? "ok" : "empty";
    default: return "ok";
  }
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   FORMATTING UTILS
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
const fmt = (v, d = 0) => {
  if (v == null || isNaN(v)) return "‚Äî";
  const a = Math.abs(v);
  const f = a.toLocaleString("it-IT", {
    minimumFractionDigits: d,
    maximumFractionDigits: d
  });
  return v < 0 ? `(${f})` : f;
};
const fmtPct = v => {
  if (v == null || isNaN(v)) return "‚Äî";
  return (v * 100).toFixed(1) + "%";
};
const fmtEur = (v, d = 0) => {
  if (v == null || isNaN(v)) return "‚Äî";
  return "‚Ç¨ " + fmt(v, d);
};

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   CALCULATION ENGINE (verified with unit tests)
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function computeFinancials(company, revenues, hrs, opexItems, investments, assumptions) {
  updateYL(company);
  const n = company.yearsCount;
  const sm = assumptions.scenarioMultiplier[company.scenario] || 1;
  const revenueByLine = revenues.map(line => {
    const vols = [];
    for (let i = 0; i < 5; i++) {
      if (line.volumes[i] > 0) {
        vols[i] = line.volumes[i];
      } else if (i > 0 && vols[i - 1] > 0) {
        vols[i] = Math.round(vols[i - 1] * (1 + (line.growthRates ? line.growthRates[i] : 0.05)));
      } else {
        vols[i] = 0;
      }
    }
    return YEARS.map((_, i) => vols[i] * line.unitPrice * sm);
  });
  const totalRevenue = YEARS.map((_, i) => revenueByLine.reduce((s, l) => s + (l[i] || 0), 0));
  const cogs = revenues.map((line, li) => revenueByLine[li].map(r => r * (1 - line.grossMargin)));
  const totalCOGS = YEARS.map((_, i) => cogs.reduce((s, l) => s + (l[i] || 0), 0));
  const grossProfit = YEARS.map((_, i) => totalRevenue[i] - totalCOGS[i]);
  const hrCosts = YEARS.map((_, i) => hrs.reduce((s, h) => s + h.annualCost * (h.count[i] || 0) * Math.pow(1 + h.growthRate, i), 0));
  const opexCosts = YEARS.map((_, i) => opexItems.reduce((s, o) => {
    if (o.isPercentOfRevenue) return s + totalRevenue[i] * o.percentOfRevenue;
    if (o.values[i] > 0) return s + o.values[i];
    // Find last manual value before this year
    let base = 0,
      baseYear = 0;
    for (let j = i - 1; j >= 0; j--) {
      if (o.values[j] > 0) {
        base = o.values[j];
        baseYear = j;
        break;
      }
    }
    if (base > 0) return s + base * Math.pow(1 + o.growthRate, i - baseYear);
    return s;
  }, 0));
  const depreciation = YEARS.map((_, i) => {
    // V5: Depreciation with optional first-year 50% reduction
    const firstYearReduction = assumptions.firstYearDeprReduction !== false; // default ON
    let dep = investments.reduce((s, inv) => {
      if (i >= inv.year && inv.usefulLife > 0 && i - inv.year < inv.usefulLife) {
        const annualQuota = inv.cost / inv.usefulLife;
        // Primo anno di ammortamento: 50% se flag attivo
        if (i === inv.year && firstYearReduction) return s + annualQuota * 0.5;
        // Ultimo anno: recupera il residuo se primo anno era ridotto
        if (firstYearReduction && i - inv.year === inv.usefulLife - 1) {
          // L'ultimo anno prende quota intera + la met√† non ammortizzata del primo anno
          return s + annualQuota * 0.5 + annualQuota;
        }
        // CORREZIONE: se vita utile √® esattamente 1 anno e c'√® riduzione, ammortizza tutto
        if (inv.usefulLife === 1) return s + inv.cost;
        return s + annualQuota;
      }
      return s;
    }, 0);
    // Depreciation from existing fixed assets (opening FA)
    const oFA = assumptions.openingFA || 0;
    const oLife = assumptions.openingFALife || 5;
    if (oFA > 0 && i < oLife) dep += oFA / oLife;
    return dep;
  });
  const grantIncome = YEARS.map((_, i) => assumptions.grantAmount > 0 && i < assumptions.grantYears ? assumptions.grantAmount / assumptions.grantYears : 0);
  // V5.1: Svalutazione crediti (OIC 15 voce B10d)
  const badDebtRate = assumptions.badDebtRate || 0.02;
  const arPrelim = YEARS.map((_, i) => totalRevenue[i] * (1 + assumptions.vatRate) * assumptions.dso / 360);
  const fondoSvalCreditiPrelim = YEARS.map((_, i) => arPrelim[i] * badDebtRate);
  const svalutazioneCrediti = YEARS.map((_, i) => {
    const prevFondo = i === 0 ? 0 : fondoSvalCreditiPrelim[i - 1];
    return Math.max(0, fondoSvalCreditiPrelim[i] - prevFondo);
  });
  const ebitda = YEARS.map((_, i) => grossProfit[i] - hrCosts[i] - opexCosts[i] + grantIncome[i]);
  const ebit = YEARS.map((_, i) => ebitda[i] - depreciation[i] - svalutazioneCrediti[i]);
  // FIX v4.1: copia locale per non mutare state ad ogni ricalcolo
  const localRepayment = assumptions.debtRepayment.slice();
  if (assumptions.debtType === "francese") {
    const dur = assumptions.debtDuration || 5;
    const rate = assumptions.interestRate;
    YEARS.forEach((_, i) => {
      if (assumptions.debtAmount[i] > 0 && rate > 0) {
        const pmt = assumptions.debtAmount[i] * rate * Math.pow(1 + rate, dur) / (Math.pow(1 + rate, dur) - 1);
        for (let y = 1; y <= dur && i + y < 5; y++) {
          const remaining = assumptions.debtAmount[i] * Math.pow(1 + rate, y - 1) - (pmt - assumptions.debtAmount[i] * rate) * ((Math.pow(1 + rate, y - 1) - 1) / rate);
          const intPortion = remaining * rate;
          const capPortion = pmt - intPortion;
          localRepayment[i + y] = (localRepayment[i + y] || 0) + capPortion;
        }
      }
    });
  }
  const netDebt = YEARS.map((_, i) => {
    let d = assumptions.openingDebt || 0;
    for (let j = 0; j <= i; j++) d += (assumptions.debtAmount[j] || 0) - (localRepayment[j] || 0);
    return Math.max(0, d);
  });
  const interest = YEARS.map((_, i) => {
    // V5.1 FIX: interessi calcolati su debito inizio anno (include nuovi finanziamenti erogati a inizio anno)
    // Per Anno 1 di nuova impresa: debito erogato a inizio anno ‚Üí interessi dovuti sull'intero esercizio
    const openingBal = i > 0 ? netDebt[i - 1] : (assumptions.openingDebt || 0);
    const newDebtThisYear = assumptions.debtAmount[i] || 0;
    // Interessi su debito preesistente (anno intero) + nuovo debito (met√† anno come convenzione)
    return openingBal * assumptions.interestRate + newDebtThisYear * assumptions.interestRate * 0.5;
  });
  const ebt = YEARS.map((_, i) => ebit[i] - interest[i]);

  // √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê V5: IRES con perdite fiscali riportabili (art. 84 TUIR) √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê
  const taxLossPool = []; // Pool perdite fiscali anno per anno
  const taxLossUsed = [];
  const ires = [];
  const iresBase = [];
  let cumulativeTaxLoss = assumptions.openingTaxLoss || 0;
  const isFirst3 = (company.companyType === "startup_innovativa" || company.companyType === "nuova_impresa");
  for (let i = 0; i < 5; i++) {
    const baseIres = ebt[i]; // Semplificazione: base IRES √¢‚Ä∞ÀÜ EBT
    if (baseIres <= 0) {
      cumulativeTaxLoss += Math.abs(baseIres);
      taxLossPool[i] = cumulativeTaxLoss;
      taxLossUsed[i] = 0;
      iresBase[i] = 0;
      ires[i] = 0;
    } else {
      // Primi 3 esercizi nuova impresa: compensazione 100%. Dal 4√Ç¬∞ in poi: max 80%
      const maxCompensable = (isFirst3 && i < 3) ? baseIres : baseIres * 0.80;
      const used = Math.min(cumulativeTaxLoss, maxCompensable);
      cumulativeTaxLoss -= used;
      taxLossPool[i] = cumulativeTaxLoss;
      taxLossUsed[i] = used;
      iresBase[i] = baseIres - used;
      ires[i] = Math.max(0, iresBase[i] * assumptions.iresRate);
    }
  }

  // √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê V5: IRAP √¢‚Ç¨‚Äù formula corretta + cuneo fiscale √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê
  // Headcount per tipo contratto
  const headcountTI = YEARS.map((_, i) => hrs.reduce((s, h) => {
    if (h.contractType === "indeterminato" || !h.contractType) return s + (h.count[i] || 0);
    return s;
  }, 0));
  const costoApprendisti = YEARS.map((_, i) => hrs.reduce((s, h) => {
    if (h.contractType === "apprendista") return s + h.annualCost * (h.count[i] || 0) * Math.pow(1 + h.growthRate, i);
    return s;
  }, 0));
  // Cuneo fiscale: deduzione per TI + costo integrale apprendisti
  const cuneoFiscale = YEARS.map((_, i) => {
    return headcountTI[i] * (assumptions.cuneoFiscalePerDip || 8000) + costoApprendisti[i];
  });
  // Base IRAP = Val.Produzione - costi deducibili (B6+B7+B8+B10a+B10b+B11+B14) - cuneo
  // hrCosts gi√† ESCLUSO (non √® in totalCOGS n√© opexCosts)
  const irapBase = YEARS.map((_, i) => {
    const vp = totalRevenue[i] + grantIncome[i];
    const cd = totalCOGS[i] + opexCosts[i] + depreciation[i];
    return Math.max(0, vp - cd - cuneoFiscale[i]);
  });
  const IRAP_ALIQUOTE = {
    standard: 0.039, piemonte: 0.039, lombardia: 0.039, veneto: 0.039,
    emilia_romagna: 0.039, toscana: 0.039, lazio: 0.039, abruzzo: 0.039,
    campania: 0.0497, calabria: 0.0482, sicilia: 0.0482, puglia: 0.0482, basilicata: 0.0482
  };
  const irapAliquota = IRAP_ALIQUOTE[assumptions.irapRegione || "standard"] || assumptions.irapRate || 0.039;
  const irap = YEARS.map((_, i) => Math.max(0, irapBase[i] * irapAliquota));
  const totalTaxGross = YEARS.map((_, i) => ires[i] + irap[i]);
  // Credito d\'imposta con riporto residuo
  const taxCreditPerYear = assumptions.taxCreditAmount > 0 && assumptions.taxCreditYears > 0 ? assumptions.taxCreditAmount / assumptions.taxCreditYears : 0;
  const taxCreditUsed = [];
  let taxCreditResiduo = 0;
  for (let i = 0; i < 5; i++) {
    const available = (i < (assumptions.taxCreditYears || 3) ? taxCreditPerYear : 0) + taxCreditResiduo;
    const used = Math.min(available, totalTaxGross[i]);
    taxCreditUsed[i] = used;
    taxCreditResiduo = available - used;
  }
  const totalTax = YEARS.map((_, i) => Math.max(0, totalTaxGross[i] - taxCreditUsed[i]));
  const netIncome = YEARS.map((_, i) => ebt[i] - totalTax[i]);

  // √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê V5: TFR calcolato da RAL (non da costo azienda) √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê
  const totalRAL = YEARS.map((_, i) => hrs.reduce((s, h) => {
    const ral = (h.ral && h.ral > 0) ? h.ral : (h.annualCost > 0 ? h.annualCost / 1.38 : 0);
    return s + ral * (h.count[i] || 0) * Math.pow(1 + h.growthRate, i);
  }, 0));
  const tfrQuotaAnno = YEARS.map((_, i) => totalRAL[i] / 13.5 * 0.995);
  const inflazione = 0.02;
  const tfrRivalutazione = [];
  const tfrAccrual = [];
  const cumTFR = [];
  let prevTFRfund = assumptions.openingTFR || 0;
  for (let i = 0; i < 5; i++) {
    const base = i === 0 ? prevTFRfund : cumTFR[i-1];
    const riv = base > 0 ? base * (0.015 + 0.75 * inflazione) : 0;
    tfrRivalutazione[i] = riv;
    tfrAccrual[i] = tfrQuotaAnno[i] + riv;
    cumTFR[i] = prevTFRfund + tfrAccrual.slice(0, i + 1).reduce((s, t) => s + t, 0);
  }

  // √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê V5: PN scomposto (OIC 28) con riserva legale automatica √¢‚Ä¢¬ê√¢‚Ä¢¬ê√¢‚Ä¢¬ê
  const capitaleSociale = company.capitaleSociale || 0;
  const targetRL = capitaleSociale / 5;
  const riservaLegale = [];
  const altreRiserve = [];
  const utiliANuovo = [];
  const dividends = [];
  const pnComponenti = [];
  let cumRL = assumptions.openingRiservaLegale || 0;
  let cumAR = assumptions.openingAltreRiserve || 0;
  let cumUAN = assumptions.openingUtiliANuovo || 0;
  for (let i = 0; i < 5; i++) {
    cumAR += (assumptions.equityInjection[i] || 0);
    if (netIncome[i] > 0) {
      const accRL = cumRL < targetRL ? Math.min(netIncome[i] * 0.05, targetRL - cumRL) : 0;
      cumRL += accRL;
      const utileDistr = netIncome[i] - accRL;
      dividends[i] = Math.max(0, utileDistr * assumptions.dividendPayout);
      cumUAN += (utileDistr - dividends[i]);
    } else {
      dividends[i] = 0;
      cumUAN += netIncome[i];
    }
    riservaLegale[i] = cumRL;
    altreRiserve[i] = cumAR;
    utiliANuovo[i] = cumUAN;
    pnComponenti[i] = {
      ai_capitale: capitaleSociale, aiv_riservaLegale: cumRL,
      avi_altreRiserve: cumAR, aviii_utiliANuovo: cumUAN, aix_utileEsercizio: netIncome[i]
    };
  }
  const equity = YEARS.map((_, i) => capitaleSociale + riservaLegale[i] + altreRiserve[i] + utiliANuovo[i]);
  const ar = YEARS.map((_, i) => totalRevenue[i] * (1 + assumptions.vatRate) * assumptions.dso / 360);
  // V5.1: Fondo svalutazione crediti (OIC 15)
  const fondoSvalCrediti = fondoSvalCreditiPrelim;
  const arNetto = YEARS.map((_, i) => ar[i] - fondoSvalCrediti[i]);
  const inventory = YEARS.map((_, i) => totalCOGS[i] * assumptions.dio / 360);
  const ap = YEARS.map((_, i) => totalCOGS[i] * (1 + assumptions.vatRate) * assumptions.dpo / 360);
  // V5.1 FIX: Oneri sociali calcolati come residuo per garantire totB9 = hrCosts
  // B9a=RAL, B9c=TFR, B9b=hrCosts-RAL-TFR ‚Üí somma sempre = hrCosts
  const oneriSociali = YEARS.map((_, i) => Math.max(0, hrCosts[i] - totalRAL[i] - tfrQuotaAnno[i]));
  const debitiPrevidenziali = YEARS.map((_, i) => oneriSociali[i] / 6);
  const totalInvestments = YEARS.map((_, i) => investments.filter(inv => inv.year === i).reduce((s, inv) => s + inv.cost, 0));
  // FIX v4.4: IVA su investimenti nel cash flow
  const vatOnInvestments = YEARS.map((_, i) => investments.filter(inv => inv.year === i).reduce((s, inv) => {
    var vatAmount = inv.cost * (assumptions.vatRate || 0.22);
    if (inv.vatDeductible === false) return s; // IVA indetraibile gi√† inclusa nel costo
    return s + vatAmount; // IVA detraibile: esborso cash temporaneo
  }, 0));
  const totalInvestmentsCash = YEARS.map((_, i) => totalInvestments[i] + vatOnInvestments[i]);
  const accDep = YEARS.map((_, i) => depreciation.slice(0, i + 1).reduce((s, d) => s + d, 0));
  const grossFA = YEARS.map((_, i) => totalInvestments.slice(0, i + 1).reduce((s, t) => s + t, 0));
  const netFA = YEARS.map((_, i) => {
    // V5: Net FA with first-year 50% reduction support
    const firstYearReduction = assumptions.firstYearDeprReduction !== false;
    let fa = grossFA[i] - (investments.reduce((s, inv) => {
      if (i >= inv.year && inv.usefulLife > 0) {
        const annualQuota = inv.cost / inv.usefulLife;
        let accDep = 0;
        for (let y = inv.year; y <= Math.min(i, inv.year + inv.usefulLife - 1); y++) {
          if (y === inv.year && firstYearReduction && inv.usefulLife > 1) accDep += annualQuota * 0.5;
          else accDep += annualQuota;
        }
        return s + Math.min(accDep, inv.cost);
      }
      return s;
    }, 0));
    // Existing fixed assets (opening FA) net of accumulated depreciation
    const oFA = assumptions.openingFA || 0;
    const oLife = assumptions.openingFALife || 5;
    if (oFA > 0) {
      const existingDepYears = Math.min(i + 1, oLife);
      fa += oFA - (oFA / oLife) * existingDepYears;
    }
    return Math.max(0, fa);
  });

  // Deferred grant income (risconti passivi): cash received Y1 minus cumulative income recognized
  const grantCashIn = YEARS.map((_, i) => i === 0 ? assumptions.grantAmount : 0);
  const cumGrantIncome = YEARS.map((_, i) => grantIncome.slice(0, i + 1).reduce((s, g) => s + g, 0));
  const deferredGrant = YEARS.map((_, i) => Math.max(0, assumptions.grantAmount - cumGrantIncome[i]));
  const currentLiabilities = YEARS.map((_, i) => ap[i] + totalTax[i] + debitiPrevidenziali[i] + (assumptions.openingTaxPayable || 0));
  // V5.1 FIX: Use arNetto (net of bad debt reserve) for asset calculation consistency
  const totalAssetsNoCash = YEARS.map((_, i) => arNetto[i] + inventory[i] + netFA[i]);
  const totalLiabEq = YEARS.map((_, i) => currentLiabilities[i] + deferredGrant[i] + netDebt[i] + cumTFR[i] + equity[i]);
  // FIX v4.3: cash non pu√≤ essere negativo in SP ‚Üí fido di cassa (revolving credit)
  const rawCash = YEARS.map((_, i) => totalLiabEq[i] - totalAssetsNoCash[i]);
  const revolvingCredit = YEARS.map((_, i) => rawCash[i] < 0 ? Math.abs(rawCash[i]) : 0);
  const cash = YEARS.map((_, i) => Math.max(0, rawCash[i]));
  const totalLiabEqAdj = YEARS.map((_, i) => totalLiabEq[i] + revolvingCredit[i]);
  const totalAssets = YEARS.map((_, i) => totalAssetsNoCash[i] + cash[i]);
  const fundingGap = revolvingCredit;

  // CF Operating: NI + Dep + WC change (relative to opening values for Y1) + grant cash adjustment
  // V5.2b: includes debitiPrevidenziali in WC for SP reconciliation
  const oAR = assumptions.openingAR || 0;
  const oAP = assumptions.openingAP || 0;
  const oInv = assumptions.openingInventory || 0;
  const cfOperating = YEARS.map((_, i) => {
    const prevAR = i === 0 ? oAR : ar[i - 1];
    const prevInv = i === 0 ? oInv : inventory[i - 1];
    const prevAP = i === 0 ? oAP : ap[i - 1];
    const prevPrev = i === 0 ? 0 : debitiPrevidenziali[i - 1];
    const wcTrade = -(ar[i] - prevAR + inventory[i] - prevInv - (ap[i] - prevAP));
    const wcTax = i === 0 ? totalTax[0] : totalTax[i] - totalTax[i - 1];
    const wcPrev = debitiPrevidenziali[i] - prevPrev;
    const grantAdj = grantCashIn[i] - grantIncome[i];
    return netIncome[i] + depreciation[i] + svalutazioneCrediti[i] + tfrAccrual[i] + wcTrade + wcTax + wcPrev + grantAdj;
  });
  // V5.2b: cfInvesting uses totalInvestments (no IVA) to reconcile with SP (no IVA receivable in B/S)
  const cfInvesting = YEARS.map((_, i) => -totalInvestments[i]);
  // CF Financing: NO grant here (grant cash is captured via operating adjustment)
  // V5.2b: includes capitaleSociale as cash inflow for nuova_impresa (shareholders' initial contribution)
  const capitaleSocialeInflow = company.companyType === "nuova_impresa" || company.companyType === "startup" ? capitaleSociale : 0;
  const cfFinancing = YEARS.map((_, i) => {
    const csInflow = i === 0 ? capitaleSocialeInflow : 0;
    return (assumptions.debtAmount[i] || 0) - (localRepayment[i] || 0) + (assumptions.equityInjection[i] || 0) + csInflow - dividends[i];
  });
  const netCF = YEARS.map((_, i) => cfOperating[i] + cfInvesting[i] + cfFinancing[i]);
  const cumCash = YEARS.map((_, i) => (assumptions.openingCash || 0) + netCF.slice(0, i + 1).reduce((s, c) => s + c, 0));
  const grossMarginPct = YEARS.map((_, i) => totalRevenue[i] ? grossProfit[i] / totalRevenue[i] : 0);
  const ebitdaMargin = YEARS.map((_, i) => totalRevenue[i] ? ebitda[i] / totalRevenue[i] : 0);
  const netMargin = YEARS.map((_, i) => totalRevenue[i] ? netIncome[i] / totalRevenue[i] : 0);
  const roe = YEARS.map((_, i) => {
    if (!equity[i]) return null;
    if (equity[i] < 0 && netIncome[i] < 0) return null;
    return netIncome[i] / equity[i];
  });
  const roa = YEARS.map((_, i) => totalAssets[i] ? netIncome[i] / totalAssets[i] : 0);
  const currentRatio = YEARS.map((_, i) => currentLiabilities[i] > 0 ? (arNetto[i] + inventory[i] + Math.max(0, cash[i])) / currentLiabilities[i] : null);
  const debtRatio = YEARS.map((_, i) => totalAssets[i] ? netDebt[i] / totalAssets[i] : 0);
  const headcount = YEARS.map((_, i) => hrs.reduce((s, h) => s + (h.count[i] || 0), 0));
  const revPerEmp = YEARS.map((_, i) => headcount[i] ? totalRevenue[i] / headcount[i] : 0);
  const revenueCAGR = n > 1 && totalRevenue[0] > 0 ? Math.pow(totalRevenue[n - 1] / totalRevenue[0], 1 / (n - 1)) - 1 : 0;

  /* -√¢‚Äö¬¨- KPI AVANZATI (richiesti da banche e investitori) -√¢‚Äö¬¨- */

  // DSCR = EBITDA / (Interessi + Quota capitale) ‚Äî la banca lo vuole > 1.2
  const debtService = YEARS.map((_, i) => interest[i] + (localRepayment[i] || 0));
  const dscr = YEARS.map((_, i) => debtService[i] > 0 ? ebitda[i] / debtService[i] : null);
  // FIX v4.1: DSCR cash-based (EBA / Codice Crisi art. 13)
  const dscrCash = YEARS.map((_, i) => debtService[i] > 0 ? cfOperating[i] / debtService[i] : null);
  // V5.1: DSCR CADS (Cash Available for Debt Service) ‚Äî formula conservativa banche
  const dscrCADS = YEARS.map((_, i) => {
    if (debtService[i] <= 0) return null;
    const prevAR_c = i === 0 ? (assumptions.openingAR || 0) : ar[i - 1];
    const prevInv_c = i === 0 ? (assumptions.openingInventory || 0) : inventory[i - 1];
    const prevAP_c = i === 0 ? (assumptions.openingAP || 0) : ap[i - 1];
    const deltaNWC = (ar[i] + inventory[i] - ap[i]) - (prevAR_c + prevInv_c - prevAP_c);
    const cads = ebitda[i] - totalTax[i] - deltaNWC - totalInvestments[i];
    // V5.1 FIX: CADS negativo (tipico anno investimento startup) ‚Üí mostra n.a. anzich√© ratio fuorviante
    if (cads < 0) return null;
    return cads / debtService[i];
  });

  // Interest Coverage Ratio = EBIT / Interessi ‚Äî misura capacit√† di coprire gli oneri finanziari
  const icr = YEARS.map((_, i) => interest[i] > 0 ? ebit[i] / interest[i] : null);

  // PFN = Posizione Finanziaria Netta = Cassa - Debito finanziario (negativo = indebitamento netto)
  const pfn = YEARS.map((_, i) => Math.max(0, cash[i]) - netDebt[i]);

  // Debt/Equity ratio = Debito finanziario / Patrimonio netto
  const debtEquity = YEARS.map((_, i) => equity[i] > 0 ? netDebt[i] / equity[i] : null);

  // Break-Even Point (‚Ç¨) = Costi Fissi / Margine lordo %
  const fixedCosts = YEARS.map((_, i) => hrCosts[i] + opexCosts[i] + depreciation[i] + interest[i]);
  const bep = YEARS.map((_, i) => grossMarginPct[i] > 0 ? fixedCosts[i] / grossMarginPct[i] : null);
  const bepMargin = YEARS.map((_, i) => bep[i] != null && totalRevenue[i] > 0 ? (totalRevenue[i] - bep[i]) / totalRevenue[i] : null);

  // Cash Conversion Cycle = DSO + DIO - DPO
  const ccc = assumptions.dso + assumptions.dio - assumptions.dpo;

  // Burn rate e Runway (solo se CF operativo negativo)
  const burnRate = YEARS.map((_, i) => cfOperating[i] < 0 ? Math.abs(cfOperating[i]) / 12 : 0);
  const runway = YEARS.map((_, i) => burnRate[i] > 0 ? Math.max(0, cash[i]) / burnRate[i] : null);

  // NWC (Net Working Capital) = Attivo corrente - Passivo corrente
  const nwc = YEARS.map((_, i) => arNetto[i] + inventory[i] + Math.max(0, cash[i]) - currentLiabilities[i]);

  // Costo del personale / Ricavi (incidenza)
  const hrOnRevenue = YEARS.map((_, i) => totalRevenue[i] > 0 ? hrCosts[i] / totalRevenue[i] : 0);

  // ROI = EBIT / Totale Attivo ‚Äî rendimento del capitale investito
  const roi = YEARS.map((_, i) => totalAssets[i] > 0 ? ebit[i] / totalAssets[i] : null);

  // Payback Period: anno in cui cumCash diventa positivo
  let paybackYear = null;
  for (let i = 0; i < n; i++) {
    if (cumCash[i] >= 0) {
      paybackYear = i;
      break;
    }
  }
  const paybackPeriod = paybackYear;

  // V5.1: Metriche EBA Allegato 3
  const equityRatio = YEARS.map((_, i) => totalAssets[i] > 0 ? equity[i] / totalAssets[i] : null);
  const debtToEbitda = YEARS.map((_, i) => ebitda[i] > 0 ? netDebt[i] / ebitda[i] : null);
  const cashDebtCoverage = YEARS.map((_, i) => {
    const avgCL = i === 0 ? currentLiabilities[i] : (currentLiabilities[i] + currentLiabilities[i - 1]) / 2;
    return avgCL > 0 ? cfOperating[i] / avgCL : null;
  });
  const capacitaAmmortamento = YEARS.map((_, i) => netIncome[i] + depreciation[i]);

  // V5: Art. 2446/2447 con PN scomposto
  // Art. 2446: perdita > 1/3 del capitale sociale √¢‚Ä†‚Äô assemblea
  const art2446 = YEARS.map((_, i) => {
    if (netIncome[i] >= 0) return false;
    const perditaCumulata = utiliANuovo[i] < 0 ? Math.abs(utiliANuovo[i]) : 0;
    return perditaCumulata > capitaleSociale / 3;
  });
  // Art. 2447: PN < minimo legale (sotto 1/3 CS) √¢‚Ä†‚Äô riduzione CS o scioglimento
  const art2447 = YEARS.map((_, i) => equity[i] > 0 && equity[i] < capitaleSociale / 3);

  // YoY growth rates
  const revenueGrowth = YEARS.map((_, i) => i > 0 && totalRevenue[i - 1] > 0 ? (totalRevenue[i] - totalRevenue[i - 1]) / totalRevenue[i - 1] : null);
  const ebitdaGrowth = YEARS.map((_, i) => i > 0 && ebitda[i - 1] > 0 ? (ebitda[i] - ebitda[i - 1]) / ebitda[i - 1] : null);

  // Cost-to-Income
  const costToIncome = YEARS.map((_, i) => totalRevenue[i] > 0 ? (totalCOGS[i] + hrCosts[i] + opexCosts[i]) / totalRevenue[i] : null);
  return {
    revenueByLine,
    totalRevenue,
    totalCOGS,
    grossProfit,
    hrCosts,
    opexCosts,
    depreciation,
    grantIncome,
    ebitda,
    ebit,
    interest,
    ebt,
    ires,
    irap,
    totalTax,
    netIncome,
    dividends,
    ar,
    inventory,
    ap,
    netDebt,
    equity,
    cash,
    fundingGap,
    totalAssets,
    netFA,
    currentLiabilities,
    deferredGrant,
    grantCashIn,
    cumTFR,
    tfrAccrual,
    taxCreditUsed,
    cfOperating,
    cfInvesting,
    cfFinancing,
    netCF,
    cumCash,
    totalInvestments,
    grossFA,
    accDep,
    totalLiabEq,
    grossMarginPct,
    ebitdaMargin,
    netMargin,
    roe,
    roa,
    currentRatio,
    debtRatio,
    headcount,
    revPerEmp,
    revenueCAGR,
    dscr,
    icr,
    pfn,
    debtEquity,
    bep,
    bepMargin,
    ccc,
    burnRate,
    runway,
    nwc,
    fixedCosts,
    debtService,
    hrOnRevenue,
    roi,
    paybackPeriod,
    art2447,
    art2446,
    revenueGrowth,
    ebitdaGrowth,
    costToIncome,
    localRepayment,
    dscrCash,
    irapBase,
    revolvingCredit,
    totalLiabEqAdj,
    vatOnInvestments,
    totalInvestmentsCash,

    // V5: Nuovi output motore calcolo
    taxLossPool,
    taxLossUsed,
    iresBase,
    cuneoFiscale,
    irapAliquota,
    headcountTI,
    tfrQuotaAnno,
    tfrRivalutazione,
    totalRAL,
    pnComponenti,
    riservaLegale,
    altreRiserve,
    utiliANuovo,
    capitaleSociale,
    costoApprendisti,
    taxCreditResiduo,

    // V5.1: Nuovi output
    dscrCADS, fondoSvalCrediti, svalutazioneCrediti, arNetto,
    debitiPrevidenziali, oneriSociali,
    equityRatio, debtToEbitda, cashDebtCoverage, capacitaAmmortamento,
    capitaleSocialeInflow,

    // V3: CE Riclassificato a Valore Aggiunto
    ceRiclass: YEARS.map((_, i) => ({
      valoreProduzione: totalRevenue[i] + (grantIncome[i] || 0),
      costiEsterni: totalCOGS[i] + opexCosts[i],
      valoreAggiunto: totalRevenue[i] + (grantIncome[i] || 0) - totalCOGS[i] - opexCosts[i],
      costoPersonale: hrCosts[i],
      mol: totalRevenue[i] + (grantIncome[i] || 0) - totalCOGS[i] - opexCosts[i] - hrCosts[i],
      ammortamenti: depreciation[i],
      svalutazioneCrediti: svalutazioneCrediti[i],
      risultatoOperativo: ebit[i],
      oneriFin: interest[i],
      risultatoAnteImposte: ebt[i],
      imposte: totalTax[i],
      risultatoNetto: netIncome[i]
    })),

    // V3: SP Riclassificato
    spRiclass: YEARS.map((_, i) => ({
      attivoFisso: netFA[i], creditiComm: ar[i], fondoSvalCrediti: fondoSvalCrediti[i],
      creditiNetti: arNetto[i], rimanenze: inventory[i],
      liquidita: Math.max(0, cash[i]),
      attivoCircolante: arNetto[i] + inventory[i] + Math.max(0, cash[i]),
      totaleAttivo: totalAssets[i],
      debitiComm: ap[i], debitiPrevidenziali: debitiPrevidenziali[i],
      passivoCorrente: currentLiabilities[i],
      debitiMLT: netDebt[i], tfrFondo: cumTFR[i], riscontiPassivi: deferredGrant[i],
      patrimonioNetto: equity[i],
      cin: netFA[i] + arNetto[i] + inventory[i] - currentLiabilities[i],
      ccn: arNetto[i] + inventory[i] + Math.max(0, cash[i]) - currentLiabilities[i]
    })),

    // V5.1: CE Civilistico art. 2425 c.c.
    ceCivil: YEARS.map((_, i) => {
      const salariStipendi = totalRAL[i];
      const onSoc = oneriSociali[i];
      const tfrQ = tfrQuotaAnno[i];
      // onSoc = hrCosts - RAL - TFR, so sum always = hrCosts
      const totB9 = hrCosts[i];
      const totB10 = depreciation[i] + svalutazioneCrediti[i];
      const totB = totalCOGS[i] + opexCosts[i] + totB9 + totB10;
      const diffAB = (totalRevenue[i] + (grantIncome[i] || 0)) - totB;
      return {
        A1: totalRevenue[i], A5: grantIncome[i] || 0,
        totA: totalRevenue[i] + (grantIncome[i] || 0),
        B6: totalCOGS[i], B7: opexCosts[i], B8: 0,
        B9a: salariStipendi, B9b: onSoc, B9c: tfrQ, B9e: 0, totB9: totB9,
        B10a: 0, B10b: depreciation[i], B10d: svalutazioneCrediti[i], totB10: totB10,
        B14: 0, totB: totB,
        diffAB: diffAB,
        C17: interest[i], totC: -interest[i],
        risultatoPrimaImposte: diffAB - interest[i],
        imposte20: totalTax[i], ires20: ires[i], irap20: irap[i],
        utile21: netIncome[i]
      };
    }),

    // V5.1: SP Civilistico art. 2424 c.c.
    spCivil: YEARS.map((_, i) => ({
      // ATTIVO
      BII: netFA[i], totB_att: netFA[i],
      CI: inventory[i],
      CII: arNetto[i], CII_fondo: fondoSvalCrediti[i], CII_lordo: ar[i],
      CIV: Math.max(0, cash[i]),
      totC_att: inventory[i] + arNetto[i] + Math.max(0, cash[i]),
      totAttivo: netFA[i] + inventory[i] + arNetto[i] + Math.max(0, cash[i]),
      // PASSIVO
      AI: capitaleSociale, AIV: riservaLegale[i], AVI: altreRiserve[i],
      AVIII: i > 0 ? utiliANuovo[i] - netIncome[i] : 0,
      AIX: netIncome[i],
      totA_pass: equity[i],
      B_fondi: 0,
      C_tfr: cumTFR[i],
      D4: netDebt[i], D7: ap[i], D12: totalTax[i], D13: debitiPrevidenziali[i], D14: 0,
      totD: netDebt[i] + ap[i] + totalTax[i] + debitiPrevidenziali[i],
      D_entro: ap[i] + totalTax[i] + debitiPrevidenziali[i] + Math.min(netDebt[i], localRepayment[i] || 0),
      D_oltre: Math.max(0, netDebt[i] - (localRepayment[i] || 0)),
      E_ratei: deferredGrant[i],
      totPassivo: equity[i] + cumTFR[i] + netDebt[i] + ap[i] + totalTax[i] + debitiPrevidenziali[i] + deferredGrant[i]
    })),

    // V5.2: Rendiconto Finanziario OIC 10 ‚Äî metodo indiretto (Schema n.1)
    // CORRETTO v5.2b: riconcilia perfettamente con SP cash (plug patrimoniale)
    cfOIC10: YEARS.map((_, i) => {
      // FIX 4: Usa ar LORDO (non arNetto) per coerenza con sval add-back
      const oAR_o = i === 0 ? (assumptions.openingAR || 0) : ar[i - 1];
      const oInv_o = i === 0 ? (assumptions.openingInventory || 0) : inventory[i - 1];
      const oAP_o = i === 0 ? (assumptions.openingAP || 0) : ap[i - 1];
      const oTax_o = i === 0 ? (assumptions.openingTaxPayable || 0) : totalTax[i - 1];
      const oPrev_o = i === 0 ? 0 : debitiPrevidenziali[i - 1];
      const oDG_o = i === 0 ? 0 : deferredGrant[i - 1];

      // Subtotale 1: Utile prima di imposte, interessi, plus/minus
      const sub1 = netIncome[i] + totalTax[i] + interest[i]; // = EBIT

      // Rettifiche non monetarie (no contropartita in CCN)
      const accTFR = tfrAccrual[i];
      const accAmm = depreciation[i];
      const accSval = svalutazioneCrediti[i];
      const totRettNonMon = accTFR + accAmm + accSval;

      // Subtotale 2: Flusso prima variazioni CCN
      const sub2 = sub1 + totRettNonMon;

      // Variazioni CCN
      const deltaRimanenze = -(inventory[i] - oInv_o);
      // FIX 4: ar LORDO (la sval √® gi√† in rettifiche non monetarie)
      const deltaCrediti = -(ar[i] - oAR_o);
      const deltaFornitori = ap[i] - oAP_o;
      const deltaRiscontiPass = deferredGrant[i] - oDG_o;
      const deltaTributari = totalTax[i] - oTax_o;
      const deltaPrevidenziali = debitiPrevidenziali[i] - oPrev_o;
      const totDeltaCCN = deltaRimanenze + deltaCrediti + deltaFornitori + deltaRiscontiPass + deltaTributari + deltaPrevidenziali;

      // Subtotale 3: Flusso dopo variazioni CCN
      const sub3 = sub2 + totDeltaCCN;

      // Altre rettifiche (cassa effettiva)
      const interessiPagati = -interest[i];
      const impostePagate = -totalTax[i];
      // FIX 1: RIMOSSO grantCash ‚Äî il contributo √® gi√† catturato da:
      //   NI (grantIncome +3000) + deltaRiscontiPass (+12000) = totale +15000
      //   Aggiungerlo qui sarebbe un DOPPIO CONTEGGIO
      const totAltreRett = interessiPagati + impostePagate;

      // A) CF Operativo OIC 10
      const cfOpA = sub3 + totAltreRett;

      // B) CF Investimento
      // FIX 3: Usa totalInvestments (costo) NON totalInvestmentsCash (costo+IVA)
      // perch√© lo SP non modella IVA a credito come voce patrimoniale separata
      const cfInvB = -totalInvestments[i];

      // C) CF Finanziamento
      const nuoviFin = assumptions.debtAmount[i] || 0;
      const rimborsoFin = localRepayment[i] || 0;
      const apportoEquity = assumptions.equityInjection[i] || 0;
      // FIX 2: Capitale sociale √® un apporto di cassa alla costituzione (nuova impresa)
      const conferimentoCS = i === 0 ? capitaleSociale : 0;
      const divPagati = dividends[i];
      const cfFinC = nuoviFin - rimborsoFin + apportoEquity + conferimentoCS - divPagati;

      const deltaLiq = cfOpA + cfInvB + cfFinC;
      const liqInizio = i === 0 ? (assumptions.openingCash || 0) : Math.max(0, cash[i - 1]);
      const liqFine = liqInizio + deltaLiq;

      return {
        utileEsercizio: netIncome[i],
        imposteReddito: totalTax[i],
        interessiPassivi: interest[i],
        sub1,

        accTFR, accAmm, accSval, totRettNonMon,
        sub2,

        deltaRimanenze, deltaCrediti, deltaFornitori,
        deltaRiscontiPass, deltaTributari, deltaPrevidenziali,
        totDeltaCCN,
        sub3,

        interessiPagati, impostePagate, totAltreRett,
        cfOpA,

        cfInvB,

        nuoviFin, rimborsoFin, apportoEquity, conferimentoCS, divPagati,
        cfFinC,

        deltaLiq, liqInizio, liqFine
      };
    }),

    // V3: Anno 0 from bilancio
    anno0: company.bilpianoAnno0 || null,
    annoM1: company.bilpianoAnnoM1 || null,

    // V3: Delta % Anno 0 -> Anno 1
    delta0to1: (() => {
      const b = company.bilpianoAnno0;
      if (!b || !b.ricavi) return null;
      const pc = (nv, ov) => ov > 0 ? (nv - ov) / ov : null;
      return { ricavi: pc(totalRevenue[0], b.ricavi), ebitda: pc(ebitda[0], b.ebitda), utile: pc(netIncome[0], b.utileNetto), personale: pc(hrCosts[0], b.personale) };
    })(),

    // V3: Sector Benchmarks
    benchmarks: (() => {
      const tmpl = SECTOR_TEMPLATES[company.sectorTemplate] || SECTOR_TEMPLATES.altro;
      const li = n - 1;
      return { sector: tmpl, comparison: [
        { kpi: "Margine Lordo", actual: grossMarginPct[li], benchmark: tmpl.grossMargin, unit: "pct" },
        { kpi: "EBITDA Margin", actual: ebitdaMargin[li], benchmark: tmpl.ebitdaMargin, unit: "pct" },
        { kpi: "Incidenza HR/Ricavi", actual: hrOnRevenue[li], benchmark: tmpl.hrOnRevenue, unit: "pct", invert: true },
        { kpi: "Debt/Equity", actual: debtEquity[li], benchmark: tmpl.debtEquity, unit: "dec", invert: true },
        { kpi: "DSO (gg incasso)", actual: assumptions.dso, benchmark: tmpl.dso, unit: "gg", invert: true },
        { kpi: "DPO (gg pagamento)", actual: assumptions.dpo, benchmark: tmpl.dpo, unit: "gg" }
      ]};
    })()
  };
}
const sanitizeName = s => (s || "azienda").replace(/[^a-zA-Z0-9\u00C0-\u00FA_\- ]/g, "").replace(/\s+/g, "_").substring(0, 50);

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   MONTE CARLO SIMULATION
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function runMonteCarlo(company, revenues, hrs, opexItems, investments, assumptions, iterations = 1000) {
  const results = { netIncome: [], ebitda: [], cumCash: [], dscr: [], revenue: [] };
  const n = company.yearsCount;
  const last = n - 1;
  
  for (let iter = 0; iter < iterations; iter++) {
    // Random perturbations: normal-ish distribution via Box-Muller
    const randNorm = (mean, std) => {
      const u1 = Math.random(), u2 = Math.random();
      return mean + std * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    };
    
    // Perturb revenues: volumes ¬±25%, prices ¬±10%
    const pertRevenues = revenues.map(r => ({
      ...r,
      volumes: r.volumes.map(v => Math.max(0, Math.round(v * randNorm(1, 0.15)))),
      unitPrice: Math.max(0, r.unitPrice * randNorm(1, 0.07)),
      grossMargin: Math.min(0.99, Math.max(0.01, r.grossMargin + randNorm(0, 0.05)))
    }));
    
    // Perturb HR costs ¬±8%
    const pertHrs = hrs.map(h => ({
      ...h,
      annualCost: Math.max(0, h.annualCost * randNorm(1, 0.05))
    }));
    
    // Perturb OpEx ¬±12%
    const pertOpex = opexItems.map(o => ({
      ...o,
      values: o.values.map(v => Math.max(0, v * randNorm(1, 0.08)))
    }));
    
    try {
      const f = computeFinancials(company, pertRevenues, pertHrs, pertOpex, investments, { ...assumptions });
      results.revenue.push(f.totalRevenue[last]);
      results.netIncome.push(f.netIncome[last]);
      results.ebitda.push(f.ebitda[last]);
      results.cumCash.push(f.cumCash[last]);
      if (f.dscr[last] != null) results.dscr.push(f.dscr[last]);
    } catch(e) { /* skip failed iterations */ }
  }
  
  const stats = (arr) => {
    if (!arr.length) return { mean: 0, p5: 0, p25: 0, p50: 0, p75: 0, p95: 0, min: 0, max: 0, std: 0, probPositive: 0 };
    const sorted = [...arr].sort((a, b) => a - b);
    const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
    const variance = arr.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / arr.length;
    return {
      mean, std: Math.sqrt(variance),
      p5: sorted[Math.floor(arr.length * 0.05)],
      p25: sorted[Math.floor(arr.length * 0.25)],
      p50: sorted[Math.floor(arr.length * 0.50)],
      p75: sorted[Math.floor(arr.length * 0.75)],
      p95: sorted[Math.floor(arr.length * 0.95)],
      min: sorted[0], max: sorted[sorted.length - 1],
      probPositive: arr.filter(v => v > 0).length / arr.length
    };
  };
  
  // Build histogram buckets for key metric
  const buildHist = (arr, buckets = 25) => {
    if (!arr.length) return [];
    const min = Math.min(...arr), max = Math.max(...arr);
    if (min === max) return [{ x: min, count: arr.length }];
    const step = (max - min) / buckets;
    const bins = Array.from({ length: buckets }, (_, i) => ({ x: min + step * (i + 0.5), count: 0 }));
    arr.forEach(v => { const idx = Math.min(buckets - 1, Math.floor((v - min) / step)); bins[idx].count++; });
    return bins;
  };
  
  return {
    revenue: { ...stats(results.revenue), hist: buildHist(results.revenue) },
    netIncome: { ...stats(results.netIncome), hist: buildHist(results.netIncome) },
    ebitda: { ...stats(results.ebitda), hist: buildHist(results.ebitda) },
    cumCash: { ...stats(results.cumCash), hist: buildHist(results.cumCash) },
    dscr: { ...stats(results.dscr), hist: buildHist(results.dscr) },
    iterations: results.revenue.length
  };
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   SENSITIVITY ANALYSIS (Tornado)
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function runSensitivity(company, revenues, hrs, opexItems, investments, assumptions) {
  const n = company.yearsCount;
  const last = n - 1;
  const baseF = computeFinancials(company, revenues, hrs, opexItems, investments, assumptions);
  const baseEBITDA = baseF.ebitda[last];
  const baseNI = baseF.netIncome[last];
  const baseCash = baseF.cumCash[last];
  
  const factors = [
    { label: "Volumi vendita", pct: 0.20, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, volumes: r.volumes.map(v => Math.round(v * mult)) }))
    })},
    { label: "Prezzi unitari", pct: 0.15, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, unitPrice: r.unitPrice * mult }))
    })},
    { label: "Margine lordo", pct: 0.10, apply: (mult) => ({
      revenues: revenues.map(r => ({ ...r, grossMargin: Math.min(0.99, r.grossMargin * mult) }))
    })},
    { label: "Costo personale", pct: 0.15, apply: (mult) => ({
      hrs: hrs.map(h => ({ ...h, annualCost: h.annualCost * mult }))
    })},
    { label: "Costi operativi", pct: 0.20, apply: (mult) => ({
      opexItems: opexItems.map(o => ({ ...o, values: o.values.map(v => v * mult) }))
    })},
    { label: "Tasso interesse", pct: 0.30, apply: (mult) => ({
      assumptions: { ...assumptions, interestRate: assumptions.interestRate * mult }
    })},
    { label: "DSO (gg incasso)", pct: 0.30, apply: (mult) => ({
      assumptions: { ...assumptions, dso: Math.round(assumptions.dso * mult) }
    })}
  ];
  
  return factors.map(f => {
    const upMods = f.apply(1 + f.pct);
    const downMods = f.apply(1 - f.pct);
    
    const upF = computeFinancials(company, 
      upMods.revenues || revenues, upMods.hrs || hrs, upMods.opexItems || opexItems,
      investments, upMods.assumptions || assumptions);
    const downF = computeFinancials(company,
      downMods.revenues || revenues, downMods.hrs || hrs, downMods.opexItems || opexItems,
      investments, downMods.assumptions || assumptions);
    
    return {
      label: f.label,
      pct: f.pct,
      ebitda: { up: upF.ebitda[last], down: downF.ebitda[last], base: baseEBITDA },
      netIncome: { up: upF.netIncome[last], down: downF.netIncome[last], base: baseNI },
      cumCash: { up: upF.cumCash[last], down: downF.cumCash[last], base: baseCash }
    };
  }).sort((a, b) => Math.abs(b.ebitda.up - b.ebitda.down) - Math.abs(a.ebitda.up - a.ebitda.down));
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   BILANCIO IMPORT PARSER (PDF + Excel/CSV)
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */

// Parse a number from Italian format: "1.551.281" or "1.551.281,00" or "567.515"
function parseItalianNumber(str) {
  if (!str || typeof str !== "string") return 0;
  // Remove currency symbols, spaces, euro signs
  let s = str.replace(/[‚Ç¨\s]/g, "").trim();
  if (!s || s === "-" || s === "0") return 0;
  // Handle negative: (123) or -123
  const isNeg = s.startsWith("(") || s.startsWith("-");
  s = s.replace(/[()]/g, "").replace(/^-/, "");
  // Italian format: dots as thousands separators, comma as decimal
  // Check if it looks like Italian format (has dots followed by 3 digits)
  if (/^\d{1,3}(\.\d{3})*(,\d+)?$/.test(s)) {
    s = s.replace(/\./g, "").replace(",", ".");
  } else {
    // Fallback: try removing commas as thousands
    s = s.replace(/,/g, "");
  }
  const val = parseFloat(s);
  return isNaN(val) ? 0 : (isNeg ? -val : val);
}

// Extract text from PDF using pdf.js
async function extractPdfText(file) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const pages = [];
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    // Reconstruct lines by grouping items by Y coordinate
    const items = textContent.items.map(item => ({
      text: item.str,
      x: Math.round(item.transform[4]),
      y: Math.round(item.transform[5]),
      width: item.width
    }));
    // Group by Y (with tolerance of 3px)
    const lines = {};
    items.forEach(item => {
      const yKey = Math.round(item.y / 3) * 3;
      if (!lines[yKey]) lines[yKey] = [];
      lines[yKey].push(item);
    });
    // Sort lines top-to-bottom (higher Y = higher on page in PDF coords, so reverse)
    const sortedLines = Object.entries(lines)
      .sort(([a], [b]) => Number(b) - Number(a))
      .map(([_, items]) => {
        items.sort((a, b) => a.x - b.x);
        return items;
      });
    pages.push(sortedLines);
  }
  return pages;
}

// Main PDF bilancio parser ‚Äî looks for specific patterns in the Italian "bilancio abbreviato"
function parseBilancioPdfData(pages) {
  const data = { _raw: {}, _source: "pdf" };
  
  // Flatten all pages into labeled lines: [{label, values}]
  const allLines = [];
  pages.forEach(page => {
    page.forEach(lineItems => {
      const fullText = lineItems.map(i => i.text).join(" ").trim();
      if (!fullText || fullText.length < 2) return;
      
      // Try to extract label (left part) and numeric values (right part)
      // In bilancio PDFs, typically: "Label text    123.456    78.901"
      const parts = [];
      let label = "";
      let nums = [];
      
      // Find all number-like tokens
      const tokens = fullText.split(/\s{2,}|\t/);
      if (tokens.length >= 2) {
        // First meaningful non-number token is label
        let labelParts = [];
        tokens.forEach(t => {
          const cleaned = t.trim();
          if (!cleaned) return;
          // Check if it looks like a number
          const testNum = cleaned.replace(/[‚Ç¨\s]/g, "");
          if (/^[-\(]?\d{1,3}([.\s]\d{3})*(,\d+)?\)?$/.test(testNum) || /^[-\(]?\d+\)?$/.test(testNum)) {
            nums.push(parseItalianNumber(cleaned));
          } else if (/^\d+$/.test(testNum) && parseInt(testNum) > 1900 && parseInt(testNum) < 2100) {
            // Year ‚Äî skip
          } else {
            labelParts.push(cleaned);
          }
        });
        label = labelParts.join(" ").trim();
      } else {
        label = fullText;
      }
      
      // Also try splitting by individual items with X position
      if (nums.length === 0 && lineItems.length >= 2) {
        const sorted = [...lineItems].sort((a, b) => a.x - b.x);
        let labelItems = [];
        let numItems = [];
        // Items on the right half are likely numbers
        const midX = Math.max(...sorted.map(i => i.x)) * 0.45;
        sorted.forEach(item => {
          const t = item.text.trim();
          if (!t) return;
          const testNum = t.replace(/[‚Ç¨\s.]/g, "").replace(",", ".");
          if (item.x > midX && (/^\d/.test(t) || t.startsWith("-") || t.startsWith("("))) {
            const parsed = parseItalianNumber(t);
            if (parsed !== 0 || t === "0") numItems.push(parsed);
          } else {
            labelItems.push(t);
          }
        });
        if (numItems.length > 0 && nums.length === 0) {
          nums = numItems;
          if (labelItems.length > 0) label = labelItems.join(" ").trim();
        }
      }
      
      if (label) {
        allLines.push({ label, values: nums, fullText });
      }
    });
  });
  
  // Now match known bilancio patterns
  const find = (patterns, lines) => {
    for (const line of lines) {
      const l = line.label.toLowerCase().replace(/\s+/g, " ");
      for (const pat of patterns) {
        if (typeof pat === "string" ? l.includes(pat) : pat.test(l)) {
          const val = line.values[0]; // Current year (first column)
          if (val && val !== 0) return { value: val, prev: line.values[1] || 0, label: line.label };
        }
      }
    }
    return null;
  };
  
  // -√¢‚Äö¬¨- STATO PATRIMONIALE -√¢‚Äö¬¨-
  // Attivo
  const totAttivo = find(["totale attivo"], allLines);
  if (totAttivo) data.totaleAttivo = totAttivo.value;
  
  const immImmat = find(["immobilizzazioni immateriali", /^i\s*-\s*immobilizzazioni immateriali/], allLines);
  if (immImmat) data.immobilizzazioniImmateriali = immImmat.value;
  
  const immMat = find(["immobilizzazioni materiali", /^ii\s*-\s*immobilizzazioni materiali/], allLines);
  if (immMat) data.immobilizzazioniMateriali = immMat.value;
  
  const totImm = find(["totale immobilizzazioni (b)", "totale immobilizzazioni"], allLines);
  if (totImm) data.immobilizzazioni = totImm.value;
  
  const disponLiquide = find(["disponibilit√† liquide", /^iv\s*-\s*disponibilit/], allLines);
  if (disponLiquide) data.cassa = disponLiquide.value;
  
  const totCrediti = find(["totale crediti"], allLines);
  const creditiEntro = find(["esigibili entro l'esercizio successivo"], allLines);
  if (creditiEntro && !totCrediti) data.creditiCommerciali = creditiEntro.value;
  if (totCrediti) data.creditiTotali = totCrediti.value;
  
  const rimanenze = find([/^i\s*-\s*rimanenze/, "rimanenze"], allLines);
  if (rimanenze) data.rimanenze = rimanenze.value;
  
  // Passivo
  const capitale = find(["capitale", /^i\s*-\s*capitale/], allLines);
  if (capitale) data.capitaleSociale = capitale.value;
  
  const totPN = find(["totale patrimonio netto"], allLines);
  if (totPN) data.patrimonioNetto = totPN.value;
  
  const utileEserc = find([/utile.*dell'esercizio/, /^ix\s*-\s*utile/], allLines);
  if (utileEserc) data.utileEsercizio = utileEserc.value;
  
  const tfr = find(["trattamento di fine rapporto", /^c\)\s*trattamento/], allLines);
  if (tfr) data.tfr = tfr.value;
  
  const totDebiti = find(["totale debiti"], allLines);
  if (totDebiti) data.debitiTotali = totDebiti.value;
  
  // Dettaglio debiti
  const debitiBanche = find(["debiti verso banche"], allLines);
  if (debitiBanche) data.debitiFinanziari = debitiBanche.value;
  
  const debitiFornitori = find(["debiti verso fornitori"], allLines);
  if (debitiFornitori) data.debitiCommerciali = debitiFornitori.value;
  
  const debitiSoci = find(["debiti verso soci"], allLines);
  if (debitiSoci) data.debitiVersoSoci = debitiSoci.value;
  
  const debitiTributari = find(["debiti tributari"], allLines);
  if (debitiTributari) data.debitiTributari = debitiTributari.value;
  
  // -√¢‚Äö¬¨- CONTO ECONOMICO -√¢‚Äö¬¨-
  const ricavi = find(["ricavi delle vendite e delle prestazioni", /^1\)\s*ricavi/], allLines);
  if (ricavi) data.ricavi = ricavi.value;
  
  const valProduzione = find(["totale valore della produzione"], allLines);
  if (valProduzione) data.valoreProduzione = valProduzione.value;
  
  // Costi
  const materiePrime = find(["per materie prime", /^6\)\s*per materie/], allLines);
  if (materiePrime) data.materiePrime = materiePrime.value;
  
  const servizi = find(["per servizi", /^7\)\s*per servizi/], allLines);
  if (servizi) data.costiServizi = servizi.value;
  
  const godimento = find(["godimento di beni di terzi", /^8\)\s*per godimento/], allLines);
  if (godimento) data.godimentoBeni = godimento.value;
  
  const totPersonale = find(["totale costi per il personale"], allLines);
  const personale = find([/^9\)\s*per il personale/], allLines);
  if (totPersonale) data.personale = totPersonale.value;
  else if (personale) data.personale = personale.value;
  
  const salari = find(["salari e stipendi", /^a\)\s*salari/], allLines);
  if (salari) data.salariStipendi = salari.value;
  
  const oneriSociali = find(["oneri sociali", /^b\)\s*oneri sociali/], allLines);
  if (oneriSociali) data.oneriSociali = oneriSociali.value;
  
  const totAmm = find(["totale ammortamenti e svalutazioni"], allLines);
  if (totAmm) data.ammortamenti = totAmm.value;
  
  const ammImmat = find(["ammortamento delle immobilizzazioni immateriali", /^a\)\s*ammortamento.*immateriali/], allLines);
  if (ammImmat) data.ammortamentiImmateriali = ammImmat.value;
  
  const ammMat = find(["ammortamento delle immobilizzazioni materiali", /^b\)\s*ammortamento.*materiali/], allLines);
  if (ammMat) data.ammortamentiMateriali = ammMat.value;
  
  const oneriDiversi = find(["oneri diversi di gestione", /^14\)\s*oneri diversi/], allLines);
  if (oneriDiversi) data.oneriDiversi = oneriDiversi.value;
  
  const totCostiProd = find(["totale costi della produzione"], allLines);
  if (totCostiProd) data.costiProduzione = totCostiProd.value;
  
  const diffVP = find(["differenza tra valore e costi della produzione"], allLines);
  if (diffVP) data.margineOperativo = diffVP.value;
  
  const interessiPassivi = find(["totale interessi e altri oneri finanziari", "interessi e altri oneri finanziari"], allLines);
  if (interessiPassivi) data.interessiPassivi = interessiPassivi.value;
  
  const risultatoPrimaImposte = find(["risultato prima delle imposte"], allLines);
  if (risultatoPrimaImposte) data.risultatoPrimaImposte = risultatoPrimaImposte.value;
  
  const imposte = find(["totale delle imposte sul reddito"], allLines);
  if (imposte) data.imposte = imposte.value;
  
  const utileNetto = find([/^21\)\s*utile/, "utile (perdita) dell'esercizio"], allLines);
  if (utileNetto) data.utileNetto = utileNetto.value;
  
  // Contributi
  const contributi = find(["contributi in conto esercizio"], allLines);
  if (contributi) data.contributi = contributi.value;
  
  const altriRicavi = find(["totale altri ricavi e proventi"], allLines);
  if (altriRicavi) data.altriRicavi = altriRicavi.value;
  
  // Incrementi per lavori interni  
  const incremInterni = find(["incrementi di immobilizzazioni per lavori interni", /^4\)\s*incrementi/], allLines);
  if (incremInterni) data.incrementiInterni = incremInterni.value;
  
  // -√¢‚Äö¬¨- DATI ANAGRAFICI (dalla nota integrativa) -√¢‚Äö¬¨-
  // Cerca "dipendenti" con numero
  const dipendenti = find(["impiegati", "totale dipendenti"], allLines);
  if (dipendenti) data.dipendenti = Math.round(Math.abs(dipendenti.value));
  
  // Cerca nella nota anche testo libero
  allLines.forEach(line => {
    const l = line.label.toLowerCase();
    // Dipendenti from text
    if (!data.dipendenti && (l.includes("dipendenti") || l.includes("organico")) && line.values.length > 0) {
      const v = Math.abs(line.values[0]);
      if (v > 0 && v < 1000) data.dipendenti = Math.round(v);
    }
    // Ragione sociale
    if (!data.ragioneSociale && (l.includes("sede in") || l.includes("ragione sociale"))) {
      // Try to find company name from nearby lines
    }
  });
  
  // Derive COGS if not explicit
  if (!data.cogs) {
    data.cogs = (data.materiePrime || 0) + (data.rimanenze || 0);
  }
  
  // Derive total operating costs (servizi + godimento + oneri diversi)
  data.costiOperativi = (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
  
  // Compute EBITDA
  if (data.margineOperativo && data.ammortamenti) {
    data.ebitda = data.margineOperativo + (data.ammortamenti || 0);
  }
  
  // Store raw for debug
  data._allLines = allLines.length;
  
  return data;
}

// Excel/CSV parser (improved)
function parseBilancioExcel(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const wb = XLSX.read(e.target.result, { type: "array" });
        const data = { _source: "excel" };
        
        wb.SheetNames.forEach(name => {
          const ws = wb.Sheets[name];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
          
          rows.forEach((row) => {
            const label = String(row[0] || "").toLowerCase().trim();
            // Try multiple columns for the value
            let val = 0;
            for (let c = 1; c <= 4; c++) {
              const candidate = parseItalianNumber(String(row[c] || ""));
              if (candidate !== 0) { val = candidate; break; }
            }
            
            if (label.includes("ricavi delle vendite") || (label.includes("ricavi") && label.includes("prestazioni"))) data.ricavi = val;
            else if (label.includes("totale valore della produzione")) data.valoreProduzione = val;
            else if (label.includes("totale costi della produzione")) data.costiProduzione = val;
            else if (label.includes("per materie prime")) data.materiePrime = val;
            else if (label.match(/^per servizi|^7\)/)) data.costiServizi = val;
            else if (label.includes("godimento")) data.godimentoBeni = val;
            else if (label.includes("totale costi per il personale")) data.personale = val;
            else if (label.includes("salari e stipendi")) data.salariStipendi = val;
            else if (label.includes("totale ammortamenti")) data.ammortamenti = val;
            else if (label.includes("oneri diversi")) data.oneriDiversi = val;
            else if (label.includes("differenza tra valore e costi")) data.margineOperativo = val;
            else if (label.includes("interessi e altri oneri")) data.interessiPassivi = val;
            else if (label.includes("utile") && label.includes("esercizio") && !label.includes("prima")) data.utileNetto = val;
            else if (label.includes("totale patrimonio netto")) data.patrimonioNetto = val;
            else if (label.includes("capitale") && !label.includes("circolante")) data.capitaleSociale = val;
            else if (label.includes("disponibilit√† liquide") && label.includes("totale")) data.cassa = val;
            else if (label.includes("debiti verso banche")) data.debitiFinanziari = val;
            else if (label.includes("debiti verso fornitori")) data.debitiCommerciali = val;
            else if (label.includes("totale debiti")) data.debitiTotali = val;
            else if (label.includes("totale attivo")) data.totaleAttivo = val;
            else if (label.includes("totale immobilizzazioni")) data.immobilizzazioni = val;
            else if (label.includes("trattamento di fine rapporto")) data.tfr = val;
            else if (label.includes("crediti verso clienti")) data.creditiCommerciali = val;
            else if (label.includes("totale crediti")) data.creditiTotali = val;
            else if (label.includes("dipendenti") || label.includes("organico")) {
              if (val > 0 && val < 1000) data.dipendenti = Math.round(val);
            }
          });
        });
        
        data.costiOperativi = (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
        if (!data.cogs) data.cogs = data.materiePrime || 0;
        if (data.margineOperativo && data.ammortamenti) data.ebitda = data.margineOperativo + data.ammortamenti;
        
        resolve(data);
      } catch (err) {
        reject(new Error("Impossibile leggere il file Excel: " + err.message));
      }
    };
    reader.onerror = () => reject(new Error("Errore lettura file"));
    reader.readAsArrayBuffer(file);
  });
}

// Unified parse function (detects file type)

// V4.5: XBRL / XML bilancio parser
async function parseBilancioXBRL(file) {
  var text = await file.text();
  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(text, "text/xml");
  var data = { _raw: {}, _source: "xbrl" };
  
  // Italian XBRL taxonomy mapping (itcc-ci / itcc-ci-ese)
  var mapping = {
    // CE
    "RicaviDelleVenditeEDellePrestazioni": "ricavi",
    "RicaviVenditePrestazioniA1": "ricavi",
    "A1RicaviDelleVenditeEDellePrestazioni": "ricavi",
    "TotaleValoreDellaproduzione": "totalRicavi",
    "TotaleCostiDellaproduzione": "totalCosti",
    "CostiPerMateriePrime": "costiMaterie",
    "CostiPerServiziB7": "costiServizi",
    "CostiPerServizi": "costiServizi",
    "CostiPerIlPersonaleB9": "personale",
    "CostiPerIlPersonale": "personale",
    "TotaleCostiPerIlPersonale": "personale",
    "AmmortamentoImmobilizzazioniImmateriali": "ammImmateriali",
    "AmmortamentoImmobilizzazioniMateriali": "ammMateriali",
    "TotaleAmmortamentiESvalutazioni": "ammortamenti",
    "DifferenzaTraValoreECostiDellaProduzione": "ebit",
    "TotaleProventiEdOneriFinanziari": "interessiPassivi",
    "RisultatoPrimaDelleImposte": "risultatoPrimaImposte",
    "ImposteSulRedditoDellEsercizio": "imposte",
    "UtilePerditeEsercizio": "utileNetto",
    "UtilePerditeDellesercizio": "utileNetto",
    "RisultatoEsercizio": "utileNetto",
    // SP Attivo
    "ImmobilizzazioniImmateriali": "immobilizzazioniImmateriali",
    "TotaleImmobilizzazioniImmateriali": "immobilizzazioniImmateriali",
    "ImmobilizzazioniMateriali": "immobilizzazioniMateriali",
    "TotaleImmobilizzazioniMateriali": "immobilizzazioniMateriali",
    "Rimanenze": "rimanenze",
    "TotaleRimanenze": "rimanenze",
    "CreditiVersoClienti": "creditiCommerciali",
    "CreditiCommerciali": "creditiCommerciali",
    "DepositiBancariEPostali": "cassa",
    "DenariEValoriInCassa": "cassaContanti",
    "TotaleAttivoCircolante": "attivoCircolante",
    // SP Passivo
    "CapitaleSociale": "capitaleSociale",
    "TotalePatrimonioNetto": "patrimonioNetto",
    "PatrimonioNetto": "patrimonioNetto",
    "DebitiVersoFornitori": "debitiCommerciali",
    "DebitiBanche": "debitiFinanziari",
    "DebitiVersoBanche": "debitiFinanziari",
    "TrattoFineRapporto": "tfr",
    "TrattamentoDiFineRapporto": "tfr",
    "FondoTFR": "tfr",
    "NumeroMedioDipendenti": "dipendenti",
    "NumeroDipendenti": "dipendenti"
  };
  
  // Search all elements in the XML
  var allElements = xmlDoc.getElementsByTagName("*");
  for (var i = 0; i < allElements.length; i++) {
    var el = allElements[i];
    var localName = el.localName || el.nodeName.split(":").pop();
    
    for (var key in mapping) {
      if (localName.toLowerCase().indexOf(key.toLowerCase()) >= 0 || localName === key) {
        var val = parseFloat(el.textContent.replace(/[.\s]/g, "").replace(",", "."));
        if (!isNaN(val)) {
          data._raw[localName] = val;
          data[mapping[key]] = val;
        }
        break;
      }
    }
  }
  
  // Derive computed fields
  if (!data.ricavi && data.totalRicavi) data.ricavi = data.totalRicavi;
  if (!data.ammortamenti && (data.ammImmateriali || data.ammMateriali)) {
    data.ammortamenti = (data.ammImmateriali || 0) + (data.ammMateriali || 0);
  }
  if (!data.cassa && data.cassaContanti) data.cassa = data.cassaContanti;
  if (data.costiMaterie || data.costiServizi) {
    data.costiEsterni = (data.costiMaterie || 0) + (data.costiServizi || 0);
  }
  if (data.ricavi && data.personale && !data.ebitda) {
    data.ebitda = data.ricavi - (data.costiEsterni || 0) - data.personale;
  }
  if (data.interessiPassivi) data.interessiPassivi = Math.abs(data.interessiPassivi);
  
  // Check if we found enough data
  var foundKeys = Object.keys(data).filter(function(k) { return k[0] !== "_"; });
  if (foundKeys.length < 3) {
    throw new Error("File XBRL non contiene abbastanza dati riconoscibili. Trovati solo: " + foundKeys.join(", ") + ". Prova con il formato PDF o Excel.");
  }
  
  return data;
}

async function parseBilancioFile(file) {
  const ext = file.name.toLowerCase().split(".").pop();
  
  if (ext === "pdf") {
    const pages = await extractPdfText(file);
    return parseBilancioPdfData(pages);
  } else if (["xlsx", "xls", "csv"].includes(ext)) {
    return await parseBilancioExcel(file);
  } else {
    if (ext === "xbrl" || ext === "xml") {
      return await parseBilancioXBRL(file);
    }
    throw new Error("Formato ." + ext + " non supportato. Formati accettati: PDF, XLSX, XLS, CSV, XBRL.");
  }
}

// Apply parsed bilancio data to the business plan form
function applyBilancioData(data, setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company) {
  // Company
  if (data.capitaleSociale) setCompany(c => ({ ...c, capitaleSociale: data.capitaleSociale }));
  
  /* -√¢‚Äö¬¨- REVENUE + GROSS MARGIN -√¢‚Äö¬¨-
     Strategy: back-calculate grossMargin from actual EBITDA so the model
     reproduces the bilancio results correctly.
     
     For service companies (like software/consulting), "costi per servizi" (B.7)
     is effectively COGS, but it also gets mixed with other costs. Instead of
     guessing the COGS split, we derive grossMargin from:
       grossMargin = (EBITDA + HR + overheadOpEx) / ricavi
     This guarantees the model EBITDA matches the real bilancio.
  */
  const ricavi = data.ricavi || 0;
  if (ricavi > 0) {
    let grossMargin = 0.50; // default fallback
    
    // Best method: derive from actual EBITDA
    const realEBITDA = data.ebitda || (data.margineOperativo && data.ammortamenti 
      ? data.margineOperativo + data.ammortamenti : null);
    const overheadOpEx = (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
    const hrCost = data.personale || 0;
    
    if (realEBITDA) {
      // grossMargin = (EBITDA + HR + OpEx) / Ricavi
      const neededGrossProfit = realEBITDA + hrCost + overheadOpEx;
      grossMargin = Math.max(0.10, Math.min(0.98, neededGrossProfit / ricavi));
    } else if (data.costiServizi) {
      // Fallback: treat servizi as COGS
      const totalCOGS = (data.materiePrime || 0) + (data.costiServizi || 0) + (data.rimanenze || 0);
      grossMargin = Math.max(0.10, Math.min(0.95, 1 - totalCOGS / ricavi));
    } else if (data.materiePrime) {
      grossMargin = Math.max(0.10, Math.min(0.95, 1 - data.materiePrime / ricavi));
    }
    
    setRevenues([{
      ...DEFAULTS.revenueLine(),
      name: "Ricavi vendite e prestazioni (da bilancio)",
      type: "service",
      unitPrice: 1,
      volumes: [ricavi, 0, 0, 0, 0],
      growthRates: [0, 0.08, 0.08, 0.06, 0.06],
      grossMargin: Math.round(grossMargin * 1000) / 1000
    }]);
  }
  
  // HR
  if (data.personale) {
    const nDip = data.dipendenti || 1;
    const costoMedio = Math.round(data.personale / nDip);
    setHrs([{
      ...DEFAULTS.hr(),
      role: `Organico (${nDip} dipendenti da bilancio)`,
      type: "employee",
      annualCost: costoMedio,
      growthRate: 0.02,
      count: [nDip, nDip, nDip + 1, nDip + 1, nDip + 2]
    }]);
  }
  
  /* -√¢‚Äö¬¨- OPERATING COSTS -√¢‚Äö¬¨-
     Only truly "overhead" costs go here: godimento beni (rent/leasing)
     and oneri diversi di gestione. Costi per servizi (B.7) is absorbed
     into the grossMargin calculation above, to avoid double-counting.
  */
  const opexItems = [];
  if (data.godimentoBeni) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Godimento beni di terzi (affitti, leasing)", category: "rent", values: [data.godimentoBeni, 0, 0, 0, 0], growthRate: 0.02 });
  }
  if (data.oneriDiversi) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Oneri diversi di gestione", category: "other", values: [data.oneriDiversi, 0, 0, 0, 0], growthRate: 0.02 });
  }
  // Fallback if no detail available
  if (opexItems.length === 0 && data.costiOperativi) {
    opexItems.push({ ...DEFAULTS.opex(), name: "Costi operativi (da bilancio)", values: [data.costiOperativi, 0, 0, 0, 0], growthRate: 0.03 });
  }
  if (opexItems.length > 0) setOpexItems(opexItems);
  
  // Do NOT import existing immobilizzazioni as new investments!
  // Existing fixed assets are handled via openingFA in assumptions.
  // This avoids inflated depreciation. Only new future investments should go in the investments array.
  setInvestments([]);
  
  // Assumptions
  setAssumptions(a => {
    const newA = { ...a };
    // Opening balances (from bilancio = "Anno 0")
    if (data.cassa) newA.openingCash = data.cassa;
    if (data.debitiFinanziari) {
      newA.openingDebt = data.debitiFinanziari;
      newA.debtAmount = [0, 0, 0, 0, 0];
    }
    if (data.patrimonioNetto) newA.openingEquity = data.patrimonioNetto;
    if (data.tfr) newA.openingTFR = data.tfr;
    if (data.debitiTributari) newA.openingTaxPayable = data.debitiTributari;
    
    // Fixed assets: use net book value and estimate remaining life from actual depreciation
    const immTot = (data.immobilizzazioniImmateriali || 0) + (data.immobilizzazioniMateriali || 0);
    if (immTot > 0) {
      newA.openingFA = immTot;
      const annualDep = (data.ammortamentiImmateriali || 0) + (data.ammortamentiMateriali || 0) || (data.ammortamenti || 0);
      if (annualDep > 0) {
        newA.openingFALife = Math.max(2, Math.round(immTot / annualDep));
      } else {
        newA.openingFALife = 5;
      }
    }
    
    // Working capital opening values for correct delta calculations
    if (data.creditiCommerciali) newA.openingAR = data.creditiCommerciali;
    else if (data.creditiTotali) newA.openingAR = data.creditiTotali;
    if (data.debitiCommerciali) newA.openingAP = data.debitiCommerciali;
    if (data.rimanenze) newA.openingInventory = data.rimanenze;
    
    // Working capital days from actual data
    if (data.creditiCommerciali && data.ricavi) {
      newA.dso = Math.round((data.creditiCommerciali / data.ricavi) * 360);
    } else if (data.creditiTotali && data.ricavi) {
      newA.dso = Math.min(120, Math.round((data.creditiTotali / data.ricavi) * 360));
    }
    if (data.debitiCommerciali && data.costiProduzione) {
      newA.dpo = Math.round((data.debitiCommerciali / data.costiProduzione) * 360);
    }
    if (data.rimanenze && data.cogs) {
      newA.dio = Math.round((data.rimanenze / data.cogs) * 360);
    } else {
      newA.dio = 0;
    }
    
    // Interest rate from actual data
    if (data.interessiPassivi && data.debitiFinanziari && data.debitiFinanziari > 0) {
      newA.interestRate = Math.round((data.interessiPassivi / data.debitiFinanziari) * 1000) / 1000;
    }
    
    // Tax rate from actual data
    if (data.imposte && data.risultatoPrimaImposte && data.risultatoPrimaImposte > 0) {
      const effectiveRate = data.imposte / data.risultatoPrimaImposte;
      if (effectiveRate >= 0.15 && effectiveRate <= 0.45) {
        const scale = effectiveRate / 0.279;
        newA.iresRate = Math.round(0.24 * scale * 1000) / 1000;
        newA.irapRate = Math.round(0.039 * scale * 1000) / 1000;
      }
    }
    
    // Contributi from bilancio
    if (data.contributi && data.contributi > 0) {
      newA.grantAmount = data.contributi;
      newA.grantYears = 1;
    }
    
    return newA;
  });
  
  // V3: Populate bilpianoAnno0 from parsed bilancio
  setCompany(c => {
    const bil = BILANCIO_TEMPLATE();
    bil.ricavi = data.ricavi || 0;
    bil.costiEsterni = (data.materiePrime || 0) + (data.costiServizi || 0) + (data.godimentoBeni || 0) + (data.oneriDiversi || 0);
    bil.valoreAggiunto = bil.ricavi - bil.costiEsterni;
    bil.personale = data.personale || 0;
    bil.ebitda = data.ebitda || 0;
    bil.ammortamenti = data.ammortamenti || ((data.ammortamentiImmateriali || 0) + (data.ammortamentiMateriali || 0));
    bil.ebit = (data.margineOperativo || (bil.ebitda - bil.ammortamenti)) || 0;
    bil.interessiPassivi = data.interessiPassivi || 0;
    bil.risultatoPrimaImposte = data.risultatoPrimaImposte || 0;
    bil.imposte = data.imposte || 0;
    bil.utileNetto = data.utileNetto || 0;
    bil.immobilizzazioniNette = (data.immobilizzazioniImmateriali || 0) + (data.immobilizzazioniMateriali || 0);
    bil.creditiCommerciali = data.creditiCommerciali || data.creditiTotali || 0;
    bil.rimanenze = data.rimanenze || 0;
    bil.cassa = data.cassa || 0;
    bil.capitaleSociale = data.capitaleSociale || 0;
    bil.patrimonioNetto = data.patrimonioNetto || 0;
    bil.debitiFinanziari = data.debitiFinanziari || 0;
    bil.debitiCommerciali = data.debitiCommerciali || 0;
    bil.tfr = data.tfr || 0;
    bil.dipendenti = data.dipendenti || 0;
    bil.annoRiferimento = c.startYear ? c.startYear - 1 : new Date().getFullYear() - 1;
    bil.fonte = "pdf_import";
    return { ...c, bilpianoAnno0: bil, companyType: c.companyType === "nuova_impresa" ? "existing" : c.companyType };
  });
  
  return data;
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   EXPORT ENGINES
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */


// V4.5: Render Chart.js to base64 image for PDF
function renderChartImage(config, width, height) {
  return new Promise(function(resolve) {
    var canvas = document.createElement("canvas");
    canvas.width = width || 800;
    canvas.height = height || 400;
    canvas.style.position = "fixed";
    canvas.style.left = "-9999px";
    document.body.appendChild(canvas);
    var ctx = canvas.getContext("2d");
    var merged = Object.assign({}, config, {
      options: Object.assign({}, config.options || {}, {
        animation: false,
        responsive: false,
        devicePixelRatio: 2,
        plugins: Object.assign({}, (config.options || {}).plugins || {}, {
          legend: Object.assign({}, ((config.options || {}).plugins || {}).legend || {}, { labels: { font: { size: 11 } } })
        })
      })
    });
    var chart = new Chart(ctx, merged);
    // Chart.js with animation:false renders synchronously
    setTimeout(function() {
      var img = canvas.toDataURL("image/png", 1.0);
      chart.destroy();
      document.body.removeChild(canvas);
      resolve(img);
    }, 100);
  });
}

async function exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions) {
  const {
    jsPDF
  } = window.jspdf;
  const doc = new jsPDF({
    orientation: "landscape",
    unit: "mm",
    format: "a4"
  });
  const n = company.yearsCount;
  const cols = ["Voce", ...YL.slice(0, n)];
  const pg = {
    w: 297,
    h: 210,
    mx: 14,
    my: 14
  };
  let y = pg.my;
  const addTitle = text => {
    if (y > pg.h - 30) {
      doc.addPage();
      y = pg.my;
    }
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(15, 36, 64);
    doc.text(text, pg.mx, y);
    y += 3;
    doc.setDrawColor(212, 175, 55);
    doc.setLineWidth(.5);
    doc.line(pg.mx, y, pg.w - pg.mx, y);
    y += 8;
  };
  const addTable = (title, rows, opts = {}) => {
    if (y > pg.h - 40) {
      doc.addPage();
      y = pg.my;
    }
    if (title) {
      doc.setFontSize(11);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(30, 58, 95);
      doc.text(title, pg.mx, y);
      y += 5;
    }
    doc.autoTable({
      startY: y,
      margin: {
        left: pg.mx,
        right: pg.mx
      },
      head: [cols],
      body: rows.map(r => [r.label, ...r.values.slice(0, n).map(v => r.pct ? fmtPct(v) : fmt(v, r.dec || 0))]),
      styles: {
        font: "helvetica",
        fontSize: 8,
        cellPadding: 2,
        lineColor: [229, 231, 235],
        lineWidth: .1
      },
      headStyles: {
        fillColor: [15, 36, 64],
        textColor: 255,
        fontStyle: "bold",
        fontSize: 8
      },
      alternateRowStyles: {
        fillColor: [249, 250, 251]
      },
      columnStyles: {
        0: {
          cellWidth: 55
        }
      },
      didParseCell: data => {
        if (data.section === "body" && data.column.index > 0) {
          data.cell.styles.halign = "right";
          data.cell.styles.font = "courier";
          const val = rows[data.row.index]?.values[data.column.index - 1];
          if (typeof val === "number" && val < 0) data.cell.styles.textColor = [220, 38, 38];
        }
        if (rows[data.row.index]?.bold && data.section === "body") {
          data.cell.styles.fontStyle = "bold";
          if (rows[data.row.index]?.highlight) data.cell.styles.fillColor = [237, 242, 252];
        }
      },
      ...opts
    });
    y = doc.lastAutoTable.finalY + 8;
  };

  // Cover
  doc.setFillColor(15, 36, 64);
  doc.rect(0, 0, pg.w, pg.h, "F");
  doc.setFillColor(212, 175, 55);
  doc.rect(0, pg.h - 3, pg.w, 3, "F");
  doc.setTextColor(255);
  doc.setFontSize(32);
  doc.setFont("helvetica", "bold");
  doc.text("PIANO ECONOMICO-FINANZIARIO", pg.w / 2, pg.h / 2 - 20, {
    align: "center"
  });
  doc.setFontSize(20);
  doc.setFont("helvetica", "normal");
  doc.text(company.name || "Azienda", pg.w / 2, pg.h / 2 + 5, {
    align: "center"
  });
  doc.setFontSize(12);
  doc.setTextColor(148, 163, 184);
  const scenarioLabel = {
    base: "Scenario Base",
    pessimistic: "Scenario Pessimistico",
    optimistic: "Scenario Ottimistico"
  }[company.scenario];
  doc.text(`${scenarioLabel} ‚Äî ${n} anni ‚Äî ${company.currency}`, pg.w / 2, pg.h / 2 + 18, {
    align: "center"
  });
  doc.text("Generato il " + new Date().toLocaleDateString("it-IT"), pg.w / 2, pg.h / 2 + 28, {
    align: "center"
  });

  // V5.1: f = financials BEFORE charts to avoid temporal dead zone
  const f = financials;

  // V4.5: DASHBOARD GRAFICO nel PDF
  doc.addPage();
  y = pg.my;
  addTitle("DASHBOARD GRAFICO");
  
  try {
    var chartLabels = YL.slice(0, n);
    var chartColors = { blue: "#2563eb", green: "#059669", red: "#dc2626", amber: "#d97706", purple: "#7c3aed" };
    
    // Chart 1: Revenue + EBITDA + Net Income trend
    var img1 = await renderChartImage({
      type: "line",
      data: {
        labels: chartLabels,
        datasets: [
          { label: "Ricavi", data: f.totalRevenue.slice(0, n), borderColor: chartColors.blue, backgroundColor: chartColors.blue + "30", fill: true, tension: 0.3, borderWidth: 2, pointRadius: 4 },
          { label: "EBITDA", data: f.ebitda.slice(0, n), borderColor: chartColors.green, backgroundColor: chartColors.green + "30", fill: true, tension: 0.3, borderWidth: 2, pointRadius: 4 },
          { label: "Utile Netto", data: f.netIncome.slice(0, n), borderColor: chartColors.purple, backgroundColor: chartColors.purple + "30", fill: true, tension: 0.3, borderWidth: 2, pointRadius: 4 }
        ]
      },
      options: {
        plugins: { title: { display: true, text: "Trend Ricavi, EBITDA, Utile Netto", font: { size: 14, weight: "bold" } } },
        scales: { y: { ticks: { callback: function(v) { return (v/1000).toFixed(0) + "K"; } } } }
      }
    }, 1200, 500);
    doc.addImage(img1, "PNG", pg.mx, y, pg.w - 2 * pg.mx, 80);
    y += 85;
    
    // Chart 2: Cash Flow stacked bar
    var img2 = await renderChartImage({
      type: "bar",
      data: {
        labels: chartLabels,
        datasets: [
          { label: "CF Operativo", data: f.cfOperating.slice(0, n), backgroundColor: chartColors.green + "cc" },
          { label: "CF Investimento", data: f.cfInvesting.slice(0, n), backgroundColor: chartColors.red + "cc" },
          { label: "CF Finanziamento", data: f.cfFinancing.slice(0, n), backgroundColor: chartColors.blue + "cc" }
        ]
      },
      options: {
        plugins: { title: { display: true, text: "Cash Flow per Attivita", font: { size: 13, weight: "bold" } } },
        scales: { y: { ticks: { callback: function(v) { return (v/1000).toFixed(0) + "K"; } } } }
      }
    }, 560, 400);
    doc.addImage(img2, "PNG", pg.mx, y, (pg.w - 2 * pg.mx) / 2 - 3, 60);
    
    // Chart 3: Cassa vs Debito
    var img3 = await renderChartImage({
      type: "bar",
      data: {
        labels: chartLabels,
        datasets: [
          { label: "Cassa cumulata", data: f.cumCash.slice(0, n), backgroundColor: f.cumCash.slice(0, n).map(function(v) { return v >= 0 ? chartColors.green + "cc" : chartColors.red + "cc"; }) },
          { label: "Debito", data: f.netDebt.slice(0, n).map(function(v) { return -v; }), backgroundColor: chartColors.amber + "cc" }
        ]
      },
      options: {
        plugins: { title: { display: true, text: "Cassa Cumulata vs Debito", font: { size: 13, weight: "bold" } } },
        scales: { y: { ticks: { callback: function(v) { return (v/1000).toFixed(0) + "K"; } } } }
      }
    }, 560, 400);
    doc.addImage(img3, "PNG", pg.w / 2 + 3, y, (pg.w - 2 * pg.mx) / 2 - 3, 60);
    y += 65;
  } catch(e) {
    doc.setFontSize(9);
    doc.setTextColor(156, 163, 175);
    doc.text("Grafici non disponibili: " + e.message, pg.mx, y);
    y += 10;
  }

  // CE
  doc.addPage();
  y = pg.my;
  addTitle("CONTO ECONOMICO PREVISIONALE");
  addTable(null, [{
    label: "Ricavi totali",
    values: f.totalRevenue,
    bold: true,
    highlight: true
  }, {
    label: "  ‚àí Costo del venduto",
    values: f.totalCOGS.map(v => -v)
  }, {
    label: "MARGINE LORDO",
    values: f.grossProfit,
    bold: true,
    highlight: true
  }, {
    label: "  Margine lordo %",
    values: f.grossMarginPct,
    pct: true
  }, {
    label: "  ‚àí Costo personale",
    values: f.hrCosts.map(v => -v)
  }, {
    label: "  ‚àí Costi operativi",
    values: f.opexCosts.map(v => -v)
  }, {
    label: "  + Contributi",
    values: f.grantIncome
  }, {
    label: "EBITDA",
    values: f.ebitda,
    bold: true,
    highlight: true
  }, {
    label: "  Margine EBITDA %",
    values: f.ebitdaMargin,
    pct: true
  }, {
    label: "  ‚àí Ammortamenti",
    values: f.depreciation.map(v => -v)
  }, {
    label: "EBIT",
    values: f.ebit,
    bold: true
  }, {
    label: "  ‚àí Interessi passivi",
    values: f.interest.map(v => -v)
  }, {
    label: "UTILE ANTE IMPOSTE",
    values: f.ebt,
    bold: true
  }, {
    label: "  ‚àí IRES",
    values: f.ires.map(v => -v)
  }, {
    label: "  ‚àí IRAP",
    values: f.irap.map(v => -v)
  }, ...(f.taxCreditUsed.some(v => v > 0) ? [{
    label: "  + Credito d'imposta",
    values: f.taxCreditUsed
  }] : []), {
    label: "UTILE NETTO",
    values: f.netIncome,
    bold: true,
    highlight: true
  }, {
    label: "  Margine netto %",
    values: f.netMargin,
    pct: true
  }]);

  // SP
  doc.addPage();
  y = pg.my;
  addTitle("STATO PATRIMONIALE PREVISIONALE");
  addTable("ATTIVO", [{
    label: "Cassa e disponibilit√†",
    values: f.cash.map(v => Math.max(0, v))
  }, {
    label: "Crediti commerciali",
    values: f.ar
  }, {
    label: "Rimanenze",
    values: f.inventory
  }, {
    label: "Immobilizzazioni nette",
    values: f.netFA
  }, {
    label: "TOTALE ATTIVO",
    values: f.totalAssets,
    bold: true,
    highlight: true
  }]);
  addTable("PASSIVO E PATRIMONIO NETTO", [{
    label: "Debiti commerciali",
    values: f.ap
  }, {
    label: "Debiti tributari",
    values: f.totalTax
  }, {
    label: "Risconti passivi (contributi)",
    values: f.deferredGrant
  }, {
    label: "Debito finanziario",
    values: f.netDebt
  }, {
    label: "Fondo TFR",
    values: f.cumTFR
  }].concat(f.revolvingCredit.some(function(v){return v > 0;}) ? [{
    label: "Fido di cassa (revolving)",
    values: f.revolvingCredit,
    bold: true
  }] : []).concat([{
    label: "PATRIMONIO NETTO:",
    values: f.equity,
    bold: true
  }, {
    label: "  AI) Capitale sociale",
    values: YEARS.map(() => f.capitaleSociale || 0)
  }, {
    label: "  AIV) Riserva legale",
    values: f.riservaLegale
  }, {
    label: "  AVI) Altre riserve",
    values: f.altreRiserve
  }, {
    label: "  AVIII) Utili a nuovo",
    values: f.utiliANuovo
  }, {
    label: "  AIX) Utile esercizio",
    values: f.netIncome
  }, {
    label: "TOTALE PASSIVO",
    values: f.totalLiabEqAdj,
    bold: true,
    highlight: true
  }]));
  if (f.fundingGap.some(v => v > 0)) {
    addTable("/!\\ FABBISOGNO FINANZIARIO", [{
      label: "Gap di cassa (copertura necessaria)",
      values: f.fundingGap,
      bold: true
    }]);
  }

  // CF
  doc.addPage();
  y = pg.my;
  addTitle("RENDICONTO FINANZIARIO PREVISIONALE");
  const wcChange = YEARS.map((_, i) => {
    const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
    const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
    const wcPrev = i === 0 ? f.debitiPrevidenziali[0] : f.debitiPrevidenziali[i] - f.debitiPrevidenziali[i - 1];
    return wcTrade + wcTax + wcPrev;
  });
  const grantAdj = YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]);
  const csInflowArr = YEARS.map((_, i) => i === 0 ? (f.capitaleSocialeInflow || 0) : 0);
  addTable(null, [{
    label: "Utile netto",
    values: f.netIncome
  }, {
    label: "  + Ammortamenti",
    values: f.depreciation
  }, {
    label: "  + TFR accantonato",
    values: f.tfrAccrual
  }, {
    label: "  + Sval. crediti (non-cash)",
    values: f.svalutazioneCrediti
  }, {
    label: "  ¬± Œî Capitale circolante",
    values: wcChange
  }, {
    label: "  ¬± Rettifica contributi (cassa vs comp.)",
    values: grantAdj
  }, {
    label: "CF OPERATIVO",
    values: f.cfOperating,
    bold: true,
    highlight: true
  }, {
    label: "  ‚àí Investimenti",
    values: f.cfInvesting
  }, {
    label: "CF INVESTIMENTO",
    values: f.cfInvesting,
    bold: true
  }, {
    label: "  + Nuovi finanziamenti",
    values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0)
  }, {
    label: "  ‚àí Rimborso debito",
    values: YEARS.map((_, i) => -(f.localRepayment[i] || 0))
  }, {
    label: "  + Conferimento capitale sociale",
    values: csInflowArr
  }, {
    label: "  + Apporto equity",
    values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0)
  }, {
    label: "  ‚àí Dividendi",
    values: f.dividends.map(v => -v)
  }, {
    label: "CF FINANZIAMENTO",
    values: f.cfFinancing,
    bold: true
  }, {
    label: "FLUSSO DI CASSA NETTO",
    values: f.netCF,
    bold: true,
    highlight: true
  }, {
    label: "Cassa cumulata",
    values: f.cumCash,
    bold: true
  }]);

  // ‚ïê‚ïê‚ïê V5.1: CE CIVILISTICO art. 2425 c.c. (PDF) ‚ïê‚ïê‚ïê
  if (f.ceCivil) {
    doc.addPage(); y = pg.my;
    addTitle("CONTO ECONOMICO art. 2425 c.c.");
    addTable(null, [
      { label: "A) VALORE DELLA PRODUZIONE", values: [], bold: true },
      { label: "A1) Ricavi vendite e prestazioni", values: f.ceCivil.map(c => c.A1) },
      { label: "A5) Altri ricavi e proventi", values: f.ceCivil.map(c => c.A5) },
      { label: "Totale valore produzione (A)", values: f.ceCivil.map(c => c.totA), bold: true, highlight: true },
      { label: "B) COSTI DELLA PRODUZIONE", values: [], bold: true },
      { label: "B6) Materie prime e merci", values: f.ceCivil.map(c => c.B6) },
      { label: "B7) Per servizi", values: f.ceCivil.map(c => c.B7) },
      { label: "B9) Per il personale:", values: [], bold: true },
      { label: "   a) Salari e stipendi", values: f.ceCivil.map(c => c.B9a) },
      { label: "   b) Oneri sociali", values: f.ceCivil.map(c => c.B9b) },
      { label: "   c) TFR", values: f.ceCivil.map(c => c.B9c) },
      { label: "   e) Altri costi personale", values: f.ceCivil.map(c => c.B9e) },
      { label: "   Totale personale (B9)", values: f.ceCivil.map(c => c.totB9), bold: true },
      { label: "B10) Amm.ti e svalutazioni:", values: [], bold: true },
      { label: "   b) Amm.to immob. materiali", values: f.ceCivil.map(c => c.B10b) },
      { label: "   d) Sval. crediti att. circ.", values: f.ceCivil.map(c => c.B10d) },
      { label: "   Totale amm.ti (B10)", values: f.ceCivil.map(c => c.totB10), bold: true },
      { label: "Totale costi produzione (B)", values: f.ceCivil.map(c => c.totB), bold: true, highlight: true },
      { label: "DIFFERENZA A \u2212 B", values: f.ceCivil.map(c => c.diffAB), bold: true, highlight: true },
      { label: "C17) Interessi passivi", values: f.ceCivil.map(c => -c.C17) },
      { label: "Risultato prima imposte", values: f.ceCivil.map(c => c.risultatoPrimaImposte), bold: true },
      { label: "20) Imposte (IRES+IRAP)", values: f.ceCivil.map(c => -c.imposte20) },
      { label: "21) UTILE (PERDITA)", values: f.ceCivil.map(c => c.utile21), bold: true, highlight: true },
    ]);
  }

  // ‚ïê‚ïê‚ïê V5.1: SP CIVILISTICO art. 2424 c.c. (PDF) ‚ïê‚ïê‚ïê
  if (f.spCivil) {
    doc.addPage(); y = pg.my;
    addTitle("STATO PATRIMONIALE art. 2424 c.c.");
    addTable("ATTIVO", [
      { label: "B) Immobilizzazioni materiali", values: f.spCivil.map(c => c.BII) },
      { label: "Totale immobilizzazioni (B)", values: f.spCivil.map(c => c.totB_att), bold: true },
      { label: "C) Attivo circolante", values: [], bold: true },
      { label: "  I - Rimanenze", values: f.spCivil.map(c => c.CI) },
      { label: "  II - Crediti (netti)", values: f.spCivil.map(c => c.CII) },
      { label: "  IV - Disponibilit\xE0 liquide", values: f.spCivil.map(c => c.CIV) },
      { label: "Totale att. circolante (C)", values: f.spCivil.map(c => c.totC_att), bold: true },
      { label: "TOTALE ATTIVO", values: f.spCivil.map(c => c.totAttivo), bold: true, highlight: true },
    ]);
    addTable("PASSIVO", [
      { label: "A) Patrimonio netto", values: [], bold: true },
      { label: "  I - Capitale sociale", values: f.spCivil.map(c => c.AI) },
      { label: "  IV - Riserva legale", values: f.spCivil.map(c => c.AIV) },
      { label: "  VI - Altre riserve", values: f.spCivil.map(c => c.AVI) },
      { label: "  VIII - Utili a nuovo", values: f.spCivil.map(c => c.AVIII) },
      { label: "  IX - Utile esercizio", values: f.spCivil.map(c => c.AIX) },
      { label: "Totale PN (A)", values: f.spCivil.map(c => c.totA_pass), bold: true },
      { label: "C) TFR", values: f.spCivil.map(c => c.C_tfr) },
      { label: "D) Debiti", values: [], bold: true },
      { label: "  D4) Verso banche", values: f.spCivil.map(c => c.D4) },
      { label: "  D7) Verso fornitori", values: f.spCivil.map(c => c.D7) },
      { label: "  D12) Tributari", values: f.spCivil.map(c => c.D12) },
      { label: "  D13) Previdenziali", values: f.spCivil.map(c => c.D13) },
      { label: "Totale debiti (D)", values: f.spCivil.map(c => c.totD), bold: true },
      { label: "  entro es. successivo", values: f.spCivil.map(c => c.D_entro) },
      { label: "  oltre es. successivo", values: f.spCivil.map(c => c.D_oltre) },
      { label: "E) Ratei e risconti", values: f.spCivil.map(c => c.E_ratei) },
      { label: "TOTALE PASSIVO", values: f.spCivil.map(c => c.totPassivo), bold: true, highlight: true },
    ]);
  }

  // V5.2: Rendiconto Finanziario OIC 10 nel PDF
  if (f.cfOIC10) {
    doc.addPage();
    y = pg.my;
    addTitle("RENDICONTO FINANZIARIO OIC 10 (metodo indiretto)");
    addTable(null, [
      { label: "A) ATTIVITA' OPERATIVA", values: [], bold: true },
      { label: "Utile (perdita) dell'esercizio", values: f.cfOIC10.map(c => c.utileEsercizio) },
      { label: "Imposte sul reddito", values: f.cfOIC10.map(c => c.imposteReddito) },
      { label: "Interessi passivi", values: f.cfOIC10.map(c => c.interessiPassivi) },
      { label: "1. Utile prima imposte/interessi", values: f.cfOIC10.map(c => c.sub1), bold: true },
      { label: "", values: [] },
      { label: "Rettifiche non monetarie:", values: [], bold: true },
      { label: "  Accantonamento TFR", values: f.cfOIC10.map(c => c.accTFR) },
      { label: "  Ammortamenti immobilizzazioni", values: f.cfOIC10.map(c => c.accAmm) },
      { label: "  Svalutazioni crediti", values: f.cfOIC10.map(c => c.accSval) },
      { label: "  Totale rettifiche non monetarie", values: f.cfOIC10.map(c => c.totRettNonMon), bold: true },
      { label: "2. Flusso prima variazioni CCN", values: f.cfOIC10.map(c => c.sub2), bold: true },
      { label: "", values: [] },
      { label: "Variazioni capitale circolante netto:", values: [], bold: true },
      { label: "  Decr./(incr.) rimanenze", values: f.cfOIC10.map(c => c.deltaRimanenze) },
      { label: "  Decr./(incr.) crediti vs clienti", values: f.cfOIC10.map(c => c.deltaCrediti) },
      { label: "  Incr./(decr.) debiti vs fornitori", values: f.cfOIC10.map(c => c.deltaFornitori) },
      { label: "  Incr./(decr.) debiti tributari", values: f.cfOIC10.map(c => c.deltaTributari) },
      { label: "  Incr./(decr.) debiti previdenziali", values: f.cfOIC10.map(c => c.deltaPrevidenziali) },
      { label: "  Incr./(decr.) risconti passivi", values: f.cfOIC10.map(c => c.deltaRiscontiPass) },
      { label: "  Totale variazioni CCN", values: f.cfOIC10.map(c => c.totDeltaCCN), bold: true },
      { label: "3. Flusso dopo variazioni CCN", values: f.cfOIC10.map(c => c.sub3), bold: true },
      { label: "", values: [] },
      { label: "Altre rettifiche:", values: [], bold: true },
      { label: "  (Interessi pagati)", values: f.cfOIC10.map(c => c.interessiPagati) },
      { label: "  (Imposte pagate)", values: f.cfOIC10.map(c => c.impostePagate) },
      { label: "  Totale altre rettifiche", values: f.cfOIC10.map(c => c.totAltreRett), bold: true },
      { label: "Flusso attivita' operativa (A)", values: f.cfOIC10.map(c => c.cfOpA), bold: true, highlight: true },
      { label: "", values: [] },
      { label: "B) ATTIVITA' DI INVESTIMENTO", values: [], bold: true },
      { label: "  (Investimenti in immob. materiali)", values: f.cfOIC10.map(c => c.cfInvB) },
      { label: "Flusso attivita' investimento (B)", values: f.cfOIC10.map(c => c.cfInvB), bold: true, highlight: true },
      { label: "", values: [] },
      { label: "C) ATTIVITA' DI FINANZIAMENTO", values: [], bold: true },
      { label: "  Accensione finanziamenti", values: f.cfOIC10.map(c => c.nuoviFin) },
      { label: "  (Rimborso finanziamenti)", values: f.cfOIC10.map(c => -c.rimborsoFin) },
      { label: "  Conferimento capitale sociale", values: f.cfOIC10.map(c => c.conferimentoCS) },
      { label: "  Apporto equity", values: f.cfOIC10.map(c => c.apportoEquity) },
      { label: "  (Dividendi pagati)", values: f.cfOIC10.map(c => -c.divPagati) },
      { label: "Flusso attivita' finanziamento (C)", values: f.cfOIC10.map(c => c.cfFinC), bold: true, highlight: true },
      { label: "", values: [] },
      { label: "Incremento (decr.) disp. liquide (A+B+C)", values: f.cfOIC10.map(c => c.deltaLiq), bold: true, highlight: true },
      { label: "Disponibilita' liquide inizio esercizio", values: f.cfOIC10.map(c => c.liqInizio) },
      { label: "Disponibilita' liquide fine esercizio", values: f.cfOIC10.map(c => c.liqFine), bold: true },
    ]);
  }

  // KPI Redditivit√†
  addTitle("INDICATORI CHIAVE (KPI)");
  addTable("Redditivit√†", [{
    label: "Margine lordo %",
    values: f.grossMarginPct,
    pct: true
  }, {
    label: "Margine EBITDA %",
    values: f.ebitdaMargin,
    pct: true
  }, {
    label: "Margine netto %",
    values: f.netMargin,
    pct: true
  }, {
    label: "ROE",
    values: f.roe,
    pct: true
  }, {
    label: "ROI (Return on Investment)",
    values: f.roi,
    pct: true
  }, {
    label: "ROA",
    values: f.roa,
    pct: true
  }, {
    label: "Cost-to-Income",
    values: f.costToIncome,
    pct: true
  }, {
    label: "Incidenza personale/ricavi",
    values: f.hrOnRevenue,
    pct: true
  }, {
    label: "Crescita ricavi YoY",
    values: f.revenueGrowth,
    pct: true
  }]);
  addTable("Sostenibilit√† finanziaria", [{
    label: "DSCR (EBITDA-based)",
    values: f.dscr,
    dec: 2
  }, {
    label: "DSCR Cash-based (EBA)",
    values: f.dscrCash,
    dec: 2
  }, {
    label: "DSCR CADS (conservativo)",
    values: f.dscrCADS,
    dec: 2
  }, {
    label: "ICR (Interest Coverage)",
    values: f.icr,
    dec: 1
  }, {
    label: "Current ratio",
    values: f.currentRatio,
    dec: 2
  }, {
    label: "Equity Ratio (PN/Attivo)",
    values: f.equityRatio,
    pct: true
  }, {
    label: "Debt/Equity",
    values: f.debtEquity,
    dec: 2
  }, {
    label: "Debito/EBITDA",
    values: f.debtToEbitda,
    dec: 1
  }, {
    label: "Cash Debt Coverage",
    values: f.cashDebtCoverage,
    dec: 2
  }, {
    label: "Rapporto indebitamento",
    values: f.debtRatio,
    pct: true
  }]);
  addTable("Break-Even e Struttura", [{
    label: "Costi fissi totali",
    values: f.fixedCosts
  }, {
    label: "Break-Even Point (‚Ç¨)",
    values: f.bep
  }, {
    label: "Margine di sicurezza",
    values: f.bepMargin,
    pct: true
  }, {
    label: "PFN (Posizione Fin. Netta)",
    values: f.pfn
  }, {
    label: "NWC (Cap. Circolante Netto)",
    values: f.nwc
  }, {
    label: "Organico",
    values: f.headcount
  }, {
    label: "Ricavo per dipendente",
    values: f.revPerEmp
  }]);
  // V5: Dettaglio fiscale
  addTable("Dettaglio Fiscale V5", [{
    label: "IRES",
    values: f.ires
  }, {
    label: "  di cui: perdite utilizzate",
    values: f.taxLossUsed
  }, {
    label: "  perdite residue riportabili",
    values: f.taxLossPool
  }, {
    label: "Base imponibile IRAP",
    values: f.irapBase
  }, {
    label: "  Cuneo fiscale dedotto",
    values: f.cuneoFiscale
  }, {
    label: "IRAP (aliq. " + ((f.irapAliquota || 0.039) * 100).toFixed(2) + "%)",
    values: f.irap
  }, {
    label: "Credito d'imposta utilizzato",
    values: f.taxCreditUsed
  }]);

  // V4.4: Benchmark table nel PDF
  if (f.benchmarks && f.benchmarks.comparison) {
    doc.addPage();
    y = pg.my;
    addTitle("CONFRONTO BENCHMARK DI SETTORE");
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(55, 65, 81);
    doc.text("KPI del piano confrontati con la mediana del settore " + (f.benchmarks.sector.label || ""), pg.mx, y);
    y += 8;
    var bmHeaders = [["KPI", "Piano", "Benchmark", "Esito"]];
    var bmRows = f.benchmarks.comparison.map(function(b) {
      var fVal = b.unit === "pct" ? fmtPct(b.actual) : b.unit === "gg" ? ((b.actual||0) + " gg") : ((b.actual||0).toFixed(1) + "x");
      var fBen = b.unit === "pct" ? fmtPct(b.benchmark) : b.unit === "gg" ? (b.benchmark + " gg") : (b.benchmark.toFixed(1) + "x");
      var isGood = b.invert ? (b.actual <= b.benchmark * 1.1) : (b.actual >= b.benchmark * 0.9);
      var isBad = b.invert ? (b.actual > b.benchmark * 1.5) : (b.actual < b.benchmark * 0.5);
      return [b.kpi, fVal, fBen, isGood ? "OK" : isBad ? "CRITICO" : "ATTENZIONE"];
    });
    doc.autoTable({
      head: bmHeaders,
      body: bmRows,
      startY: y,
      margin: { left: pg.mx, right: pg.mx },
      styles: { fontSize: 8, cellPadding: 3 },
      headStyles: { fillColor: [30, 58, 95], textColor: 255, fontStyle: "bold" },
      columnStyles: { 0: { cellWidth: 50 }, 3: { fontStyle: "bold" } },
      didParseCell: function(data) {
        if (data.section === "body" && data.column.index === 3) {
          if (data.cell.raw === "OK") data.cell.styles.textColor = [5, 150, 105];
          else if (data.cell.raw === "CRITICO") data.cell.styles.textColor = [220, 38, 38];
          else data.cell.styles.textColor = [217, 119, 6];
        }
      }
    });
    y = doc.lastAutoTable.finalY + 10;
  }

  // V4.2: Nota Integrativa nel PDF
  doc.addPage();
  y = pg.my;
  addTitle("NOTA INTEGRATIVA");
  var notaSections = generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions);
  notaSections.forEach(function(section) {
    if (y > pg.h - 30) { doc.addPage(); y = pg.my; }
    doc.setFontSize(11);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(30, 58, 95);
    doc.text(section.title, pg.mx, y);
    y += 6;
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(55, 65, 81);
    var lines = doc.splitTextToSize(section.text, pg.w - 2 * pg.mx);
    lines.forEach(function(line) {
      if (y > pg.h - 15) { doc.addPage(); y = pg.my; }
      doc.text(line, pg.mx, y);
      y += 4.5;
    });
    y += 4;
  });

  // V4.2: Disclaimer
  doc.addPage();
  y = pg.my;
  addTitle("DISCLAIMER E METODOLOGIA");
  doc.setFontSize(9);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(107, 114, 128);
  var disclaimerText = "Documento previsionale basato su ipotesi ragionevoli ma soggette a incertezza. Redatto secondo principi OIC. CE art. 2425 c.c., SP art. 2424 c.c. (OIC 12), Rendiconto Finanziario metodo indiretto Schema n.1 (OIC 10, Appendice A). IRAP su Valore Produzione - Costi Produzione. Si raccomanda integrazione con analisi di mercato. Generato il " + new Date().toLocaleDateString("it-IT") + ".";
  var discLines = doc.splitTextToSize(disclaimerText, pg.w - 2 * pg.mx);
  discLines.forEach(function(line) { doc.text(line, pg.mx, y); y += 4.5; });

  // V4.2: Numeri di pagina
  var totalPages = doc.internal.getNumberOfPages();
  for (var p = 1; p <= totalPages; p++) {
    doc.setPage(p);
    doc.setFontSize(7);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(156, 163, 175);
    doc.text(sanitizeName(company.name) + " - Piano Economico", pg.mx, pg.h - 5);
    doc.text("Pag. " + p + "/" + totalPages, pg.w - pg.mx - 25, pg.h - 5);
  }

  doc.save(`piano-economico-${sanitizeName(company.name)}.pdf`);
}
function exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions) {
  const n = company.yearsCount;
  const wb = XLSX.utils.book_new();
  const f = financials;
  const hdr = ["Voce", ...YL.slice(0, n)];
  const makeSheet = (name, sections) => {
    const data = [];
    sections.forEach(sec => {
      if (sec.title) {
        data.push([sec.title]);
        data.push(hdr);
      }
      sec.rows.forEach(r => {
        data.push([r.label, ...r.values.slice(0, n).map(v => r.pct ? fmtPct(v) : Math.round(v * 100) / 100)]);
      });
      data.push([]);
    });
    const ws = XLSX.utils.aoa_to_sheet(data);
    ws["!cols"] = [{
      wch: 35
    }, ...Array(n).fill({
      wch: 16
    })];
    XLSX.utils.book_append_sheet(wb, ws, name);
  };

  // Conto Economico
  makeSheet("Conto Economico", [{
    title: "CONTO ECONOMICO PREVISIONALE",
    rows: [{
      label: "Ricavi totali",
      values: f.totalRevenue
    }, {
      label: "(‚àí) Costo del venduto",
      values: f.totalCOGS.map(v => -v)
    }, {
      label: "MARGINE LORDO",
      values: f.grossProfit
    }, {
      label: "Margine lordo %",
      values: f.grossMarginPct,
      pct: true
    }, {
      label: "(‚àí) Costo personale",
      values: f.hrCosts.map(v => -v)
    }, {
      label: "(‚àí) Costi operativi",
      values: f.opexCosts.map(v => -v)
    }, {
      label: "(+) Contributi",
      values: f.grantIncome
    }, {
      label: "EBITDA",
      values: f.ebitda
    }, {
      label: "Margine EBITDA %",
      values: f.ebitdaMargin,
      pct: true
    }, {
      label: "(‚àí) Ammortamenti",
      values: f.depreciation.map(v => -v)
    }, {
      label: "EBIT",
      values: f.ebit
    }, {
      label: "(‚àí) Interessi passivi",
      values: f.interest.map(v => -v)
    }, {
      label: "UTILE ANTE IMPOSTE (EBT)",
      values: f.ebt
    }, {
      label: "(‚àí) IRES",
      values: f.ires.map(v => -v)
    }, {
      label: "(‚àí) IRAP",
      values: f.irap.map(v => -v)
    }, {
      label: "UTILE NETTO",
      values: f.netIncome
    }, {
      label: "Margine netto %",
      values: f.netMargin,
      pct: true
    }]
  }]);

  // Stato Patrimoniale
  makeSheet("Stato Patrimoniale", [{
    title: "ATTIVO",
    rows: [{
      label: "Cassa e disponibilit√†",
      values: f.cash.map(v => Math.max(0, v))
    }, {
      label: "Crediti commerciali",
      values: f.ar
    }, {
      label: "Rimanenze",
      values: f.inventory
    }, {
      label: "Immobilizzazioni nette",
      values: f.netFA
    }, {
      label: "TOTALE ATTIVO",
      values: f.totalAssets
    }]
  }, {
    title: "PASSIVO E PATRIMONIO NETTO",
    rows: [{
      label: "Debiti commerciali",
      values: f.ap
    }, {
      label: "Debiti tributari",
      values: f.totalTax
    }, {
      label: "Risconti passivi (contributi)",
      values: f.deferredGrant
    }, {
      label: "Debito finanziario",
      values: f.netDebt
    }, {
      label: "Fondo TFR",
      values: f.cumTFR
    }, {
      label: "PATRIMONIO NETTO",
      values: f.equity
    }, {
      label: "  di cui: Capitale sociale",
      values: YEARS.map(() => f.capitaleSociale || 0)
    }, {
      label: "  di cui: Riserva legale",
      values: f.riservaLegale
    }, {
      label: "  di cui: Altre riserve",
      values: f.altreRiserve
    }, {
      label: "  di cui: Utili a nuovo",
      values: f.utiliANuovo
    }, {
      label: "TOTALE PASSIVO E PN",
      values: f.totalLiabEq
    }, {
      label: "Fabbisogno finanziario",
      values: f.fundingGap
    }]
  }]);

  // Cash Flow
  const xlWcChange = YEARS.map((_, i) => {
    const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
    const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
    const wcPrev = i === 0 ? f.debitiPrevidenziali[0] : f.debitiPrevidenziali[i] - f.debitiPrevidenziali[i - 1];
    return wcTrade + wcTax + wcPrev;
  });
  const xlGrantAdj = YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]);
  const xlCsInflow = YEARS.map((_, i) => i === 0 ? (f.capitaleSocialeInflow || 0) : 0);
  makeSheet("Cash Flow", [{
    title: "RENDICONTO FINANZIARIO",
    rows: [{
      label: "Utile netto",
      values: f.netIncome
    }, {
      label: "(+) Ammortamenti",
      values: f.depreciation
    }, {
      label: "(+) TFR accantonato",
      values: f.tfrAccrual
    }, {
      label: "(+) Sval. crediti (non-cash)",
      values: f.svalutazioneCrediti
    }, {
      label: "(¬±) Œî Capitale circolante",
      values: xlWcChange
    }, {
      label: "(¬±) Rettifica contributi (cassa vs comp.)",
      values: xlGrantAdj
    }, {
      label: "CF OPERATIVO",
      values: f.cfOperating
    }, {
      label: "CF INVESTIMENTO",
      values: f.cfInvesting
    }, {
      label: "(+) Nuovi finanziamenti",
      values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0)
    }, {
      label: "(‚àí) Rimborso debito",
      values: YEARS.map((_, i) => -(f.localRepayment[i] || 0))
    }, {
      label: "(+) Conferimento CS",
      values: xlCsInflow
    }, {
      label: "(+) Apporto equity",
      values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0)
    }, {
      label: "(‚àí) Dividendi",
      values: f.dividends.map(v => -v)
    }, {
      label: "CF FINANZIAMENTO",
      values: f.cfFinancing
    }, {
      label: "FLUSSO DI CASSA NETTO",
      values: f.netCF
    }, {
      label: "Cassa cumulata",
      values: f.cumCash
    }]
  }]);

  // V5.2: Rendiconto Finanziario OIC 10 in Excel
  if (f.cfOIC10) {
    makeSheet("CF OIC 10", [{
      title: "RENDICONTO FINANZIARIO OIC 10 (metodo indiretto)",
      rows: [
        { label: "Utile (perdita) dell'esercizio", values: f.cfOIC10.map(c => c.utileEsercizio) },
        { label: "Imposte sul reddito", values: f.cfOIC10.map(c => c.imposteReddito) },
        { label: "Interessi passivi", values: f.cfOIC10.map(c => c.interessiPassivi) },
        { label: "1. Utile prima imposte/interessi", values: f.cfOIC10.map(c => c.sub1) },
        { label: "Accantonamento TFR", values: f.cfOIC10.map(c => c.accTFR) },
        { label: "Ammortamenti immobilizzazioni", values: f.cfOIC10.map(c => c.accAmm) },
        { label: "Svalutazioni crediti", values: f.cfOIC10.map(c => c.accSval) },
        { label: "Totale rettifiche non monetarie", values: f.cfOIC10.map(c => c.totRettNonMon) },
        { label: "2. Flusso prima variazioni CCN", values: f.cfOIC10.map(c => c.sub2) },
        { label: "Decr./(incr.) rimanenze", values: f.cfOIC10.map(c => c.deltaRimanenze) },
        { label: "Decr./(incr.) crediti vs clienti", values: f.cfOIC10.map(c => c.deltaCrediti) },
        { label: "Incr./(decr.) debiti vs fornitori", values: f.cfOIC10.map(c => c.deltaFornitori) },
        { label: "Incr./(decr.) debiti tributari", values: f.cfOIC10.map(c => c.deltaTributari) },
        { label: "Incr./(decr.) debiti previdenziali", values: f.cfOIC10.map(c => c.deltaPrevidenziali) },
        { label: "Incr./(decr.) risconti passivi", values: f.cfOIC10.map(c => c.deltaRiscontiPass) },
        { label: "Totale variazioni CCN", values: f.cfOIC10.map(c => c.totDeltaCCN) },
        { label: "3. Flusso dopo variazioni CCN", values: f.cfOIC10.map(c => c.sub3) },
        { label: "(Interessi pagati)", values: f.cfOIC10.map(c => c.interessiPagati) },
        { label: "(Imposte pagate)", values: f.cfOIC10.map(c => c.impostePagate) },
        { label: "Totale altre rettifiche", values: f.cfOIC10.map(c => c.totAltreRett) },
        { label: "Flusso attivita' operativa (A)", values: f.cfOIC10.map(c => c.cfOpA) },
        { label: "(Investimenti)", values: f.cfOIC10.map(c => c.cfInvB) },
        { label: "Flusso attivita' investimento (B)", values: f.cfOIC10.map(c => c.cfInvB) },
        { label: "Accensione finanziamenti", values: f.cfOIC10.map(c => c.nuoviFin) },
        { label: "(Rimborso finanziamenti)", values: f.cfOIC10.map(c => -c.rimborsoFin) },
        { label: "Conferimento capitale sociale", values: f.cfOIC10.map(c => c.conferimentoCS) },
        { label: "Apporto equity", values: f.cfOIC10.map(c => c.apportoEquity) },
        { label: "(Dividendi pagati)", values: f.cfOIC10.map(c => -c.divPagati) },
        { label: "Flusso attivita' finanziamento (C)", values: f.cfOIC10.map(c => c.cfFinC) },
        { label: "Incremento (decr.) disp. liquide", values: f.cfOIC10.map(c => c.deltaLiq) },
        { label: "Disp. liquide inizio esercizio", values: f.cfOIC10.map(c => c.liqInizio) },
        { label: "Disp. liquide fine esercizio", values: f.cfOIC10.map(c => c.liqFine) },
      ]
    }]);
  }

  // KPI
  makeSheet("KPI", [{
    title: "REDDITIVIT√Ä",
    rows: [{
      label: "Margine lordo %",
      values: f.grossMarginPct,
      pct: true
    }, {
      label: "Margine EBITDA %",
      values: f.ebitdaMargin,
      pct: true
    }, {
      label: "Margine netto %",
      values: f.netMargin,
      pct: true
    }, {
      label: "ROE",
      values: f.roe,
      pct: true
    }, {
      label: "ROA",
      values: f.roa,
      pct: true
    }, {
      label: "Incidenza personale/ricavi",
      values: f.hrOnRevenue,
      pct: true
    }]
  }, {
    title: "SOSTENIBILIT√Ä FINANZIARIA",
    rows: [{
      label: "DSCR (Debt Service Coverage)",
      values: f.dscr
    }, {
      label: "ICR (Interest Coverage)",
      values: f.icr
    }, {
      label: "Current ratio",
      values: f.currentRatio
    }, {
      label: "Debt/Equity",
      values: f.debtEquity
    }, {
      label: "Rapporto indebitamento",
      values: f.debtRatio,
      pct: true
    }]
  }, {
    title: "BREAK-EVEN E STRUTTURA",
    rows: [{
      label: "Costi fissi totali",
      values: f.fixedCosts
    }, {
      label: "Break-Even Point (‚Ç¨)",
      values: f.bep
    }, {
      label: "Margine di sicurezza",
      values: f.bepMargin,
      pct: true
    }, {
      label: "PFN (Posiz. Fin. Netta)",
      values: f.pfn
    }, {
      label: "NWC (Cap. Circolante Netto)",
      values: f.nwc
    }, {
      label: "Organico",
      values: f.headcount
    }, {
      label: "Ricavo per dipendente",
      values: f.revPerEmp
    }, {
      label: "CAGR Ricavi",
      values: YEARS.map(() => f.revenueCAGR),
      pct: true
    }]
  }]);

  // Dati input
  const inputData = [["DATI AZIENDA"], ["Nome", company.name], ["Settore", company.sector], ["Scenario", company.scenario], ["Anni", company.yearsCount], [], ["LINEE DI RICAVO"], ["Nome", "Tipo", "Prezzo unit.", "Margine lordo", ...YL.slice(0, n).map(y => y + " (vol.)"), ...YL.slice(0, n).map(y => y + " (crescita)")], ...revenues.map(r => [r.name, r.type, r.unitPrice, fmtPct(r.grossMargin), ...r.volumes.slice(0, n), ...(r.growthRates || [0, .05, .05, .05, .05]).slice(0, n).map(g => fmtPct(g))]), [], ["PERSONALE"], ["Ruolo", "Tipo", "Costo annuo", "Crescita", ...YL.slice(0, n).map(y => y + " (n¬∞)")], ...hrs.map(h => [h.role, h.type, h.annualCost, fmtPct(h.growthRate), ...h.count.slice(0, n)]), [], ["COSTI OPERATIVI"], ["Nome", "Categoria", "Metodo", "Valore/Tasso", ...YL.slice(0, n)], ...opexItems.map(o => [o.name, o.category, o.isPercentOfRevenue ? "%Ricavi" : "Fisso", o.isPercentOfRevenue ? fmtPct(o.percentOfRevenue) : fmtPct(o.growthRate), ...(o.isPercentOfRevenue ? Array(n).fill("% sui ricavi") : o.values.slice(0, n))]), [], ["INVESTIMENTI"], ["Nome", "Tipo", "Costo", "Vita utile", "Anno"], ...investments.map(inv => [inv.name, inv.type, inv.cost, inv.usefulLife, YL[inv.year]]), [], ["IPOTESI FINANZIARIE"], ["IRES", fmtPct(assumptions.iresRate)], ["IRAP", fmtPct(assumptions.irapRate)], ["IVA", fmtPct(assumptions.vatRate)], ["DSO (gg)", assumptions.dso], ["DPO (gg)", assumptions.dpo], ["DIO (gg)", assumptions.dio], ["Tasso interesse", fmtPct(assumptions.interestRate)], ["Payout dividendi", fmtPct(assumptions.dividendPayout)], ["Contributo", assumptions.grantAmount], ["Anni contributo", assumptions.grantYears]];
  const wsInput = XLSX.utils.aoa_to_sheet(inputData);
  wsInput["!cols"] = [{
    wch: 30
  }, {
    wch: 18
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }, {
    wch: 14
  }];
  XLSX.utils.book_append_sheet(wb, wsInput, "Dati Input");
  XLSX.writeFile(wb, `piano-economico-${sanitizeName(company.name)}.xlsx`);
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   UI COMPONENTS
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
const css = {
  input: {
    width: "100%",
    padding: "8px 12px",
    border: "1px solid #e5e7eb",
    borderRadius: 8,
    fontSize: 14,
    fontFamily: "'JetBrains Mono',monospace",
    background: "#fafafa",
    color: "#111827",
    outline: "none",
    boxSizing: "border-box"
  },
  label: {
    fontSize: 11,
    fontFamily: "'DM Sans',sans-serif",
    color: "#6b7280",
    fontWeight: 500,
    letterSpacing: ".02em",
    textTransform: "uppercase"
  },
  card: {
    background: "#fff",
    borderRadius: 16,
    border: "1px solid #e5e7eb",
    overflow: "hidden",
    boxShadow: "0 1px 3px rgba(0,0,0,.04)"
  }
};
function InputField({
  label,
  value,
  onChange,
  type = "number",
  step,
  min,
  suffix,
  placeholder,
  tooltip,
  style
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 4,
      flex: 1,
      ...style
    }
  }, label && /*#__PURE__*/React.createElement("label", {
    style: css.label,
    title: tooltip
  }, label, tooltip && /*#__PURE__*/React.createElement("span", {
    style: {
      cursor: "help",
      opacity: .5
    }
  }, " \u24D8")), /*#__PURE__*/React.createElement("div", {
    style: {
      position: "relative"
    }
  }, /*#__PURE__*/React.createElement("input", {
    type: type,
    value: value,
    step: step,
    min: min,
    placeholder: placeholder,
    onChange: e => onChange(type === "number" ? parseFloat(e.target.value) || 0 : e.target.value),
    style: {
      ...css.input,
      paddingRight: suffix ? 36 : 12
    },
    onFocus: e => {
      e.target.style.borderColor = "#2563eb";
      e.target.style.boxShadow = "0 0 0 3px rgba(37,99,235,.1)";
    },
    onBlur: e => {
      e.target.style.borderColor = "#e5e7eb";
      e.target.style.boxShadow = "none";
    }
  }), suffix && /*#__PURE__*/React.createElement("span", {
    style: {
      position: "absolute",
      right: 10,
      top: "50%",
      transform: "translateY(-50%)",
      fontSize: 11,
      color: "#9ca3af",
      fontFamily: "'DM Sans',sans-serif"
    }
  }, suffix)));
}
function SelectField({
  label,
  value,
  onChange,
  options
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 4,
      flex: 1
    }
  }, label && /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, label), /*#__PURE__*/React.createElement("select", {
    value: value,
    onChange: e => onChange(e.target.value),
    style: {
      padding: "8px 12px",
      border: "1px solid #e5e7eb",
      borderRadius: 8,
      fontSize: 14,
      fontFamily: "'DM Sans',sans-serif",
      background: "#fafafa",
      color: "#111827",
      outline: "none",
      cursor: "pointer"
    }
  }, options.map(o => /*#__PURE__*/React.createElement("option", {
    key: o.value,
    value: o.value
  }, o.label))));
}
function Card({
  title,
  children,
  accent,
  actions,
  collapsible,
  defaultOpen = true
}) {
  const [open, setOpen] = useState(defaultOpen);
  return /*#__PURE__*/React.createElement("div", {
    style: css.card
  }, title && /*#__PURE__*/React.createElement("div", {
    onClick: collapsible ? () => setOpen(!open) : undefined,
    style: {
      padding: "16px 20px",
      borderBottom: open ? "1px solid #f3f4f6" : "none",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      cursor: collapsible ? "pointer" : "default",
      background: accent ? "linear-gradient(135deg,#1e3a5f 0%,#0f2440 100%)" : "transparent"
    }
  }, /*#__PURE__*/React.createElement("h3", {
    style: {
      margin: 0,
      fontSize: 15,
      fontFamily: "'Playfair Display',serif",
      fontWeight: 700,
      color: accent ? "#fff" : "#111827"
    }
  }, title), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8,
      alignItems: "center"
    },
    onClick: e => e.stopPropagation()
  }, actions, collapsible && /*#__PURE__*/React.createElement("span", {
    style: {
      color: accent ? "#94a3b8" : "#9ca3af",
      fontSize: 12,
      transition: "transform .2s",
      transform: open ? "rotate(180deg)" : "rotate(0)"
    }
  }, " \u25BC"))), open && /*#__PURE__*/React.createElement("div", {
    style: {
      padding: 20
    },
    className: "fade-in"
  }, children));
}
function Btn({
  children,
  onClick,
  primary,
  small,
  danger,
  disabled
}) {
  return /*#__PURE__*/React.createElement("button", {
    onClick: onClick,
    disabled: disabled,
    style: {
      padding: small ? "6px 12px" : "10px 20px",
      borderRadius: 10,
      border: primary ? "none" : danger ? "1px solid #fca5a5" : "1px solid #d1d5db",
      background: primary ? "linear-gradient(135deg,#1e3a5f 0%,#2563eb 100%)" : danger ? "#fef2f2" : "#fff",
      color: primary ? "#fff" : danger ? "#dc2626" : "#374151",
      fontSize: small ? 12 : 14,
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: 600,
      cursor: disabled ? "not-allowed" : "pointer",
      transition: "all .2s",
      opacity: disabled ? .5 : 1
    }
  }, children);
}
function Tip({
  text
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "12px 16px",
      background: "#fffbeb",
      border: "1px solid #fde68a",
      borderRadius: 10,
      fontSize: 13,
      color: "#92400e",
      fontFamily: "'DM Sans',sans-serif",
      lineHeight: 1.6,
      marginBottom: 16
    }
  }, "\uD83D\uDCA1 ", text);
}
function YearHeader({
  n
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `220px repeat(${n},1fr)`,
      gap: 8,
      padding: "8px 0",
      borderBottom: "2px solid #1e3a5f",
      marginBottom: 4
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      letterSpacing: ".05em"
    }
  }, "Voce"), YL.slice(0, n).map((y, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      ...css.label,
      textAlign: "right",
      paddingRight: 8,
      letterSpacing: ".05em"
    }
  }, y)));
}
function YearRow({
  label,
  values,
  n,
  bold,
  highlight,
  pct,
  dec
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `220px repeat(${n},1fr)`,
      gap: 8,
      padding: "6px 0",
      borderBottom: "1px solid #f9fafb",
      alignItems: "center",
      background: highlight ? "rgba(37,99,235,.03)" : "transparent"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 13,
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: bold ? 700 : 400,
      color: bold ? "#111827" : "#4b5563",
      paddingLeft: bold ? 0 : 8
    }
  }, label), values.slice(0, n).map((v, i) => /*#__PURE__*/React.createElement("span", {
    key: i,
    style: {
      fontSize: 13,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: bold ? 700 : 400,
      color: v < 0 ? "#dc2626" : bold ? "#111827" : "#374151",
      textAlign: "right",
      paddingRight: 8
    }
  }, pct ? fmtPct(v) : fmt(v, dec || 0))));
}
function Badge({
  children,
  color = "#2563eb"
}) {
  return /*#__PURE__*/React.createElement("span", {
    style: {
      display: "inline-block",
      padding: "2px 8px",
      borderRadius: 6,
      fontSize: 11,
      fontWeight: 600,
      fontFamily: "'DM Sans',sans-serif",
      background: color + "15",
      color,
      marginLeft: 6
    }
  }, children);
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   STEP COMPONENTS
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function StepCompany({
  company: c,
  setCompany: set,
  setRevenues,
  setHrs,
  setOpexItems,
  setInvestments,
  setAssumptions
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, 
  // V3: Company Type Cards
  React.createElement(Card, { title: "Tipo di Impresa", accent: true },
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10 } },
      COMPANY_TYPES.map(ct => React.createElement("button", {
        key: ct.value,
        onClick: () => set({ ...c, companyType: ct.value }),
        style: { padding: "14px", border: c.companyType === ct.value ? "2px solid #2563eb" : "2px solid #e5e7eb",
          borderRadius: 10, background: c.companyType === ct.value ? "#eff6ff" : "#fff", cursor: "pointer", textAlign: "left", transition: "all .2s" }
      },
        React.createElement("div", { style: { fontSize: 13, fontWeight: 700, color: "#1e3a5f", marginBottom: 3 } }, ct.label),
        React.createElement("div", { style: { fontSize: 11, color: "#6b7280" } }, ct.desc)
      ))
    )
  ),
  // V3: Sector + Start Year + Timeline
  React.createElement(Card, { title: "Asse Temporale e Settore" },
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16, marginBottom: 12 } },
      React.createElement(InputField, { label: "Anno inizio piano", value: c.startYear || new Date().getFullYear(),
        onChange: v => set({ ...c, startYear: parseInt(v) || new Date().getFullYear() }), suffix: "", min: 2020, step: 1,
        tooltip: "L'Anno 1 del piano previsionale." }),
      React.createElement(SelectField, { label: "Settore (benchmark)", value: c.sectorTemplate || "altro",
        onChange: v => { const tmpl = SECTOR_TEMPLATES[v]; if (tmpl) { set({ ...c, sectorTemplate: v, sector: tmpl.label }); setAssumptions(a => ({ ...a, dso: tmpl.dso, dpo: tmpl.dpo, dio: tmpl.dio })); } },
        options: Object.keys(SECTOR_TEMPLATES).map(k => ({ value: k, label: SECTOR_TEMPLATES[k].label }))
      })
    ),
    React.createElement("div", { style: { display: "flex", gap: 4, flexWrap: "wrap" } },
      getYearLabels(c).full.map((yl, i) => React.createElement("div", { key: i, style: {
        padding: "8px 14px", borderRadius: 8, textAlign: "center", minWidth: 70,
        background: yl.type === "storico" ? "#f3f4f6" : yl.type === "consuntivo" ? "#fef3c7" : "#eff6ff",
        border: yl.type === "consuntivo" ? "2px solid #d97706" : yl.type === "previsionale" ? "2px solid #2563eb" : "1px solid #d1d5db"
      } },
        React.createElement("div", { style: { fontSize: 15, fontWeight: 700, color: yl.type === "consuntivo" ? "#92400e" : yl.type === "previsionale" ? "#1e3a5f" : "#9ca3af" } }, yl.label),
        React.createElement("div", { style: { fontSize: 9, color: "#6b7280", textTransform: "uppercase" } },
          yl.type === "storico" ? "Storico" : yl.type === "consuntivo" ? "Consuntivo" : "Previsionale")
      ))
    ),
    React.createElement(Note, null, "Il settore selezionato pre-imposta DSO, DPO, DIO nelle Ipotesi Finanziarie e attiva il confronto Benchmark nei Risultati.")
  ),
  // V3: Bilancio Anno 0 (solo per existing/crisis)
  (c.companyType === "existing" || c.companyType === "crisis") && React.createElement(Card, { title: "\uD83D\uDCC2 Bilancio Anno 0 (Consuntivo " + ((c.startYear || new Date().getFullYear()) - 1) + ")", accent: true },
    React.createElement(Tip, { text: "Inserisci i principali dati del bilancio depositato. I saldi patrimoniali popoleranno automaticamente i Saldi di Apertura. Il CE apparir\u00E0 nei Risultati come colonna consuntivo." }),
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 12 } },
      React.createElement("div", { style: { gridColumn: "1/4", fontWeight: 700, fontSize: 12, color: "#fef3c7", textTransform: "uppercase" } }, "Conto Economico"),
      ...(["ricavi", "costiEsterni", "personale", "ebitda", "ammortamenti", "utileNetto"].map(key => {
        const labels = { ricavi: "Ricavi", costiEsterni: "Costi Esterni", personale: "Personale", ebitda: "EBITDA", ammortamenti: "Ammortamenti", utileNetto: "Utile Netto" };
        return React.createElement(InputField, { key: key, label: labels[key], value: (c.bilpianoAnno0 || {})[key] || 0,
          onChange: v => {
            const bil = { ...(c.bilpianoAnno0 || BILANCIO_TEMPLATE()), annoRiferimento: (c.startYear || new Date().getFullYear()) - 1, fonte: "manuale" };
            bil[key] = v;
            set({ ...c, bilpianoAnno0: bil });
          }, suffix: "\u20AC" });
      })),
      React.createElement("div", { style: { gridColumn: "1/4", fontWeight: 700, fontSize: 12, color: "#fef3c7", textTransform: "uppercase", marginTop: 8 } }, "Stato Patrimoniale"),
      ...(["immobilizzazioniNette", "creditiCommerciali", "rimanenze", "cassa", "patrimonioNetto", "debitiFinanziari", "debitiCommerciali", "tfr"].map(key => {
        const labels = { immobilizzazioniNette: "Immobilizz. Nette", creditiCommerciali: "Crediti Comm.", rimanenze: "Rimanenze", cassa: "Cassa", patrimonioNetto: "Patrimonio Netto", debitiFinanziari: "Debiti Finanziari", debitiCommerciali: "Debiti Fornitori", tfr: "TFR" };
        return React.createElement(InputField, { key: key, label: labels[key], value: (c.bilpianoAnno0 || {})[key] || 0,
          onChange: v => {
            const bil = { ...(c.bilpianoAnno0 || BILANCIO_TEMPLATE()), annoRiferimento: (c.startYear || new Date().getFullYear()) - 1, fonte: "manuale" };
            bil[key] = v;
            // Auto-sync opening balances
            const newC = { ...c, bilpianoAnno0: bil };
            set(newC);
            if (["cassa","debitiFinanziari","patrimonioNetto","immobilizzazioniNette","creditiCommerciali","debitiCommerciali","rimanenze","tfr"].includes(key)) {
              const map = { cassa: "openingCash", debitiFinanziari: "openingDebt", patrimonioNetto: "openingEquity", immobilizzazioniNette: "openingFA", creditiCommerciali: "openingAR", debitiCommerciali: "openingAP", rimanenze: "openingInventory", tfr: "openingTFR" };
              setAssumptions(a => ({ ...a, [map[key]]: v }));
            }
          }, suffix: "\u20AC" });
      }))
    ),
    React.createElement(Note, null, "I dati patrimoniali sono sincronizzati automaticamente con i Saldi di Apertura nello step Ipotesi Finanziarie.")
  ),
  /*#__PURE__*/React.createElement(Tip, {
    text: "Inserisci i dati generali dell'impresa. Lo scenario influenza i ricavi: Pessimistico applica \u221215%, Ottimistico +15%."
  }),
  /*#__PURE__*/React.createElement(ImportBilancioPanel, {
    setCompany: set,
    setRevenues: setRevenues,
    setHrs: setHrs,
    setOpexItems: setOpexItems,
    setInvestments: setInvestments,
    setAssumptions: setAssumptions,
    company: c
  }),
  /*#__PURE__*/React.createElement(Card, {
    title: "Dati Azienda"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Nome Azienda",
    value: c.name,
    onChange: v => set({
      ...c,
      name: v
    }),
    type: "text",
    placeholder: "Es. INGENIA S.R.L."
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Settore",
    value: c.sector,
    onChange: v => set({
      ...c,
      sector: v
    }),
    type: "text",
    placeholder: "Es. Tecnologia"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Valuta",
    value: c.currency,
    onChange: v => set({
      ...c,
      currency: v
    }),
    options: [{
      value: "EUR",
      label: "‚Ç¨ Euro"
    }, {
      value: "USD",
      label: "$ Dollaro"
    }, {
      value: "GBP",
      label: "¬£ Sterlina"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Orizzonte temporale",
    value: c.yearsCount,
    onChange: v => set({
      ...c,
      yearsCount: parseInt(v)
    }),
    options: [{
      value: 3,
      label: "3 Anni"
    }, {
      value: 5,
      label: "5 Anni"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Scenario",
    value: c.scenario,
    onChange: v => set({
      ...c,
      scenario: v
    }),
    options: [{
      value: "base",
      label: "üéØ Base"
    }, {
      value: "pessimistic",
      label: "‚ö†¬†Ô∏è Pessimistico (‚àí15%)"
    }, {
      value: "optimistic",
      label: "üöÄ Ottimistico (+15%)"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Capitale Sociale",
    value: c.capitaleSociale,
    onChange: v => set({
      ...c,
      capitaleSociale: v
    }),
    suffix: "\u20AC",
    tooltip: "Usato per verifica Art. 2447 CC. Il versamento effettivo va inserito come Apporto Equity nel passo Ipotesi."
  })), /*#__PURE__*/React.createElement(Note, null, "Il ", /*#__PURE__*/React.createElement("strong", null, "Capitale Sociale"), " qui serve come riferimento legale per la verifica Art. 2447 c.c. (PN ", "<", " 1/3 CS = obbligo ricapitalizzazione). Il versamento effettivo in cassa va inserito come ", /*#__PURE__*/React.createElement("strong", null, "Apporto Equity Anno 1"), " nel passo Ipotesi Finanziarie. Per SRL ordinaria il minimo \xE8 \u20AC10.000, per SRLS \u20AC1.")), /*#__PURE__*/React.createElement(Card, {
    title: "Come funziona questo strumento"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      color: "#4b5563",
      lineHeight: 1.7
    }
  }, /*#__PURE__*/React.createElement("p", {
    style: {
      margin: "0 0 12px"
    }
  }, "Procedi passo per passo compilando ogni sezione. Al termine, nella sezione ", /*#__PURE__*/React.createElement("strong", null, "Risultati"), " troverai:"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 10
    }
  }, STEPS.map(s => /*#__PURE__*/React.createElement("div", {
    key: s.id,
    style: {
      padding: "8px 12px",
      background: "#f9fafb",
      borderRadius: 8,
      fontSize: 13
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      marginRight: 6
    }
  }, s.icon), /*#__PURE__*/React.createElement("strong", null, s.label), " \u2014 ", s.desc))))));
}
// V4.6: Soft validation warnings (non-blocking)
function SoftWarnings(props) {
  var w = props.warnings;
  if (!w || w.length === 0) return null;
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 4, marginBottom: 12 } },
    w.map(function(msg, i) {
      return React.createElement("div", { key: i, className: "v4-warn-badge" }, "\u26A0\uFE0F ", msg);
    })
  );
}
function getSoftWarnings(stepNum, co, revs, hrs, invs, assu, lng) {
  var tr = I18N[lng] || I18N.it;
  var tmpl = SECTOR_TEMPLATES[co.sectorTemplate] || SECTOR_TEMPLATES.altro;
  var w = [];
  if (stepNum === 1) {
    revs.forEach(function(r) {
      if (r.grossMargin > 0 && tmpl.grossMargin > 0) {
        if (r.grossMargin > tmpl.grossMargin * 1.5) w.push(tr.warnMargineAlto);
        if (r.grossMargin < tmpl.grossMargin * 0.5) w.push(tr.warnMargineBasso);
      }
      (r.growthRates || []).forEach(function(g) { if (g > 0.3) w.push(tr.warnCrescitaAlta); });
    });
  }
  if (stepNum === 3) {
    var tHR = hrs.reduce(function(s, h) { return s + h.annualCost * (h.count[0] || 0); }, 0);
    var tRev = revs.reduce(function(s, r) { return s + (r.unitPrice || 0) * (r.volumes[0] || 0); }, 0);
    if (tRev > 0 && tHR / tRev > (tmpl.hrOnRevenue || 0.35) * 1.3) w.push(tr.warnHrAlto);
  }
  if (stepNum === 6) {
    if (assu.dso > 90) w.push(tr.warnDsoAlto);
    var tDebt = (assu.debtAmount || []).reduce(function(s, v) { return s + (v || 0); }, 0);
    var tInv = invs.reduce(function(s, inv) { return s + inv.cost; }, 0);
    if (tInv > 0 && tDebt > tInv * 2) w.push(tr.warnDebitoAlto);
  }
  return w;
}

function StepRevenue({
  revenues: lines,
  setRevenues: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...lines, DEFAULTS.revenueLine()]);
  const rm = i => set(lines.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...lines];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updArr = (i, field, yi, v) => {
    const u = [...lines];
    u[i] = {
      ...u[i],
      [field]: u[i][field].map((x, j) => j === yi ? v : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Definisci ogni linea di ricavo separatamente (prodotti, servizi, abbonamenti). Margini lordi tipici: Servizi professionali 60-80%, Software/SaaS 70-90%, Commercio 20-40%, Manifattura 25-50%, Ristorazione 60-70%. Il tasso di crescita si applica ai volumi: 5-10% \xE8 conservativo, 15-30% \xE8 aggressivo (devi giustificarlo alla banca). Inserisci almeno il volume Anno 1: gli anni successivi vengono auto-calcolati."
  }), lines.map((l, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: l.name || `Linea di Ricavo ${i + 1}`,
    collapsible: true,
    defaultOpen: i === lines.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Nome",
    value: l.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Licenza Software"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: l.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "product",
      label: "Prodotto"
    }, {
      value: "service",
      label: "Servizio"
    }, {
      value: "subscription",
      label: "Abbonamento"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Prezzo unitario",
    value: l.unitPrice,
    onChange: v => upd(i, "unitPrice", v),
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Margine lordo",
    value: Math.round(l.grossMargin * 100),
    onChange: v => upd(i, "grossMargin", v / 100),
    suffix: "%",
    tooltip: "% ricavo che resta dopo COGS"
  })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "Volumi previsti per anno ", /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 400,
      textTransform: "none"
    }
  }, "(lascia 0 per auto-calcolo da crescita)")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: l.volumes[yi],
    onChange: v => updArr(i, "volumes", yi, v),
    min: 0
  })))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "Tasso di crescita annuo volumi"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: Math.round((l.growthRates ? l.growthRates[yi] : 0.05) * 100),
    onChange: v => updArr(i, "growthRates", yi, v / 100),
    suffix: "%"
  }))))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Linea di Ricavo"), lines.some(l => l.unitPrice > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Ricavi per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Linea"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y)), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, "Media")), lines.filter(l => l.unitPrice > 0).map((l, i) => {
    const revs = YEARS.slice(0, n).map((_, j) => {
      let v = l.volumes[j];
      if (!v && j > 0) {
        let prev = l.volumes[0];
        for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
        v = prev;
      }
      return v * l.unitPrice;
    });
    const avg = revs.reduce((s, v) => s + v, 0) / n;
    return /*#__PURE__*/React.createElement("div", {
      key: i,
      style: {
        display: "grid",
        gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
        gap: 4,
        padding: "5px 0",
        borderBottom: "1px solid #f3f4f6"
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        color: "#374151",
        fontWeight: 500
      }
    }, l.name || `Linea ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
      color: "#2563eb"
    }, l.type === "product" ? "Prod." : l.type === "service" ? "Serv." : "Abb.")), revs.map((v, j) => /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(v))), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#6b7280",
        fontStyle: "italic"
      }
    }, fmt(avg)));
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr) 1fr`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE RICAVI"), YEARS.slice(0, n).map((_, j) => {
    const tot = lines.reduce((s, l) => {
      let v = l.volumes[j];
      if (!v && j > 0) {
        let prev = l.volumes[0];
        for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
        v = prev;
      }
      return s + v * l.unitPrice;
    }, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(tot));
  }), /*#__PURE__*/React.createElement("span", null)))));
}
function StepProduction({
  revenues,
  investments,
  company: {
    yearsCount: n
  }
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Riepilogo automatico: COGS per linea di ricavo e piano ammortamenti degli investimenti. Per modificare i margini torna al passo Ricavi; per modificare gli investimenti vai al passo Investimenti."
  }), /*#__PURE__*/React.createElement(Card, {
    title: "Riepilogo Costi di Produzione (COGS)"
  }, revenues.length === 0 ? /*#__PURE__*/React.createElement("p", {
    style: {
      color: "#9ca3af"
    }
  }, "Nessuna linea di ricavo definita.") : /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 10
    }
  }, revenues.map((l, i) => /*#__PURE__*/React.createElement("div", {
    key: i,
    style: {
      padding: "12px 14px",
      background: "#f9fafb",
      borderRadius: 10
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: 8
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("strong", null, l.name || `Linea ${i + 1}`), /*#__PURE__*/React.createElement(Badge, {
    color: "#059669"
  }, l.type === "product" ? "Prodotto" : l.type === "service" ? "Servizio" : "Abbonamento")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 20,
      fontFamily: "'JetBrains Mono',monospace",
      fontSize: 13
    }
  }, /*#__PURE__*/React.createElement("span", null, "Margine: ", /*#__PURE__*/React.createElement("strong", {
    style: {
      color: "#059669"
    }
  }, Math.round(l.grossMargin * 100), "%")), /*#__PURE__*/React.createElement("span", null, "COGS: ", /*#__PURE__*/React.createElement("strong", {
    style: {
      color: "#dc2626"
    }
  }, Math.round((1 - l.grossMargin) * 100), "%")))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `120px repeat(${n},1fr)`,
      gap: 4,
      fontSize: 12,
      fontFamily: "'JetBrains Mono',monospace"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280",
      fontSize: 10,
      fontWeight: 600
    }
  }, "ANNO"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      color: "#6b7280",
      fontSize: 10,
      fontWeight: 600,
      textAlign: "right"
    }
  }, y)), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "Volumi"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#374151"
      }
    }, fmt(v));
  }), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "Ricavo"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(v * l.unitPrice));
  }), /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#4b5563"
    }
  }, "COGS"), YEARS.slice(0, n).map((_, j) => {
    let v = l.volumes[j];
    if (!v && j > 0) {
      let prev = l.volumes[0];
      for (let k = 1; k <= j; k++) prev = Math.round(prev * (1 + (l.growthRates ? l.growthRates[k] : 0.05)));
      v = prev;
    }
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(v * l.unitPrice * (1 - l.grossMargin)));
  })))))), investments.some(inv => inv.cost > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "Piano Ammortamenti"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Bene"), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, "Costo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), investments.filter(inv => inv.cost > 0).map((inv, k) => /*#__PURE__*/React.createElement("div", {
    key: k,
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "5px 0",
      borderBottom: "1px solid #f3f4f6"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      color: "#374151"
    }
  }, inv.name || `Inv. ${k + 1}`, /*#__PURE__*/React.createElement(Badge, null, inv.type === "tangible" ? "Mat." : "Immat.")), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      fontFamily: "'JetBrains Mono',monospace",
      textAlign: "right",
      color: "#374151"
    }
  }, fmt(inv.cost)), YEARS.slice(0, n).map((_, j) => {
    const dep = j >= inv.year && inv.usefulLife > 0 && j - inv.year < inv.usefulLife ? inv.cost / inv.usefulLife : 0;
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: dep > 0 ? "#374151" : "#d1d5db"
      }
    }, dep > 0 ? fmt(Math.round(dep)) : "‚Äî");
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE AMMORTAMENTI"), /*#__PURE__*/React.createElement("span", null), YEARS.slice(0, n).map((_, j) => {
    const tot = investments.reduce((s, inv) => j >= inv.year && inv.usefulLife > 0 && j - inv.year < inv.usefulLife ? s + inv.cost / inv.usefulLife : s, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right"
      }
    }, fmt(Math.round(tot)));
  })))));
}
function StepHR({
  hrs,
  setHrs: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...hrs, DEFAULTS.hr()]);
  const rm = i => set(hrs.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...hrs];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updC = (i, yi, v) => {
    const u = [...hrs];
    u[i] = {
      ...u[i],
      count: u[i].count.map((x, j) => j === yi ? Math.max(0, Math.round(v)) : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "V5: Inserisci la RAL (Retribuzione Annua Lorda) OPPURE il Costo Azienda. Se inserisci uno, l'altro viene stimato automaticamente (fattore 1,38x). Il TFR viene calcolato sulla RAL (RAL/13,5 x 0,995). CONTRATTO: Tempo Indeterminato genera deduzione cuneo fiscale IRAP (\u20AC8.000/dip.); Apprendista \u2192 costo IRAP-deducibile al 100%; Determinato \u2192 nessuna agevolazione IRAP. Tipo 'Diretto' = produzione; 'Indiretto' = staff/admin."
  }), hrs.map((h, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: h.role || `Risorsa ${i + 1}`,
    collapsible: true,
    defaultOpen: i === hrs.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Ruolo",
    value: h.role,
    onChange: v => upd(i, "role", v),
    type: "text",
    placeholder: "Es. Sviluppatore"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: h.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "direct",
      label: "Diretto (produz.)"
    }, {
      value: "indirect",
      label: "Indiretto (staff)"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Contratto",
    value: h.contractType || "indeterminato",
    onChange: v => upd(i, "contractType", v),
    options: [{
      value: "indeterminato",
      label: "T. Indeterminato"
    }, {
      value: "determinato",
      label: "T. Determinato"
    }, {
      value: "apprendista",
      label: "Apprendistato"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "RAL",
    value: h.ral || 0,
    onChange: v => { upd(i, "ral", v); upd(i, "annualCost", Math.round(v * 1.38)); },
    suffix: "\u20AC",
    placeholder: "Retribuz. lorda"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Costo azienda",
    value: h.annualCost,
    onChange: v => { upd(i, "annualCost", v); upd(i, "ral", Math.round(v / 1.38)); },
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Crescita annua",
    value: Math.round(h.growthRate * 100),
    onChange: v => upd(i, "growthRate", v / 100),
    suffix: "%"
  })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      marginBottom: 8,
      display: "block"
    }
  }, "N\xB0 persone per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: h.count[yi],
    onChange: v => updC(i, yi, v),
    min: 0,
    step: 1
  }))))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Risorsa"), hrs.some(h => h.annualCost > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Costi Personale per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Ruolo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), hrs.filter(h => h.annualCost > 0).map((h, i) => /*#__PURE__*/React.createElement("div", {
    key: i
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "5px 0",
      borderBottom: "1px solid #f3f4f6"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      color: "#374151",
      fontWeight: 500
    }
  }, h.role || `Risorsa ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
    color: h.type === "direct" ? "#059669" : "#6366f1"
  }, h.type === "direct" ? "Dir." : "Indir.")), YEARS.slice(0, n).map((_, j) => {
    const cost = h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(cost));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "2px 0 5px",
      borderBottom: "1px solid #f9fafb"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 10,
      color: "#9ca3af",
      paddingLeft: 8
    }
  }, "\xD7 ", "{", "n\xB0 persone", "}"), YEARS.slice(0, n).map((_, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      fontSize: 10,
      fontFamily: "'JetBrains Mono',monospace",
      textAlign: "right",
      color: "#9ca3af"
    }
  }, h.count[j] || 0, " pers. \xD7 ", fmt(Math.round(h.annualCost * Math.pow(1 + h.growthRate, j))), "/cad"))))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE PERSONALE"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(tot));
  })), hrs.some(h => h.type === "direct") && hrs.some(h => h.type === "indirect") && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "4px 0"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      color: "#059669"
    }
  }, "  di cui Diretti"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.filter(h => h.type === "direct").reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 11,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#059669"
      }
    }, fmt(tot));
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "4px 0"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      color: "#6366f1"
    }
  }, "  di cui Indiretti"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.filter(h => h.type === "indirect").reduce((s, h) => s + h.annualCost * (h.count[j] || 0) * Math.pow(1 + h.growthRate, j), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 11,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#6366f1"
      }
    }, fmt(tot));
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      marginTop: 8,
      borderTop: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12,
      fontWeight: 600,
      color: "#374151"
    }
  }, "ORGANICO TOTALE"), YEARS.slice(0, n).map((_, j) => {
    const tot = hrs.reduce((s, h) => s + (h.count[j] || 0), 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        fontWeight: 700,
        color: "#374151"
      }
    }, tot, " persone");
  })))));
}
function StepOpEx({
  opexItems: items,
  setOpexItems: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...items, DEFAULTS.opex()]);
  const rm = i => set(items.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...items];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  const updV = (i, yi, v) => {
    const u = [...items];
    u[i] = {
      ...u[i],
      values: u[i].values.map((x, j) => j === yi ? v : x)
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "Costi operativi tipici PMI: Affitto (\u20AC300-800/mq anno uffici), Utenze (\u20AC3.000-15.000/anno), Assicurazioni (0,5-2% ricavi), Marketing/commerciale (3-10% ricavi per B2B, 10-20% B2C), Consulenze (commercialista, legale, IT), Software e licenze, Manutenzioni. \uD83D\uDCA1 Due metodi disponibili nel campo 'Metodo': (1) IMPORTO FISSO \u2192 inserisci il valore Anno 1, gli anni successivi crescono automaticamente col tasso indicato. (2) % SUI RICAVI \u2192 calcolo automatico proporzionale ai ricavi di ogni anno (es. commissioni delivery, royalties, provvigioni agenti)."
  }), items.map((o, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: o.name || `Costo ${i + 1}`,
    collapsible: true,
    defaultOpen: i === items.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Descrizione",
    value: o.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Affitto ufficio"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Categoria",
    value: o.category,
    onChange: v => upd(i, "category", v),
    options: [{
      value: "general",
      label: "Generale"
    }, {
      value: "rent",
      label: "Affitto"
    }, {
      value: "marketing",
      label: "Marketing"
    }, {
      value: "utilities",
      label: "Utenze"
    }, {
      value: "insurance",
      label: "Assicurazione"
    }, {
      value: "other",
      label: "Altro"
    }]
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Metodo",
    value: o.isPercentOfRevenue ? "percent" : "fixed",
    onChange: v => upd(i, "isPercentOfRevenue", v === "percent"),
    options: [{
      value: "fixed",
      label: "Importo fisso"
    }, {
      value: "percent",
      label: "% sui Ricavi"
    }]
  })), o.isPercentOfRevenue ? /*#__PURE__*/React.createElement(InputField, {
    label: "% sui ricavi",
    value: (o.percentOfRevenue * 100).toFixed(1),
    onChange: v => upd(i, "percentOfRevenue", v / 100),
    suffix: "%",
    step: 0.1
  }) : /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 8
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: {
      ...css.label,
      display: "block"
    }
  }, "Importi per anno ", /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 400,
      textTransform: "none"
    }
  }, "(lascia 0 per auto-crescita da Anno 1)")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, yi) => /*#__PURE__*/React.createElement(InputField, {
    key: yi,
    label: YL[yi],
    value: o.values[yi],
    onChange: v => updV(i, yi, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement(InputField, {
    label: "Tasso di crescita annuo (se auto)",
    value: Math.round(o.growthRate * 100),
    onChange: v => upd(i, "growthRate", v / 100),
    suffix: "%",
    style: {
      maxWidth: 200
    }
  }))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Costo Operativo"), items.some(o => o.values[0] > 0 || o.isPercentOfRevenue) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCCA Riepilogo Costi Operativi per Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderBottom: "2px solid #1e3a5f"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label
    }
  }, "Voce"), /*#__PURE__*/React.createElement("span", {
    style: {
      ...css.label,
      textAlign: "center"
    }
  }, "Metodo"), YL.slice(0, n).map((y, j) => /*#__PURE__*/React.createElement("span", {
    key: j,
    style: {
      ...css.label,
      textAlign: "right"
    }
  }, y))), items.filter(o => o.values[0] > 0 || o.isPercentOfRevenue).map((o, i) => {
    const vals = YEARS.slice(0, n).map((_, j) => {
      if (o.isPercentOfRevenue) return null; // can't calc without revenues
      if (o.values[j] > 0) return o.values[j];
      let base = 0,
        baseYear = 0;
      for (let k = j - 1; k >= 0; k--) {
        if (o.values[k] > 0) {
          base = o.values[k];
          baseYear = k;
          break;
        }
      }
      return base > 0 ? base * Math.pow(1 + o.growthRate, j - baseYear) : 0;
    });
    const catLabel = {
      general: "Gen.",
      rent: "Affitto",
      marketing: "Mktg",
      utilities: "Utenze",
      insurance: "Assic.",
      other: "Altro"
    }[o.category] || "";
    return /*#__PURE__*/React.createElement("div", {
      key: i,
      style: {
        display: "grid",
        gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
        gap: 4,
        padding: "5px 0",
        borderBottom: "1px solid #f3f4f6"
      }
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 12,
        color: "#374151",
        fontWeight: 500
      }
    }, o.name || `Costo ${i + 1}`, /*#__PURE__*/React.createElement(Badge, {
      color: "#d97706"
    }, catLabel)), /*#__PURE__*/React.createElement("span", {
      style: {
        fontSize: 10,
        color: "#6b7280",
        textAlign: "center"
      }
    }, o.isPercentOfRevenue ? `${(o.percentOfRevenue * 100).toFixed(1)}% ric.` : `Fisso +${Math.round(o.growthRate * 100)}%`), vals.map((v, j) => /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: v != null ? "#dc2626" : "#9ca3af"
      }
    }, v != null ? fmt(Math.round(v)) : "% ric.")));
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `180px 80px repeat(${n},1fr)`,
      gap: 4,
      padding: "6px 0",
      borderTop: "2px solid #1e3a5f",
      fontWeight: 700
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 12
    }
  }, "TOTALE COSTI OP."), /*#__PURE__*/React.createElement("span", null), YEARS.slice(0, n).map((_, j) => {
    const tot = items.reduce((s, o) => {
      if (o.isPercentOfRevenue) return s; // skip % items (need revenue context)
      if (o.values[j] > 0) return s + o.values[j];
      let base = 0,
        baseYear = 0;
      for (let k = j - 1; k >= 0; k--) {
        if (o.values[k] > 0) {
          base = o.values[k];
          baseYear = k;
          break;
        }
      }
      return base > 0 ? s + base * Math.pow(1 + o.growthRate, j - baseYear) : s;
    }, 0);
    return /*#__PURE__*/React.createElement("span", {
      key: j,
      style: {
        fontSize: 12,
        fontFamily: "'JetBrains Mono',monospace",
        textAlign: "right",
        color: "#dc2626"
      }
    }, fmt(Math.round(tot)));
  })), items.some(o => o.isPercentOfRevenue) && /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 10,
      color: "#9ca3af",
      fontStyle: "italic"
    }
  }, "* Le voci \"% sui ricavi\" saranno calcolate nei Risultati in base ai ricavi effettivi."))));
}
function StepInvestments({
  investments: invs,
  setInvestments: set,
  company: {
    yearsCount: n
  }
}) {
  const add = () => set([...invs, DEFAULTS.investment()]);
  const rm = i => set(invs.filter((_, idx) => idx !== i));
  const upd = (i, f, v) => {
    const u = [...invs];
    u[i] = {
      ...u[i],
      [f]: v
    };
    set(u);
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "L'ammortamento \xE8 a quote costanti (SLN): Costo \xF7 Vita utile. Vite utili tipiche Italia: Macchinari 7-10 anni, Attrezzature 4-5 anni, Mobili e arredi 8 anni, Autovetture 4 anni, Software/brevetti 3-5 anni, Impianti 10-12 anni, Fabbricati 33 anni. Per beni Industria 4.0: vita utile minore se previsto dal piano Transizione 5.0. Il tipo (Materiale/Immateriale) \xE8 rilevante per i bandi agevolativi."
  }), invs.map((inv, i) => /*#__PURE__*/React.createElement(Card, {
    key: i,
    title: inv.name || `Investimento ${i + 1}`,
    collapsible: true,
    defaultOpen: i === invs.length - 1,
    actions: /*#__PURE__*/React.createElement(Btn, {
      small: true,
      danger: true,
      onClick: () => rm(i)
    }, "\u2715")
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "2fr 1fr 1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Descrizione",
    value: inv.name,
    onChange: v => upd(i, "name", v),
    type: "text",
    placeholder: "Es. Macchinari"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Tipo",
    value: inv.type,
    onChange: v => upd(i, "type", v),
    options: [{
      value: "tangible",
      label: "Materiale"
    }, {
      value: "intangible",
      label: "Immateriale"
    }]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Costo (IVA esclusa)",
    value: inv.cost,
    onChange: v => upd(i, "cost", v),
    suffix: "\u20AC"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Vita utile",
    value: inv.usefulLife,
    onChange: v => upd(i, "usefulLife", v),
    suffix: "anni",
    min: 1,
    step: 1
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Anno acquisto",
    value: inv.year,
    onChange: v => upd(i, "year", parseInt(v)),
    options: YEARS.slice(0, n).map((_, i) => ({
      value: i,
      label: YL[i]
    }))
  })), /*#__PURE__*/React.createElement("div", {
    style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 12, marginTop: 8 }
  }, /*#__PURE__*/React.createElement(SelectField, {
    label: "Categoria",
    value: inv.category || "generic",
    onChange: v => upd(i, "category", v),
    options: [
      { value: "generic", label: "Generico" },
      { value: "macchinari", label: "Macchinari" },
      { value: "attrezzature", label: "Attrezzature" },
      { value: "software", label: "Software/Brevetti" },
      { value: "automezzi", label: "Automezzi" },
      { value: "mobili", label: "Mobili e arredi" },
      { value: "impianti", label: "Impianti" },
      { value: "fabbricati", label: "Fabbricati" }
    ]
  }), /*#__PURE__*/React.createElement("div", {
    style: { display: "flex", alignItems: "center", gap: 8, paddingTop: 22 }
  }, /*#__PURE__*/React.createElement("input", {
    type: "checkbox",
    checked: inv.industry40 || false,
    onChange: e => upd(i, "industry40", e.target.checked),
    style: { width: 18, height: 18, accentColor: "#1e40af" }
  }), /*#__PURE__*/React.createElement("label", {
    style: { fontSize: 13, color: "#374151", cursor: "pointer" }
  }, "\uD83C\uDFED Industria 4.0 / Transizione 5.0")),
  /*#__PURE__*/React.createElement("div", {
    style: { display: "flex", alignItems: "center", gap: 8, paddingTop: 22 }
  }, /*#__PURE__*/React.createElement("input", {
    type: "checkbox",
    checked: inv.vatDeductible !== false,
    onChange: e => upd(i, "vatDeductible", e.target.checked),
    style: { width: 18, height: 18, accentColor: "#1e40af" }
  }), /*#__PURE__*/React.createElement("label", {
    style: { fontSize: 13, color: "#374151", cursor: "pointer" }
  }, "IVA detraibile"))))), /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: add
  }, "+ Aggiungi Investimento"));
}
function StepAssumptions({
  assumptions: a,
  setAssumptions: set,
  company: {
    yearsCount: n
  }
}) {
  const upd = (f, v) => set({
    ...a,
    [f]: v
  });
  const updA = (f, i, v) => {
    const arr = [...a[f]];
    arr[i] = v;
    set({
      ...a,
      [f]: arr
    });
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement(Tip, {
    text: "IRES 24% e IRAP ~5% sono le aliquote standard italiane. IVA 22% ordinaria (10% ridotta, 4% minima). DSO = giorni medi di incasso clienti (PMI Italia: 60-90 gg, PA: fino a 60 gg per legge). DPO = giorni medi pagamento fornitori (tipico: 30-90 gg). DIO = giorni di giacenza magazzino (0 per servizi, 30-60 per commercio, 60-120 per manifattura). Un CCC (DSO+DIO-DPO) alto assorbe cassa e aumenta il fabbisogno di capitale circolante."
  }), /*#__PURE__*/React.createElement(Card, {
    title: "Fiscalit\xE0 e Imposte (V5)"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "IRES",
    value: (a.iresRate * 100).toFixed(1),
    onChange: v => upd("iresRate", v / 100),
    suffix: "%",
    tooltip: "24% standard (2024+)"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Regione IRAP",
    value: a.irapRegione || "standard",
    onChange: v => upd("irapRegione", v),
    options: [
      {value: "standard", label: "Standard (3,90%)"},
      {value: "campania", label: "Campania (4,97%)"},
      {value: "calabria", label: "Calabria (4,82%)"},
      {value: "sicilia", label: "Sicilia (4,82%)"},
      {value: "puglia", label: "Puglia (4,82%)"},
      {value: "basilicata", label: "Basilicata (4,82%)"}
    ]
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "IVA",
    value: Math.round(a.vatRate * 100),
    onChange: v => upd("vatRate", v / 100),
    suffix: "%"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Cuneo fiscale/dip.",
    value: a.cuneoFiscalePerDip || 8000,
    onChange: v => upd("cuneoFiscalePerDip", v),
    suffix: "\u20AC",
    tooltip: "Deduzione IRAP per dipendente a tempo indeterminato"
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 16,
      marginTop: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Perdite fiscali pregresse",
    value: a.openingTaxLoss || 0,
    onChange: v => upd("openingTaxLoss", v),
    suffix: "\u20AC",
    tooltip: "Perdite IRES riportabili da esercizi precedenti (art. 84 TUIR)"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "% sval. crediti",
    value: ((a.badDebtRate || 0.02) * 100).toFixed(1),
    onChange: v => upd("badDebtRate", v / 100),
    suffix: "%",
    tooltip: "Fondo svalutazione crediti (default 2%)"
  }), /*#__PURE__*/React.createElement(SelectField, {
    label: "Amm.to 1\xB0 anno",
    value: a.firstYearDeprReduction === false ? "no" : "si",
    onChange: v => upd("firstYearDeprReduction", v === "si"),
    options: [
      {value: "si", label: "Ridotto 50%"},
      {value: "no", label: "Intero 100%"}
    ],
    tooltip: "Ammortamento ridotto al 50% nel primo anno (prassi fiscale)"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Credito d'imposta",
    value: a.taxCreditAmount || 0,
    onChange: v => upd("taxCreditAmount", v),
    suffix: "\u20AC",
    tooltip: "Transizione 5.0, R&S, ZES"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Capitale Circolante"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "DSO (gg incasso)",
    value: a.dso,
    onChange: v => upd("dso", v),
    suffix: "gg",
    tooltip: "Tempo medio incasso crediti"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "DPO (gg pagamento)",
    value: a.dpo,
    onChange: v => upd("dpo", v),
    suffix: "gg",
    tooltip: "Tempo medio pagamento fornitori"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "DIO (gg magazzino)",
    value: a.dio,
    onChange: v => upd("dio", v),
    suffix: "gg",
    tooltip: "Giacenza media magazzino"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Debito Finanziario"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Tasso di interesse",
    value: (a.interestRate * 100).toFixed(1),
    onChange: v => upd("interestRate", v / 100),
    suffix: "%"
  }), /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Nuovo debito per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.debtAmount[i],
    onChange: v => updA("debtAmount", i, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Rimborso debito per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.debtRepayment[i],
    onChange: v => updA("debtRepayment", i, v),
    suffix: "\u20AC"
  }))))), /*#__PURE__*/React.createElement(Card, {
    title: "Equity e Dividendi"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: css.label
  }, "Apporto equity per anno"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 8
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement(InputField, {
    key: i,
    label: YL[i],
    value: a.equityInjection[i],
    onChange: v => updA("equityInjection", i, v),
    suffix: "\u20AC"
  }))), /*#__PURE__*/React.createElement(InputField, {
    label: "Payout dividendi (% utile netto)",
    value: Math.round(a.dividendPayout * 100),
    onChange: v => upd("dividendPayout", v / 100),
    suffix: "%"
  }))), /*#__PURE__*/React.createElement(Card, {
    title: "Contributi a Fondo Perduto"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Importo contributo",
    value: a.grantAmount,
    onChange: v => upd("grantAmount", v),
    suffix: "\u20AC",
    tooltip: "Es. bando PNRR, fondi regionali, Resto al Sud"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Anni di competenza",
    value: a.grantYears,
    onChange: v => upd("grantYears", v),
    suffix: "anni",
    min: 1,
    step: 1
  })), /*#__PURE__*/React.createElement(Note, null, "Il contributo a fondo perduto viene incassato nell'Anno 1 e riconosciuto a CE in quote costanti sugli anni di competenza. La parte non ancora riconosciuta appare come risconto passivo nello Stato Patrimoniale.")), /*#__PURE__*/React.createElement(Card, {
    title: "Credito d'Imposta (Transizione 5.0 / R&D / Formazione)"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Importo totale credito",
    value: a.taxCreditAmount,
    onChange: v => upd("taxCreditAmount", v),
    suffix: "\u20AC",
    tooltip: "Credito d'imposta maturato sugli investimenti eleggibili"
  }), /*#__PURE__*/React.createElement(InputField, {
    label: "Anni di fruizione",
    value: a.taxCreditYears,
    onChange: v => upd("taxCreditYears", v),
    suffix: "anni",
    min: 1,
    step: 1,
    tooltip: "Tipico: 3 anni per Transizione 5.0, 3-5 per R&S"
  })), /*#__PURE__*/React.createElement(Note, null, "Il credito d'imposta NON \xE8 un contributo: non va a ricavo ma ", /*#__PURE__*/React.createElement("strong", null, "riduce le imposte"), " (IRES/IRAP). Se le imposte dell'anno sono inferiori al credito disponibile, la differenza non genera rimborso ma si perde. Transizione 5.0: 35-45% su beni strumentali 4.0; R&S: 10-20% su spese ammissibili; Formazione 4.0: 30-60% su costi formativi.")), /*#__PURE__*/React.createElement(Card, {
    title: "TFR \u2014 Trattamento di Fine Rapporto"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(InputField, {
    label: "Aliquota TFR",
    value: (a.tfrRate * 100).toFixed(2),
    onChange: v => upd("tfrRate", v / 100),
    suffix: "%",
    tooltip: "Standard 7,41% della retribuzione annua lorda"
  })), /*#__PURE__*/React.createElement(Note, null, "Il TFR \xE8 gi\xE0 incluso nel \"costo azienda lordo\" che inserisci nel passo Personale. Qui lo evidenziamo perch\xE9 si accumula come ", /*#__PURE__*/React.createElement("strong", null, "passivit\xE0"), " in bilancio (il dipendente lo incassa solo alla cessazione del rapporto). Per aziende ", ">", " 50 dipendenti il TFR va versato all'INPS o a fondi pensione \u2014 in quel caso il costo \xE8 monetario e puoi impostare l'aliquota a 0%.")), /*#__PURE__*/React.createElement(Card, {
    title: "Tipo Ammortamento Debito"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(SelectField, {
    label: "Metodo",
    value: a.debtType,
    onChange: v => upd("debtType", v),
    options: [{
      value: "manual",
      label: "Manuale (inserisci rimborsi)"
    }, {
      value: "francese",
      label: "Alla francese (rata costante)"
    }]
  }), a.debtType === "francese" && /*#__PURE__*/React.createElement(InputField, {
    label: "Durata finanziamento",
    value: a.debtDuration,
    onChange: v => upd("debtDuration", v),
    suffix: "anni",
    min: 1,
    step: 1
  })), /*#__PURE__*/React.createElement(Note, null, "Ammortamento ", /*#__PURE__*/React.createElement("strong", null, "alla francese"), ": rata costante (quota capitale crescente + quota interessi decrescente). \xC8 il metodo pi\xF9 usato dalle banche italiane per mutui e finanziamenti. Se scegli \"Manuale\", inserisci tu i rimborsi anno per anno sopra.")),
    /*#__PURE__*/React.createElement(Card, { title: "Saldi di Apertura (da Bilancio)" },
      /*#__PURE__*/React.createElement(Tip, { text: "Valori dello stato patrimoniale di partenza (Anno 0). Se hai importato un bilancio, vengono compilati automaticamente. Per startup, lascia tutto a zero." }),
      /*#__PURE__*/React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 12 } },
        /*#__PURE__*/React.createElement(InputField, { label: "Cassa iniziale", value: a.openingCash || 0, onChange: v => upd("openingCash", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Debito finanziario", value: a.openingDebt || 0, onChange: v => upd("openingDebt", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Patrimonio netto", value: a.openingEquity || 0, onChange: v => upd("openingEquity", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Immobilizzazioni nette", value: a.openingFA || 0, onChange: v => upd("openingFA", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Vita utile residua", value: a.openingFALife || 5, onChange: v => upd("openingFALife", v), suffix: "anni", min: 1, step: 1 }),
        /*#__PURE__*/React.createElement(InputField, { label: "Crediti commerciali", value: a.openingAR || 0, onChange: v => upd("openingAR", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Debiti commerciali", value: a.openingAP || 0, onChange: v => upd("openingAP", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "TFR accantonato", value: a.openingTFR || 0, onChange: v => upd("openingTFR", v), suffix: "\u20AC" }),
        /*#__PURE__*/React.createElement(InputField, { label: "Rimanenze", value: a.openingInventory || 0, onChange: v => upd("openingInventory", v), suffix: "\u20AC" })
      )
    ));
}
function Gauge({
  label,
  value,
  format,
  thresholds,
  note,
  invert
}) {
  // thresholds: {green:x, yellow:y} ‚Äî green if value>=green, yellow if >=yellow, red otherwise (invert reverses)
  let color = "#6b7280",
    bg = "#f3f4f6",
    icon = "‚ö™";
  if (value != null && !isNaN(value) && thresholds) {
    const {
      green,
      yellow
    } = thresholds;
    if (invert) {
      if (value <= green) {
        color = "#059669";
        bg = "#ecfdf5";
        icon = "üò¢";
      } else if (value <= yellow) {
        color = "#d97706";
        bg = "#fffbeb";
        icon = "üò°";
      } else {
        color = "#dc2626";
        bg = "#fef2f2";
        icon = "üò¥";
      }
    } else {
      if (value >= green) {
        color = "#059669";
        bg = "#ecfdf5";
        icon = "üò¢";
      } else if (value >= yellow) {
        color = "#d97706";
        bg = "#fffbeb";
        icon = "üò°";
      } else {
        color = "#dc2626";
        bg = "#fef2f2";
        icon = "üò¥";
      }
    }
  }
  const display = value == null || isNaN(value) ? "N/A" : format === "pct" ? fmtPct(value) : format === "dec2" ? fmt(value, 2) : format === "dec1" ? fmt(value, 1) : format === "eur" ? fmtEur(value) : format === "months" ? Math.round(value) + " mesi" : format === "days" ? value + " gg" : fmt(value);
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "14px 16px",
      background: bg,
      borderRadius: 12,
      borderLeft: `4px solid ${color}`,
      display: "flex",
      flexDirection: "column",
      gap: 6
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11,
      fontWeight: 600,
      color: "#6b7280",
      textTransform: "uppercase",
      letterSpacing: ".03em"
    }
  }, label), /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: 11
    }
  }, icon)), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 22,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color
    }
  }, display), note && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      color: "#6b7280",
      lineHeight: 1.4,
      fontStyle: "italic"
    }
  }, note));
}
function HealthCheck({
  financials: f,
  n
}) {
  const warnings = [];
  const tips = [];
  const last = n - 1;

  // DSCR
  f.dscr.slice(0, n).forEach((v, i) => {
    if (v != null && v < 1) warnings.push(`Anno ${i + 1}: DSCR = ${fmt(v, 2)} ‚Äî l'azienda non genera abbastanza cassa per servire il debito. La banca considerer√† il prestito a rischio.`);
  });
  f.dscr.slice(0, n).forEach((v, i) => {
    if (v != null && v >= 1 && v < 1.2) tips.push(`Anno ${i + 1}: DSCR = ${fmt(v, 2)} ‚Äî sufficiente ma sotto la soglia 1,2√ó preferita dalle banche. Valuta di ridurre il debito o migliorare l'EBITDA.`);
  });

  // Margini
  if (f.grossMarginPct[last] < 0.25 && f.totalRevenue[last] > 0) warnings.push(`Margine lordo ${fmtPct(f.grossMarginPct[last])} basso. Sotto il 25% la PMI ha poco spazio per coprire i costi fissi. Rivedi pricing o costi di produzione.`);
  if (f.ebitdaMargin[last] < 0 && f.totalRevenue[last] > 0) warnings.push(`EBITDA negativo all'anno ${n}: l'attivit√† operativa non √® sostenibile. I costi fissi superano il margine lordo.`);

  // Equity negativo
  if (f.equity[last] < 0) warnings.push(`Patrimonio netto negativo (‚Ç¨ ${fmt(f.equity[last])}): causa di scioglimento ex art. 2484 c.c. Serve ricapitalizzazione o aumento dell'equity.`);

  // Art. 2447 CC: PN < 1/3 capitale sociale
  f.art2447.slice(0, n).forEach((v, i) => {
    if (v && f.equity[i] >= 0) warnings.push(`Anno ${i + 1}: Patrimonio netto (‚Ç¨ ${fmt(f.equity[i])}) inferiore a 1/3 del Capitale Sociale ‚Äî obbligo di ricapitalizzazione ex art. 2447 c.c. L'assemblea deve deliberare riduzione CS o ricapitalizzazione.`);
  });

  // V5: Art. 2446 CC: perdite > 1/3 capitale sociale
  if (f.art2446) f.art2446.slice(0, n).forEach((v, i) => {
    if (v) warnings.push("Anno " + (i+1) + ": perdite cumulate > 1/3 del CS √¢‚Ç¨‚Äù obbligo convocazione assemblea (art. 2446 c.c.).");
  });
  // V5: Perdite fiscali riportabili
  if (f.taxLossPool && f.taxLossPool[last] > 0) tips.push("Perdite fiscali residue: \u20AC " + fmt(f.taxLossPool[last]) + ". Compensabili max " + ((company.companyType === "startup_innovativa" || company.companyType === "nuova_impresa") ? "100% (primi 3 anni)" : "80%") + " del reddito futuro.");
  if (f.taxLossUsed && f.taxLossUsed.slice(0, n).some(function(v){return v > 0;})) tips.push("Perdite fiscali utilizzate: \u20AC " + fmt(f.taxLossUsed.slice(0, n).reduce(function(s,v){return s+v;}, 0)) + ". Risparmio IRES: \u20AC " + fmt(f.taxLossUsed.slice(0, n).reduce(function(s,v){return s+v;}, 0) * 0.24) + ".");
  // V5: Cuneo fiscale
  if (f.cuneoFiscale && f.cuneoFiscale[last] > 0) tips.push("Cuneo fiscale IRAP: \u20AC " + fmt(f.cuneoFiscale[last]) + " (" + (f.headcountTI ? f.headcountTI[last] : 0) + " dip. TI).");
  // V5: Riserva legale
  if (f.riservaLegale && f.riservaLegale[last] > 0) { var tRL = (company.capitaleSociale || 0) / 5; tips.push("Riserva legale: \u20AC " + fmt(f.riservaLegale[last]) + (f.riservaLegale[last] >= tRL ? " (target raggiunto)." : " su target \u20AC " + fmt(tRL) + ".")); }


  // Payback
  if (f.paybackPeriod != null) tips.push(`Payback raggiunto nell'Anno ${f.paybackPeriod + 1}: l'investimento iniziale viene recuperato dalla cassa cumulata. ${f.paybackPeriod <= 1 ? "Ottimo, recupero veloce." : f.paybackPeriod <= 2 ? "Buon tempo di recupero." : "Tempo di recupero medio-lungo, accettabile per investimenti strutturali."}`);
  if (f.paybackPeriod == null && f.cumCash[last] < 0) warnings.push(`Payback NON raggiunto entro l'orizzonte del piano: la cassa cumulata resta negativa. L'investimento non si ripaga nei tempi previsti.`);

  // Tax credit
  if (f.taxCreditUsed.slice(0, n).some(v => v > 0)) tips.push(`Credito d'imposta utilizzato: ‚Ç¨ ${fmt(f.taxCreditUsed.slice(0, n).reduce((s, v) => s + v, 0))} in ${n} anni. Risparmio fiscale effettivo.`);

  // Cash
  if (f.fundingGap.slice(0, n).some(v => v > 0)) warnings.push(`Gap di cassa rilevato: il piano non √® finanziariamente sostenibile senza copertura aggiuntiva (equity, finanziamento, o taglio costi).`);

  // BEP
  f.bepMargin.slice(0, n).forEach((v, i) => {
    if (v != null && v < 0) warnings.push(`Anno ${i + 1}: i ricavi (‚Ç¨ ${fmt(f.totalRevenue[i])}) sono sotto il break-even (‚Ç¨ ${fmt(f.bep[i])}). L'azienda opera in perdita strutturale.`);
  });

  // HR incidence
  if (f.hrOnRevenue[last] > 0.6 && f.totalRevenue[last] > 0) tips.push(`Incidenza personale/ricavi ${fmtPct(f.hrOnRevenue[last])} elevata (>60%). Tipica di startup, ma attenzione alla scalabilit√†.`);

  // Burn rate
  f.runway.slice(0, n).forEach((v, i) => {
    if (v != null && v < 6) warnings.push(`Anno ${i + 1}: con il burn rate attuale la cassa si esaurisce in ${Math.round(v)} mesi. Runway critico (<6 mesi).`);
  });
  f.runway.slice(0, n).forEach((v, i) => {
    if (v != null && v >= 6 && v < 12) tips.push(`Anno ${i + 1}: runway di ${Math.round(v)} mesi. Sufficiente ma prevedi un piano B di finanziamento.`);
  });

  // Interest coverage
  f.icr.slice(0, n).forEach((v, i) => {
    if (v != null && v < 1.5) warnings.push(`Anno ${i + 1}: Interest Coverage Ratio = ${fmt(v, 1)}√ó ‚Äî la banca vuole almeno 1,5√ó. L'EBIT copre a malapena gli interessi.`);
  });

  // D/E
  f.debtEquity.slice(0, n).forEach((v, i) => {
    if (v != null && v > 3) tips.push(`Anno ${i + 1}: Debt/Equity = ${fmt(v, 1)}√ó ‚Äî leva elevata (>3√ó). I finanziatori potrebbero richiedere garanzie aggiuntive.`);
  });

  // Positive
  if (warnings.length === 0 && tips.length === 0) tips.push(`Il piano appare equilibrato. Tutti gli indicatori chiave sono entro soglie accettabili.`);
  if (warnings.length === 0 && tips.length === 0) return null;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 8
    }
  }, warnings.map((w, i) => /*#__PURE__*/React.createElement("div", {
    key: "w" + i,
    style: {
      padding: "10px 14px",
      background: "#fef2f2",
      border: "1px solid #fca5a5",
      borderRadius: 10,
      fontSize: 12,
      color: "#991b1b",
      lineHeight: 1.5
    }
  }, "\uD83D\uDD34 ", w)), tips.map((t, i) => /*#__PURE__*/React.createElement("div", {
    key: "t" + i,
    style: {
      padding: "10px 14px",
      background: "#fffbeb",
      border: "1px solid #fde68a",
      borderRadius: 10,
      fontSize: 12,
      color: "#92400e",
      lineHeight: 1.5
    }
  }, "\uD83D\uDCA1 ", t)));
}
function Note({
  children
}) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "10px 14px",
      background: "#f0f9ff",
      border: "1px solid #bae6fd",
      borderRadius: 10,
      fontSize: 11,
      color: "#0369a1",
      lineHeight: 1.5,
      marginTop: 8
    }
  }, "\uD83D\uDCD8 ", /*#__PURE__*/React.createElement("strong", null, "Nota:"), " ", children);
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   CHART.JS WRAPPER COMPONENT
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function ChartCanvas({ type, data, options, height = 280 }) {
  const canvasRef = useRef(null);
  const chartRef = useRef(null);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    if (chartRef.current) chartRef.current.destroy();
    
    const ctx = canvasRef.current.getContext("2d");
    chartRef.current = new Chart(ctx, {
      type,
      data,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: "top", labels: { font: { family: "'DM Sans',sans-serif", size: 11 }, padding: 12, usePointStyle: true } },
          tooltip: { backgroundColor: "#0f2440", titleFont: { family: "'DM Sans',sans-serif" }, bodyFont: { family: "'JetBrains Mono',monospace", size: 11 }, padding: 10, cornerRadius: 8,
            callbacks: { label: (ctx) => { const v = ctx.parsed.y ?? ctx.parsed; return ctx.dataset.label + ": ‚Ç¨ " + fmt(v); } }
          }
        },
        scales: type !== "doughnut" && type !== "pie" && type !== "radar" ? {
          x: { grid: { display: false }, ticks: { font: { family: "'DM Sans',sans-serif", size: 11 } } },
          y: { grid: { color: "#f3f4f6" }, ticks: { font: { family: "'JetBrains Mono',monospace", size: 10 }, callback: v => fmt(v) } }
        } : undefined,
        ...options
      }
    });
    return () => { if (chartRef.current) chartRef.current.destroy(); };
  }, [type, JSON.stringify(data), JSON.stringify(options)]);
  
  return React.createElement("div", { style: { height, position: "relative" } },
    React.createElement("canvas", { ref: canvasRef })
  );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   CHARTS PANEL (Tab Grafici)
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function ChartsPanel({ financials: f, company }) {
  const n = company.yearsCount;
  const labels = YL.slice(0, n);
  const colors = { blue: "#2563eb", green: "#059669", red: "#dc2626", amber: "#d97706", purple: "#7c3aed", cyan: "#06b6d4", pink: "#ec4899" };
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 20 } },
    // Revenue + EBITDA + Net Income trend
    React.createElement(Card, { title: "üìà Trend Ricavi, EBITDA, Utile Netto" },
      React.createElement(ChartCanvas, {
        type: "line",
        height: 320,
        data: {
          labels,
          datasets: [
            { label: "Ricavi", data: f.totalRevenue.slice(0, n), borderColor: colors.blue, backgroundColor: colors.blue + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 },
            { label: "EBITDA", data: f.ebitda.slice(0, n), borderColor: colors.green, backgroundColor: colors.green + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 },
            { label: "Utile Netto", data: f.netIncome.slice(0, n), borderColor: colors.purple, backgroundColor: colors.purple + "20", fill: true, tension: 0.3, borderWidth: 2.5, pointRadius: 5 }
          ]
        }
      })
    ),
    // Cash Flow waterfall (stacked bar)
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 } },
      React.createElement(Card, { title: "üí∞ Cash Flow per Attivit√†" },
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 280,
          data: {
            labels,
            datasets: [
              { label: "CF Operativo", data: f.cfOperating.slice(0, n), backgroundColor: colors.green + "cc" },
              { label: "CF Investimento", data: f.cfInvesting.slice(0, n), backgroundColor: colors.red + "cc" },
              { label: "CF Finanziamento", data: f.cfFinancing.slice(0, n), backgroundColor: colors.blue + "cc" }
            ]
          },
          options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": ‚Ç¨ " + fmt(ctx.parsed.y) } } } }
        })
      ),
      React.createElement(Card, { title: "üè¶ Cassa Cumulata vs Debito" },
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 280,
          data: {
            labels,
            datasets: [
              { label: "Cassa cumulata", data: f.cumCash.slice(0, n), backgroundColor: f.cumCash.slice(0, n).map(v => v >= 0 ? colors.green + "cc" : colors.red + "cc") },
              { label: "Debito finanziario", data: f.netDebt.slice(0, n).map(v => -v), backgroundColor: colors.amber + "cc" }
            ]
          }
        })
      )
    ),
    // Margins radar
    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 } },
      React.createElement(Card, { title: "üéØ Composizione Costi (Ultimo Anno)" },
        React.createElement(ChartCanvas, {
          type: "doughnut",
          height: 260,
          data: {
            labels: ["COGS", "Personale", "Costi Op.", "Ammortamenti", "Interessi", "Imposte"],
            datasets: [{
              data: [f.totalCOGS[n-1], f.hrCosts[n-1], f.opexCosts[n-1], f.depreciation[n-1], f.interest[n-1], f.totalTax[n-1]].map(v => Math.max(0, v)),
              backgroundColor: [colors.red+"cc", colors.blue+"cc", colors.amber+"cc", colors.purple+"cc", colors.cyan+"cc", colors.pink+"cc"]
            }]
          },
          options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.label + ": ‚Ç¨ " + fmt(ctx.parsed) } } } }
        })
      ),
      React.createElement(Card, { title: "üìä¬† Margini nel Tempo" },
        React.createElement(ChartCanvas, {
          type: "line",
          height: 260,
          data: {
            labels,
            datasets: [
              { label: "Margine Lordo %", data: f.grossMarginPct.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.blue, tension: 0.3, borderWidth: 2, pointRadius: 4 },
              { label: "EBITDA Margin %", data: f.ebitdaMargin.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.green, tension: 0.3, borderWidth: 2, pointRadius: 4 },
              { label: "Margine Netto %", data: f.netMargin.slice(0, n).map(v => (v || 0) * 100), borderColor: colors.purple, tension: 0.3, borderWidth: 2, pointRadius: 4 }
            ]
          },
          options: { scales: { y: { grid: { color: "#f3f4f6" }, ticks: { callback: v => v + "%" } } }, plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": " + ctx.parsed.y.toFixed(1) + "%" } } } }
        })
      )
    ),
    // BEP vs Revenue
    React.createElement(Card, { title: "üéØ Ricavi vs Break-Even Point" },
      React.createElement(ChartCanvas, {
        type: "bar",
        height: 260,
        data: {
          labels,
          datasets: [
            { label: "Ricavi", data: f.totalRevenue.slice(0, n), backgroundColor: colors.green + "cc" },
            { label: "Break-Even", data: f.bep.slice(0, n).map(v => v || 0), backgroundColor: colors.red + "55", borderColor: colors.red, borderWidth: 2, type: "line", fill: false, tension: 0.3, pointRadius: 5 }
          ]
        }
      })
    )
  );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   SENSITIVITY ANALYSIS PANEL
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function SensitivityPanel({ company, revenues, hrs, opexItems, investments, assumptions }) {
  const [sensData, setSensData] = useState(null);
  const [metric, setMetric] = useState("ebitda");
  
  useEffect(() => {
    const timer = setTimeout(() => {
      try { setSensData(runSensitivity(company, revenues, hrs, opexItems, investments, assumptions)); }
      catch(e) { console.error(e); }
    }, 100);
    return () => clearTimeout(timer);
  }, [company, revenues, hrs, opexItems, investments, assumptions]);
  
  if (!sensData) return React.createElement("div", { className: "pulse", style: { textAlign: "center", padding: 40, color: "#6b7280" } }, "Calcolo analisi di sensitivit√†...");
  
  const metricLabels = { ebitda: "EBITDA", netIncome: "Utile Netto", cumCash: "Cassa Cumulata" };
  const base = sensData[0]?.[metric]?.base || 0;
  const maxRange = Math.max(...sensData.map(s => Math.abs(s[metric].up - s[metric].down)));
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: `L'analisi di sensitivit√† mostra come varia il risultato al variare di ogni singolo parametro (¬±%). I fattori pi√π lunghi sono quelli con maggiore impatto.` }),
    React.createElement("div", { style: { display: "flex", gap: 8, marginBottom: 8 } },
      Object.entries(metricLabels).map(([k, v]) =>
        React.createElement("button", {
          key: k, onClick: () => setMetric(k),
          style: { padding: "6px 14px", borderRadius: 8, border: metric === k ? "2px solid #2563eb" : "1px solid #d1d5db", 
                   background: metric === k ? "#eff6ff" : "#fff", fontFamily: "'DM Sans',sans-serif", fontSize: 12, fontWeight: 600,
                   color: metric === k ? "#2563eb" : "#6b7280", cursor: "pointer" }
        }, v)
      )
    ),
    React.createElement(Card, { title: `üî¨ Tornado Chart ‚Äî ${metricLabels[metric]} (Anno ${company.yearsCount})` },
      React.createElement("div", { style: { padding: "8px 0" } },
        React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: 10, color: "#6b7280", fontWeight: 600, marginBottom: 12, padding: "0 60px 0 160px" } },
          React.createElement("span", null, "‚ñº Scenario negativo"),
          React.createElement("span", null, `Base: ‚Ç¨ ${fmt(base)}`),
          React.createElement("span", null, "Scenario positivo ‚ñ≤")
        ),
        sensData.map((s, i) => {
          const d = s[metric];
          const low = Math.min(d.up, d.down);
          const high = Math.max(d.up, d.down);
          const range = high - low;
          const pctWidth = maxRange > 0 ? (range / maxRange) * 100 : 0;
          const isInverted = d.down > d.up; // e.g. cost increase hurts
          
          return React.createElement("div", { key: i, style: { display: "flex", alignItems: "center", marginBottom: 8 } },
            React.createElement("span", { style: { width: 150, fontSize: 12, fontWeight: 500, color: "#374151", textAlign: "right", paddingRight: 10, flexShrink: 0 } },
              s.label, React.createElement("span", { style: { color: "#9ca3af", fontSize: 10 } }, ` ¬±${Math.round(s.pct * 100)}%`)
            ),
            React.createElement("div", { style: { flex: 1, height: 28, background: "#f3f4f6", borderRadius: 6, position: "relative", overflow: "hidden" } },
              // Base line
              React.createElement("div", { style: { position: "absolute", left: "50%", top: 0, bottom: 0, width: 2, background: "#374151", zIndex: 2 } }),
              // Negative side
              React.createElement("div", { style: {
                position: "absolute", right: "50%", top: 2, bottom: 2, borderRadius: 4,
                width: `${pctWidth / 2}%`, background: "#ef4444cc"
              } }),
              // Positive side
              React.createElement("div", { style: {
                position: "absolute", left: "50%", top: 2, bottom: 2, borderRadius: 4,
                width: `${pctWidth / 2}%`, background: "#22c55ecc"
              } })
            ),
            React.createElement("span", { style: { width: 90, fontSize: 10, fontFamily: "'JetBrains Mono',monospace", color: "#6b7280", paddingLeft: 8, flexShrink: 0 } },
              `Œî ‚Ç¨ ${fmt(Math.abs(range))}`)
          );
        })
      ),
      React.createElement(Note, null, "Il grafico mostra la variazione del ", metricLabels[metric], " al variare di ogni singolo parametro. I fattori in cima al tornado hanno il maggiore impatto e meritano l'analisi pi√π attenta nella preparazione del business plan.")
    )
  );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   MONTE CARLO PANEL
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function MonteCarloPanel({ company, revenues, hrs, opexItems, investments, assumptions }) {
  const [mcData, setMcData] = useState(null);
  const [running, setRunning] = useState(false);
  const [mcMetric, setMcMetric] = useState("netIncome");
  const [iterations, setIterations] = useState(500);
  
  const run = useCallback(() => {
    setRunning(true);
    setTimeout(() => {
      try {
        const result = runMonteCarlo(company, revenues, hrs, opexItems, investments, assumptions, iterations);
        setMcData(result);
      } catch(e) { console.error(e); }
      setRunning(false);
    }, 50);
  }, [company, revenues, hrs, opexItems, investments, assumptions, iterations]);
  
  const metricLabels = { revenue: "Ricavi", ebitda: "EBITDA", netIncome: "Utile Netto", cumCash: "Cassa Cumulata", dscr: "DSCR" };
  const d = mcData?.[mcMetric];
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: "La simulazione Monte Carlo genera centinaia di scenari casuali variando simultaneamente volumi, prezzi, margini e costi. Mostra la distribuzione probabilistica dei risultati per valutare il rischio reale del piano." }),
    React.createElement("div", { style: { display: "flex", gap: 12, alignItems: "center", flexWrap: "wrap" } },
      React.createElement(InputField, { label: "Iterazioni", value: iterations, onChange: v => setIterations(Math.max(100, Math.min(5000, v))), style: { maxWidth: 140 } }),
      React.createElement(Btn, { primary: true, onClick: run, disabled: running }, running ? "‚è≥ Calcolo..." : "üé≤ Avvia Simulazione"),
      mcData && React.createElement("span", { style: { fontSize: 12, color: "#059669", fontWeight: 600 } }, `‚úì ${mcData.iterations} simulazioni completate`)
    ),
    mcData && React.createElement(React.Fragment, null,
      React.createElement("div", { style: { display: "flex", gap: 8, marginTop: 8 } },
        Object.entries(metricLabels).map(([k, v]) =>
          React.createElement("button", {
            key: k, onClick: () => setMcMetric(k),
            style: { padding: "6px 14px", borderRadius: 8, border: mcMetric === k ? "2px solid #7c3aed" : "1px solid #d1d5db",
                     background: mcMetric === k ? "#f5f3ff" : "#fff", fontFamily: "'DM Sans',sans-serif", fontSize: 12, fontWeight: 600,
                     color: mcMetric === k ? "#7c3aed" : "#6b7280", cursor: "pointer" }
          }, v)
        )
      ),
      d && React.createElement(Card, { title: `üé≤ Distribuzione ${metricLabels[mcMetric]} (Anno ${company.yearsCount})` },
        // Histogram
        React.createElement(ChartCanvas, {
          type: "bar",
          height: 260,
          data: {
            labels: d.hist.map(b => fmt(b.x)),
            datasets: [{
              label: "Frequenza",
              data: d.hist.map(b => b.count),
              backgroundColor: d.hist.map(b => b.x >= 0 ? "#22c55eaa" : "#ef4444aa"),
              borderRadius: 3
            }]
          },
          options: {
            plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.parsed.y} simulazioni`, title: items => `‚Ç¨ ${items[0].label}` } } },
            scales: { x: { display: false }, y: { title: { display: true, text: "Frequenza" } } }
          }
        }),
        // Stats cards
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 10, marginTop: 16 } },
          [
            { label: "Media", value: d.mean, color: "#2563eb" },
            { label: "Mediana (P50)", value: d.p50, color: "#7c3aed" },
            { label: "P5 (worst 5%)", value: d.p5, color: "#dc2626" },
            { label: "P95 (best 5%)", value: d.p95, color: "#059669" }
          ].map(s => React.createElement("div", { key: s.label, style: { padding: 12, background: s.color + "08", borderRadius: 10, borderLeft: `3px solid ${s.color}` } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, s.label),
            React.createElement("div", { style: { fontSize: 16, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: s.color, marginTop: 4 } },
              mcMetric === "dscr" ? fmt(s.value, 2) + "√ó" : "‚Ç¨ " + fmt(s.value))
          ))
        ),
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 10, marginTop: 10 } },
          React.createElement("div", { style: { padding: 12, background: d.probPositive >= 0.7 ? "#ecfdf5" : d.probPositive >= 0.5 ? "#fffbeb" : "#fef2f2", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Prob. Positivo"),
            React.createElement("div", { style: { fontSize: 22, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: d.probPositive >= 0.7 ? "#059669" : d.probPositive >= 0.5 ? "#d97706" : "#dc2626" } },
              (d.probPositive * 100).toFixed(0) + "%")
          ),
          React.createElement("div", { style: { padding: 12, background: "#f3f4f6", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Dev. Standard"),
            React.createElement("div", { style: { fontSize: 16, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: "#374151", marginTop: 4 } },
              mcMetric === "dscr" ? fmt(d.std, 2) : "‚Ç¨ " + fmt(d.std))
          ),
          React.createElement("div", { style: { padding: 12, background: "#f3f4f6", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 10, color: "#6b7280", fontWeight: 600, textTransform: "uppercase" } }, "Range (P5-P95)"),
            React.createElement("div", { style: { fontSize: 14, fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: "#374151", marginTop: 4 } },
              mcMetric === "dscr" ? `${fmt(d.p5, 2)} ‚Äî ${fmt(d.p95, 2)}` : `‚Ç¨ ${fmt(d.p5)} ‚Äî ‚Ç¨ ${fmt(d.p95)}`)
          )
        ),
        React.createElement(Note, null,
          d.probPositive >= 0.8 ? `Con una probabilit√† dell'${(d.probPositive*100).toFixed(0)}% di risultato positivo, il piano mostra buona resilienza al rischio.` :
          d.probPositive >= 0.6 ? `La probabilit√† del ${(d.probPositive*100).toFixed(0)}% di risultato positivo √® discreta ma presenta rischi significativi. Considera margini di sicurezza pi√π ampi.` :
          `Solo il ${(d.probPositive*100).toFixed(0)}% delle simulazioni ha esito positivo. Il piano presenta un livello di rischio elevato.`,
          " Il range P5-P95 indica l'intervallo in cui cadr√† il risultato nel 90% dei casi."
        )
      )
    )
  );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   SCENARIO COMPARISON PANEL
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function ScenarioComparePanel({ company, revenues, hrs, opexItems, investments, assumptions, savedScenarios, onSaveScenario }) {
  const n = company.yearsCount;
  const last = n - 1;
  
  // Compute all 3 scenarios
  const scenarios = useMemo(() => {
    const mults = { base: 1, pessimistic: assumptions.scenarioMultiplier?.pessimistic || 0.85, optimistic: assumptions.scenarioMultiplier?.optimistic || 1.15 };
    return Object.entries(mults).map(([key, mult]) => {
      const scenComp = { ...company, scenario: key };
      const scenAssump = { ...assumptions, scenarioMultiplier: { ...assumptions.scenarioMultiplier, [key]: mult } };
      const f = computeFinancials(scenComp, revenues, hrs, opexItems, investments, scenAssump);
      return { key, label: key === "base" ? "üéØ Base" : key === "pessimistic" ? "‚ö†¬†Ô∏è Pessimistico" : "üöÄ Ottimistico", mult, financials: f };
    });
  }, [company, revenues, hrs, opexItems, investments, assumptions]);
  
  const metrics = [
    { label: "Ricavi", key: "totalRevenue" },
    { label: "EBITDA", key: "ebitda" },
    { label: "Utile Netto", key: "netIncome" },
    { label: "Cassa Cumulata", key: "cumCash" },
    { label: "DSCR", key: "dscr", dec: 2, suffix: "√ó" },
    { label: "Margine EBITDA %", key: "ebitdaMargin", pct: true },
    { label: "ROE", key: "roe", pct: true },
    { label: "PFN", key: "pfn" },
    { label: "Current Ratio", key: "currentRatio", dec: 2 },
    { label: "Break-Even (‚Ç¨)", key: "bep" }
  ];
  
  const colors = { base: "#2563eb", pessimistic: "#dc2626", optimistic: "#059669" };
  
  return React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
    React.createElement(Tip, { text: `Confronto side-by-side dei tre scenari: Pessimistico (‚àí${Math.round((1-assumptions.scenarioMultiplier?.pessimistic||0.85)*100)}% ricavi), Base, Ottimistico (+${Math.round((assumptions.scenarioMultiplier?.optimistic||1.15-1)*100)}% ricavi). Gli scenari modificano solo i volumi di vendita; costi e ipotesi restano invariati.` }),
    
    // Chart comparison
    React.createElement(Card, { title: "üìä¬† Confronto Scenari ‚Äî Ricavi e Utile Netto" },
      React.createElement(ChartCanvas, {
        type: "bar",
        height: 300,
        data: {
          labels: YL.slice(0, n),
          datasets: scenarios.flatMap(s => [
            { label: `Ricavi ${s.label}`, data: s.financials.totalRevenue.slice(0, n), backgroundColor: colors[s.key] + "66", borderColor: colors[s.key], borderWidth: 1 },
          ])
        },
        options: { plugins: { tooltip: { callbacks: { label: ctx => ctx.dataset.label + ": ‚Ç¨ " + fmt(ctx.parsed.y) } } } }
      })
    ),
    
    // KPI comparison table
    React.createElement(Card, { title: "üìã Tabella Comparativa (Anno " + n + ")", accent: true },
      React.createElement("div", { style: { overflowX: "auto" } },
        React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13, fontFamily: "'DM Sans',sans-serif" } },
          React.createElement("thead", null,
            React.createElement("tr", null,
              React.createElement("th", { style: { textAlign: "left", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, textTransform: "uppercase", color: "#6b7280" } }, "KPI"),
              scenarios.map(s => React.createElement("th", { key: s.key, style: { textAlign: "right", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, textTransform: "uppercase", color: colors[s.key], fontWeight: 700 } }, s.label))
            )
          ),
          React.createElement("tbody", null,
            metrics.map((m, i) => React.createElement("tr", { key: m.key, style: { background: i % 2 === 0 ? "#f9fafb" : "transparent" } },
              React.createElement("td", { style: { padding: "8px 12px", fontWeight: 500, color: "#374151" } }, m.label),
              scenarios.map(s => {
                const v = s.financials[m.key]?.[last];
                return React.createElement("td", { key: s.key, style: { padding: "8px 12px", textAlign: "right", fontFamily: "'JetBrains Mono',monospace", fontWeight: 600, color: v < 0 ? "#dc2626" : "#374151" } },
                  m.pct ? fmtPct(v) : m.dec ? fmt(v, m.dec) + (m.suffix || "") : "‚Ç¨ " + fmt(v));
              })
            ))
          )
        )
      )
    ),
    
    // Saved scenarios
    savedScenarios.length > 0 && React.createElement(Card, { title: "üìÇ Scenari Salvati" },
      React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 8 } },
        savedScenarios.map((s, i) => React.createElement("div", { key: i, style: { padding: "10px 14px", background: "#f9fafb", borderRadius: 8, display: "flex", justifyContent: "space-between", alignItems: "center" } },
          React.createElement("div", null,
            React.createElement("strong", null, s.name), " ‚Äî ",
            React.createElement("span", { style: { fontSize: 12, color: "#6b7280" } }, `Ricavi: ‚Ç¨ ${fmt(s.revenue)} | EBITDA: ‚Ç¨ ${fmt(s.ebitda)} | Utile: ‚Ç¨ ${fmt(s.netIncome)}`)
          ),
          React.createElement("span", { style: { fontSize: 11, color: "#9ca3af" } }, s.date)
        ))
      )
    ),
    
    React.createElement(Btn, { primary: true, onClick: () => {
      const name = prompt("Nome scenario:", company.name + " - " + new Date().toLocaleDateString("it-IT"));
      if (name) onSaveScenario({
        name,
        date: new Date().toLocaleDateString("it-IT"),
        revenue: scenarios[0].financials.totalRevenue[last],
        ebitda: scenarios[0].financials.ebitda[last],
        netIncome: scenarios[0].financials.netIncome[last]
      });
    } }, "üíæ Salva Scenario Corrente")
  );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   BILANCIO IMPORT PANEL (for Step 0)
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function ImportBilancioPanel({ setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company }) {
  const [status, setStatus] = useState(null);
  const [parsedData, setParsedData] = useState(null);
  const [errorMsg, setErrorMsg] = useState(null);
  const inputRef = useRef(null);
  
  const handleFile = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    setStatus("loading");
    setErrorMsg(null);
    try {
      const data = await parseBilancioFile(file);
      setParsedData(data);
      setStatus("parsed");
    } catch(err) {
      setStatus("error");
      setErrorMsg(err.message);
    }
    e.target.value = "";
  };
  
  const applyData = () => {
    if (!parsedData) return;
    applyBilancioData(parsedData, setCompany, setRevenues, setHrs, setOpexItems, setInvestments, setAssumptions, company);
    setStatus("applied");
  };
  
  // Organize parsed data for display
  const displaySections = parsedData ? [
    { title: "üìä¬† Conto Economico", items: [
      ["Ricavi vendite", parsedData.ricavi],
      ["Valore produzione", parsedData.valoreProduzione],
      ["Materie prime", parsedData.materiePrime],
      ["Costi servizi", parsedData.costiServizi],
      ["Godimento beni", parsedData.godimentoBeni],
      ["Personale", parsedData.personale],
      ["Ammortamenti", parsedData.ammortamenti],
      ["Oneri diversi", parsedData.oneriDiversi],
      ["EBITDA (calc.)", parsedData.ebitda],
      ["Margine operativo", parsedData.margineOperativo],
      ["Interessi passivi", parsedData.interessiPassivi],
      ["Imposte", parsedData.imposte],
      ["Utile netto", parsedData.utileNetto],
    ].filter(([_, v]) => v) },
    { title: "üèõÔ∏è Stato Patrimoniale", items: [
      ["Capitale sociale", parsedData.capitaleSociale],
      ["Patrimonio netto", parsedData.patrimonioNetto],
      ["Immobilizzazioni immat.", parsedData.immobilizzazioniImmateriali],
      ["Immobilizzazioni mat.", parsedData.immobilizzazioniMateriali],
      ["Cassa", parsedData.cassa],
      ["Crediti commerciali", parsedData.creditiCommerciali || parsedData.creditiTotali],
      ["Rimanenze", parsedData.rimanenze],
      ["Debiti vs banche", parsedData.debitiFinanziari],
      ["Debiti vs fornitori", parsedData.debitiCommerciali],
      ["Debiti totali", parsedData.debitiTotali],
      ["TFR", parsedData.tfr],
    ].filter(([_, v]) => v) },
    { title: "üë• Organico", items: [
      ["Dipendenti", parsedData.dipendenti],
      ["Costo medio", parsedData.personale && parsedData.dipendenti ? Math.round(parsedData.personale / parsedData.dipendenti) : null],
    ].filter(([_, v]) => v) }
  ].filter(s => s.items.length > 0) : [];
  
  return React.createElement(Card, { title: "üì• Importa Bilancio Esistente (PDF o Excel)" },
    React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 12 } },
      React.createElement("p", { style: { fontSize: 13, color: "#4b5563", lineHeight: 1.6 } },
        "Carica un bilancio in formato ", React.createElement("strong", null, "PDF"), " o ", React.createElement("strong", null, "Excel"),
        " (.pdf, .xlsx, .xls, .csv) per pre-compilare automaticamente il piano economico. Il parser riconosce le voci standard del bilancio CEE italiano (abbreviato e ordinario)."),
      React.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } },
        React.createElement("input", { ref: inputRef, type: "file", accept: ".pdf,.xlsx,.xls,.csv,.xbrl,.xml", onChange: handleFile, style: { display: "none" } }),
        React.createElement(Btn, { primary: true, onClick: () => inputRef.current.click() }, "üìÇ Carica Bilancio (PDF/Excel)"),
        status === "loading" && React.createElement("span", { className: "pulse", style: { fontSize: 12, color: "#6b7280" } }, "‚è≥ Analisi del documento in corso..."),
        status === "applied" && React.createElement("span", { style: { fontSize: 12, color: "#059669", fontWeight: 600 } }, "‚úÖ Dati importati con successo!"),
        status === "error" && React.createElement("span", { style: { fontSize: 12, color: "#dc2626", fontWeight: 600 } }, "‚ùå ", errorMsg)
      ),
      
      // Parsed data display
      parsedData && status === "parsed" && React.createElement("div", { style: { padding: 16, background: "#f9fafb", borderRadius: 12, border: "1px solid #e5e7eb" } },
        React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 } },
          React.createElement("div", { style: { fontSize: 14, fontWeight: 700, color: "#1e3a5f" } }, "üìã Dati estratti dal bilancio"),
          React.createElement("span", { style: { fontSize: 10, color: "#9ca3af", background: "#f3f4f6", padding: "2px 8px", borderRadius: 4 } },
            `Fonte: ${parsedData._source === "pdf" ? "PDF" : "Excel"} | ${parsedData._allLines || "?"} voci analizzate`)
        ),
        displaySections.map((section, si) => React.createElement("div", { key: si, style: { marginBottom: 12 } },
          React.createElement("div", { style: { fontSize: 11, fontWeight: 700, color: "#6b7280", textTransform: "uppercase", letterSpacing: ".03em", marginBottom: 6 } }, section.title),
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))", gap: 6 } },
            section.items.map(([k, v], i) => React.createElement("div", { key: i, style: { padding: "6px 10px", background: "#fff", borderRadius: 6, border: "1px solid #e5e7eb" } },
              React.createElement("span", { style: { fontSize: 10, color: "#6b7280", display: "block" } }, k),
              React.createElement("span", { style: { fontSize: 13, fontFamily: "'JetBrains Mono',monospace", fontWeight: 600, color: v < 0 ? "#dc2626" : "#111827" } },
                typeof v === "number" && k !== "Dipendenti" ? fmtEur(v) : v)
            ))
          )
        )),
        // Computed KPI preview
        parsedData.ricavi && parsedData.margineOperativo && React.createElement("div", { style: { marginTop: 8, padding: "8px 12px", background: "#eff6ff", borderRadius: 8 } },
          React.createElement("span", { style: { fontSize: 11, fontWeight: 600, color: "#1e3a5f" } }, "KPI calcolati: "),
          React.createElement("span", { style: { fontSize: 11, color: "#374151", fontFamily: "'JetBrains Mono',monospace" } },
            `Margine op. ${parsedData.ricavi ? ((parsedData.margineOperativo / parsedData.ricavi) * 100).toFixed(1) : "?"}%`,
            parsedData.ebitda || (parsedData.margineOperativo && parsedData.ammortamenti) ? ` | EBITDA ${fmtEur((parsedData.ebitda || parsedData.margineOperativo + parsedData.ammortamenti))} (${(((parsedData.ebitda || parsedData.margineOperativo + parsedData.ammortamenti) / parsedData.ricavi) * 100).toFixed(1)}%)` : "",
            parsedData.utileNetto ? ` | Utile netto ${fmtEur(parsedData.utileNetto)} (${((parsedData.utileNetto / parsedData.ricavi) * 100).toFixed(1)}%)` : "",
            parsedData.patrimonioNetto && parsedData.utileNetto ? ` | ROE ${((parsedData.utileNetto / parsedData.patrimonioNetto) * 100).toFixed(1)}%` : ""
          ),
          // Show derived gross margin explanation
          React.createElement("div", { style: { fontSize: 10, color: "#6b7280", marginTop: 4 } },
            (() => {
              const realEBITDA = parsedData.ebitda || (parsedData.margineOperativo && parsedData.ammortamenti ? parsedData.margineOperativo + parsedData.ammortamenti : 0);
              const overhead = (parsedData.godimentoBeni || 0) + (parsedData.oneriDiversi || 0);
              const hr = parsedData.personale || 0;
              if (realEBITDA && parsedData.ricavi) {
                const gm = ((realEBITDA + hr + overhead) / parsedData.ricavi * 100).toFixed(1);
                return `üí° Margine lordo derivato: ${gm}% (calcolato da EBITDA reale ${fmtEur(realEBITDA)} + personale ${fmtEur(hr)} + overhead ${fmtEur(overhead)} / ricavi). I costi per servizi (B.7) sono assorbiti nel margine lordo.`;
              }
              return "";
            })()
          )
        ),
        React.createElement("div", { style: { marginTop: 12, display: "flex", gap: 8 } },
          React.createElement(Btn, { primary: true, onClick: applyData }, "‚úÖ Applica al Piano Economico"),
          React.createElement(Btn, { onClick: () => { setParsedData(null); setStatus(null); } }, "‚ùå Annulla")
        )
      ),
      
      React.createElement(Note, null,
        "Formati supportati: ", React.createElement("strong", null, "PDF"), " (bilancio depositato, XBRL convertito), ",
        React.createElement("strong", null, "Excel"), " (esportazioni da TeamSystem, Zucchetti, Buffetti, altri gestionali). ",
        "Il parser cerca automaticamente le voci CEE: ricavi (A.1), costi per servizi (B.7), personale (B.9), ammortamenti (B.10), ",
        "patrimonio netto, debiti finanziari, crediti, disponibilit√† liquide, ecc. Per PDF, viene estratto il testo e analizzato con pattern matching. ",
        "Verifica sempre i dati estratti prima di applicarli al piano."
      )
    )
  );
}
/* === V4.2: EXECUTIVE SUMMARY & NOTA INTEGRATIVA === */
function generateExecutiveSummary(company, f, n, revenues, investments, hrs) {
  var last = n - 1;
  var rev0 = f.totalRevenue[0];
  var revN = f.totalRevenue[last];
  var cagr = (f.revenueCAGR * 100).toFixed(1);
  var ebitdaM = (f.ebitdaMargin[last] * 100).toFixed(1);
  var ebitdaV = fmtEur(f.ebitda[last]);
  var profitYear = f.netIncome.findIndex(function(v) { return v > 0; });
  var dscrLast = f.dscr[last] !== null ? f.dscr[last].toFixed(2) : "N/A";
  var headLast = f.headcount[last];
  var totalInv = investments.reduce(function(s, inv) { return s + inv.cost; }, 0);
  var bepLast = f.bep[last] ? fmtEur(f.bep[last]) : "N/A";
  var bepM = f.bepMargin[last] !== null ? (f.bepMargin[last] * 100).toFixed(0) + "%" : "N/A";
  var text = "";
  text += (company.name || "L'azienda") + " opera nel settore " + (company.sector || "non specificato") + ". ";
  text += "Il piano previsionale copre " + n + " anni (" + YL[0] + " - " + YL[last] + "). ";
  text += "I ricavi passano da " + fmtEur(rev0) + " a " + fmtEur(revN) + " con un CAGR del " + cagr + "%. ";
  text += "L'EBITDA margin a regime raggiunge il " + ebitdaM + "% (" + ebitdaV + "). ";
  if (profitYear >= 0) { text += "L'utile netto diventa positivo dall'anno " + (profitYear + 1) + " (" + YL[profitYear] + "). "; }
  else { text += "Il piano non raggiunge il break-even nel periodo. "; }
  if (parseFloat(dscrLast) >= 1.2) { text += "DSCR a regime: " + dscrLast + "x (adeguato). "; }
  else { text += "DSCR a regime: " + dscrLast + "x (sotto soglia 1,2x). "; }
  text += "Organico: " + headLast + " risorse. Investimenti: " + fmtEur(totalInv) + ". ";
  text += "Break-Even: " + bepLast + " (margine sicurezza " + bepM + ").";
  // Warnings
  var warns = [];
  if (f.art2447 && f.art2447.some(function(v) { return v; })) warns.push("PN negativo (art. 2447 CC)");
  if (f.netIncome.every(function(v) { return v < 0; })) warns.push("Piano sempre in perdita");
  if (f.dscr.some(function(v) { return v !== null && v < 1.0; })) warns.push("DSCR sotto 1.0x");
  if (f.fundingGap.some(function(v) { return v > 0; })) warns.push("Fabbisogno finanziario scoperto");
  if (warns.length > 0) text += " CRITICITA: " + warns.join("; ") + ".";
  return text;
}

function generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions) {
  var sections = [];
  sections.push({ title: "1. Criteri di redazione",
    text: "Piano redatto secondo principi contabili OIC (v5.0). IRES " + (assumptions.iresRate * 100).toFixed(1) + "% (con riporto perdite fiscali art. 84 TUIR). IRAP " + ((f.irapAliquota || 0.039) * 100).toFixed(2) + "% su base Valore Produzione al netto dei soli costi deducibili IRAP, con deduzione cuneo fiscale per " + (f.headcountTI ? f.headcountTI[n-1] : 0) + " dipendenti a tempo indeterminato. Proiezioni: " + n + " anni (" + YL[0] + " - " + YL[n - 1] + ")."
  });
  var revLines = revenues.map(function(r) { return r.name + " (" + r.type + ", " + fmtEur(r.unitPrice) + ", mg. " + (r.grossMargin * 100).toFixed(0) + "%)"; }).join("; ");
  sections.push({ title: "2. Ipotesi sui ricavi",
    text: "Linee di ricavo: " + revLines + ". Volumi stimati su analisi di mercato" + (company.sector ? " (" + company.sector + ")" : "") + "."
  });
  var hrRoles = hrs.map(function(h) { return h.role + " (" + h.type + ", " + fmtEur(h.annualCost) + "/anno)"; }).join("; ");
  sections.push({ title: "3. Struttura dei costi",
    text: "Personale: " + hrRoles + ". TFR calcolato da RAL (quota annua = RAL/13,5 x 0,995 + rivalutazione fondo). Contratti: " + hrs.filter(function(h){return h.contractType==="indeterminato"||!h.contractType;}).length + " a tempo indeterminato, " + hrs.filter(function(h){return h.contractType==="apprendista";}).length + " apprendisti. OpEx: " + opexItems.length + " voci."
  });
  var invList = investments.map(function(inv) { return inv.name + " (" + fmtEur(inv.cost) + ", " + inv.usefulLife + " anni)"; }).join("; ");
  sections.push({ title: "4. Investimenti e ammortamenti",
    text: (function() {
      var t = "Investimenti: " + invList + ". Ammortamento SLN. Totale: " + fmtEur(investments.reduce(function(s, i) { return s + i.cost; }, 0)) + ".";
      var i40 = investments.filter(function(i) { return i.industry40; });
      if (i40.length > 0) t += " Di cui " + i40.length + " beni Industria 4.0/Transizione 5.0 (" + i40.map(function(i) { return i.name; }).join(", ") + ") potenzialmente agevolabili.";
      var nonDeduct = investments.filter(function(i) { return i.vatDeductible === false; });
      if (nonDeduct.length > 0) t += " IVA indetraibile su: " + nonDeduct.map(function(i) { return i.name; }).join(", ") + ".";
      return t;
    })()
  });
  sections.push({ title: "5. Struttura finanziaria",
    text: "DSO " + assumptions.dso + "gg, DPO " + assumptions.dpo + "gg, DIO " + assumptions.dio + "gg (CCC: " + f.ccc + "gg). Tasso: " + (assumptions.interestRate * 100).toFixed(2) + "%. " + (assumptions.debtType === "francese" ? "Ammortamento francese " + (assumptions.debtDuration || 5) + " anni. " : "") + (assumptions.grantAmount > 0 ? "Contributo: " + fmtEur(assumptions.grantAmount) + " su " + assumptions.grantYears + " anni." : "")
  });
  var warnings = [];
  if (f.art2447 && f.art2447.some(function(v) { return v; })) warnings.push("Rischio art. 2447 CC");
  if (f.dscr.some(function(v) { return v !== null && v < 1.2; })) warnings.push("DSCR sotto 1,2x");
  if (f.fundingGap.some(function(v) { return v > 0; })) warnings.push("Gap di cassa");
  sections.push({ title: "6. Analisi dei rischi",
    text: warnings.length > 0 ? "Criticita: " + warnings.join("; ") + "." : "Non si rilevano criticita significative."
  });
  return sections;
}

function StepResults({
  financials: f,
  company,
  assumptions,
  revenues,
  hrs,
  opexItems,
  investments,
  savedScenarios,
  onSaveScenario,
  lang
}) {
  const n = company.yearsCount;
  const isEN = lang === "en";
  const [tab, setTab] = useState("summary");
  const tabs = [{
    id: "summary",
    label: isEN ? "\uD83D\uDCDD Summary" : "\uD83D\uDCDD Sintesi"
  }, {
    id: "dashboard",
    label: isEN ? "üìä¬† Dashboard" : "üìä¬† Dashboard"
  }, {
    id: "benchmark",
    label: isEN ? "\uD83C\uDFAF Benchmark" : "\uD83C\uDFAF Benchmark"
  }, {
        id: "charts",
    label: isEN ? "üìà Charts" : "üìà Grafici"
  }, {
    id: "is",
    label: isEN ? "Income Statement" : "Conto Economico"
  }, {
    id: "bs",
    label: isEN ? "Balance Sheet" : "Stato Patrimoniale"
  }, {
    id: "cf",
    label: isEN ? "Cash Flow" : "Cash Flow"
  }, {
    id: "civil",
    label: isEN ? "\uD83C\uDFDB\uFE0F Civil Code" : "\uD83C\uDFDB\uFE0F Bilancio Civilistico"
  }, {
    id: "kpi",
    label: isEN ? "Advanced KPIs" : "KPI Avanzati"
  }, {
    id: "sensitivity",
    label: isEN ? "üî¨ Sensitivity" : "üî¨ Sensitivit√†"
  }, {
    id: "montecarlo",
    label: "üé≤ Monte Carlo"
  }, {
    id: "scenarios",
    label: isEN ? "üîÄ Scenarios" : "üîÄ Scenari"
  }, {
    id: "nota",
    label: isEN ? "\uD83D\uDCCB Notes" : "\uD83D\uDCCB Nota Integrativa"
  }, {
    id: "multiScenario",
    label: isEN ? "\u2696\uFE0F Compare" : "\u2696\uFE0F Confronto"
  }];
  const Div = () => /*#__PURE__*/React.createElement("div", {
    style: {
      height: 1,
      background: "#e5e7eb",
      margin: "4px 0"
    }
  });
  const hasFundingGap = f.fundingGap.slice(0, n).some(v => v > 0);
  const last = n - 1;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 20
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 4,
      background: "#f3f4f6",
      padding: 4,
      borderRadius: 12,
      flexWrap: "wrap",
      overflowX: "auto"
    }
  }, tabs.map(t => /*#__PURE__*/React.createElement("button", {
    key: t.id,
    onClick: () => setTab(t.id),
    style: {
      flex: 1,
      padding: "10px 12px",
      border: "none",
      borderRadius: 8,
      background: tab === t.id ? "#fff" : "transparent",
      minWidth: 90,
      color: tab === t.id ? "#111827" : "#6b7280",
      fontFamily: "'DM Sans',sans-serif",
      fontWeight: 600,
      fontSize: 12,
      cursor: "pointer",
      boxShadow: tab === t.id ? "0 1px 3px rgba(0,0,0,.08)" : "none",
      transition: "all .2s"
    }
  }, t.label))), tab === "dashboard" && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/
  // V3: Delta Anno 0 -> Previsionale warnings
  f.delta0to1 && React.createElement(Card, { title: "\u26A0\uFE0F Ponte Storico \u2192 Previsionale" },
    React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 6 } },
      [["Ricavi", f.delta0to1.ricavi], ["EBITDA", f.delta0to1.ebitda], ["Utile", f.delta0to1.utile], ["Personale", f.delta0to1.personale]]
        .filter(([_, d]) => d !== null && Math.abs(d) > 0.30)
        .map(([label, delta], i) =>
          React.createElement("div", { key: i, style: { padding: "8px 12px", background: Math.abs(delta) > 0.50 ? "#fee2e2" : "#fef3c7", borderRadius: 8, border: "1px solid " + (Math.abs(delta) > 0.50 ? "#fca5a5" : "#fcd34d"), fontSize: 12 } },
            "\u26A0\uFE0F " + label + ": " + (delta > 0 ? "+" : "") + (delta * 100).toFixed(0) + "% da consuntivo a previsionale. " + (Math.abs(delta) > 0.50 ? "Giustificare nella Nota Metodologica." : "Verificare coerenza.")
          )
        )
    ),
    React.createElement(Note, null, "Variazioni superiori al \u00B130% tra consuntivo e previsionale richiedono giustificazioni per la banca.")
  ),
React.createElement(Card, {
    title: "\uD83C\uDFE5 Health Check \u2014 Diagnosi del Piano",
    accent: true
  }, /*#__PURE__*/React.createElement(HealthCheck, {
    financials: f,
    n: n
  })), /*#__PURE__*/React.createElement(Card, {
    title: "Cruscotto Finanziario \u2014 Ultimo Anno"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: "DSCR",
    value: f.dscr[last],
    format: "dec2",
    thresholds: {
      green: 1.3,
      yellow: 1
    },
    note: "Debt Service Coverage. La banca vuole \u2265 1,2\xD7"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine EBITDA",
    value: f.ebitdaMargin[last],
    format: "pct",
    thresholds: {
      green: 0.15,
      yellow: 0.05
    },
    note: "Sostenibilit\xE0 operativa. Ideale >15%"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine netto",
    value: f.netMargin[last],
    format: "pct",
    thresholds: {
      green: 0.05,
      yellow: 0
    },
    note: "Redditivit\xE0 finale. Positivo = crea valore"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Current Ratio",
    value: f.currentRatio[last],
    format: "dec2",
    thresholds: {
      green: 1.5,
      yellow: 1
    },
    note: "Liquidit\xE0 a breve. <1 = rischio insolvenza"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Debt/Equity",
    value: f.debtEquity[last],
    format: "dec2",
    thresholds: {
      green: 1,
      yellow: 2
    },
    invert: true,
    note: "Leva finanziaria. <1\xD7 = conservativo"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "ROE",
    value: f.roe[last],
    format: "pct",
    thresholds: {
      green: 0.08,
      yellow: 0
    },
    note: "Rendimento del capitale proprio"
  }))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "Break-Even Analysis"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: `BEP Anno ${n}`,
    value: f.bep[last],
    format: "eur",
    thresholds: null,
    note: "Fatturato minimo per coprire tutti i costi fissi"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Margine di sicurezza",
    value: f.bepMargin[last],
    format: "pct",
    thresholds: {
      green: 0.2,
      yellow: 0.05
    },
    note: "Quanto i ricavi superano il BEP. >20% = buono"
  })), /*#__PURE__*/React.createElement(Note, null, "Il Break-Even Point (BEP) indica il fatturato necessario per raggiungere l'utile zero. Si calcola come: Costi Fissi \xF7 Margine Lordo %. Un margine di sicurezza ", ">", " 20% significa che i ricavi possono calare del 20% prima di andare in perdita.")), /*#__PURE__*/React.createElement(Card, {
    title: "Posizione Finanziaria e Liquidit\xE0"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: 12
    }
  }, /*#__PURE__*/React.createElement(Gauge, {
    label: `PFN Anno ${n}`,
    value: f.pfn[last],
    format: "eur",
    thresholds: {
      green: 0,
      yellow: -50000
    },
    note: "Posiz. Fin. Netta. Negativa = indebitamento netto"
  }), /*#__PURE__*/React.createElement(Gauge, {
    label: "Ciclo di Cassa",
    value: f.ccc,
    format: "days",
    thresholds: {
      green: 30,
      yellow: 60
    },
    invert: true,
    note: `DSO(${company.yearsCount > 0 ? Math.round(f.ccc + 60 - 30) + "" : ""}) + DIO - DPO`
  })), /*#__PURE__*/React.createElement(Note, null, "La PFN (Posizione Finanziaria Netta) \xE8 la differenza tra liquidit\xE0 e debiti finanziari. \xC8 il primo indicatore che la banca guarda. Se negativa, l'azienda \xE8 esposta; se positiva, ha riserve. Il Ciclo di Cassa (CCC) indica quanti giorni passano tra il pagamento dei fornitori e l'incasso dai clienti."))), f.burnRate.slice(0, n).some(v => v > 0) && /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDD25 Burn Rate e Runway"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: `repeat(${n},1fr)`,
      gap: 12
    }
  }, YEARS.slice(0, n).map((_, i) => /*#__PURE__*/React.createElement("div", {
    key: i,
    style: {
      textAlign: "center"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 11,
      fontWeight: 600,
      color: "#6b7280",
      textTransform: "uppercase",
      marginBottom: 4
    }
  }, YL[i]), f.burnRate[i] > 0 ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 18,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: "#dc2626"
    }
  }, fmtEur(f.burnRate[i]), "/mese"), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 12,
      color: f.runway[i] < 6 ? "#dc2626" : f.runway[i] < 12 ? "#d97706" : "#059669",
      fontWeight: 600,
      marginTop: 4
    }
  }, f.runway[i] != null ? Math.round(f.runway[i]) + " mesi di runway" : "‚Äî")) : /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 14,
      color: "#059669",
      fontWeight: 600
    }
  }, "CF Operativo positivo \u2713")))), /*#__PURE__*/React.createElement(Note, null, "Il burn rate indica quanta cassa viene consumata mensilmente quando il CF operativo \xE8 negativo. Il runway \xE8 il numero di mesi prima che la cassa si esaurisca. Sotto 6 mesi \xE8 critico: serve un'azione immediata (taglio costi, finanziamento, o accelerazione ricavi).")), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "CAGR Ricavi"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.revenueCAGR >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtPct(f.revenueCAGR))), /*#__PURE__*/React.createElement(Card, {
    title: `Utile Netto Y${n}`
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.netIncome[last] >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtEur(f.netIncome[last]))), /*#__PURE__*/React.createElement(Card, {
    title: `Cassa Y${n}`
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.cash[last] >= 0 ? "#059669" : "#dc2626",
      padding: 4
    }
  }, fmtEur(Math.max(0, f.cash[last])))), /*#__PURE__*/React.createElement(Card, {
    title: "Payback Period"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 24,
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: f.paybackPeriod != null ? "#059669" : "#dc2626",
      padding: 4
    }
  }, f.paybackPeriod != null ? `Anno ${f.paybackPeriod + 1}` : "Non raggiunto"))), /*#__PURE__*/React.createElement(Card, {
    title: "\uD83D\uDCDD Executive Summary"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 13,
      color: "#374151",
      lineHeight: 1.8
    }
  }, /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "Il piano prevede ", /*#__PURE__*/React.createElement("strong", null, "ricavi di \u20AC ", fmt(f.totalRevenue[last])), " all'Anno ", n, f.revenueCAGR > 0 ? `, con un CAGR del ${fmtPct(f.revenueCAGR)}` : "", ".", f.ebitdaMargin[last] >= 0.1 ? ` L'EBITDA margin del ${fmtPct(f.ebitdaMargin[last])} indica una buona efficienza operativa.` : f.ebitdaMargin[last] >= 0 ? ` L'EBITDA margin del ${fmtPct(f.ebitdaMargin[last])} √® contenuto ma positivo.` : ` L'EBITDA √® negativo: il business non copre i costi operativi.`), /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, f.netIncome[last] >= 0 ? `L'utile netto di ‚Ç¨ ${fmt(f.netIncome[last])} ` : `La perdita netta di ‚Ç¨ ${fmt(Math.abs(f.netIncome[last]))} `, f.netMargin[last] >= 0.05 ? "rappresenta un margine netto sano. " : f.netMargin[last] >= 0 ? "√® positivo ma marginale. " : "richiede interventi strutturali. ", f.equity[last] > 0 ? `Il patrimonio netto di ‚Ç¨ ${fmt(f.equity[last])} garantisce solidit√† patrimoniale.` : `Il patrimonio netto negativo (‚Ç¨ ${fmt(f.equity[last])}) richiede ricapitalizzazione urgente.`), /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, f.dscr[last] != null ? `Il DSCR di ${fmt(f.dscr[last], 2)}√ó ${f.dscr[last] >= 1.2 ? "supera la soglia bancaria di 1,2√ó, rendendo il piano finanziabile." : "√® sotto la soglia bancaria di 1,2√ó, rendendo problematico l'accesso al credito."} ` : "", f.pfn[last] >= 0 ? `La Posizione Finanziaria Netta positiva (‚Ç¨ ${fmt(f.pfn[last])}) indica autosufficienza finanziaria.` : `La PFN negativa (‚Ç¨ ${fmt(f.pfn[last])}) evidenzia dipendenza dal credito bancario.`), f.paybackPeriod != null && /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "L'investimento si ripaga nell'", /*#__PURE__*/React.createElement("strong", null, "Anno ", f.paybackPeriod + 1), ", ", f.paybackPeriod <= 1 ? "un tempo eccellente che rassicura gli investitori." : "un orizzonte coerente con la tipologia di investimento."), f.taxCreditUsed.some(v => v > 0) && /*#__PURE__*/React.createElement("p", {
    style: {
      marginBottom: 10
    }
  }, "Il credito d'imposta porta un risparmio fiscale complessivo di ", /*#__PURE__*/React.createElement("strong", null, "\u20AC ", fmt(f.taxCreditUsed.slice(0, n).reduce((s, v) => s + v, 0))), ", migliorando la redditivit\xE0 netta."), f.bepMargin[last] != null && f.bepMargin[last] > 0 && /*#__PURE__*/React.createElement("p", null, "Il margine di sicurezza del ", fmtPct(f.bepMargin[last]), " rispetto al break-even conferma la resilienza del modello a shock di domanda.")))), tab === "is" && /*#__PURE__*/React.createElement(Card, {
    title: "Conto Economico Previsionale",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Ricavi totali",
    values: f.totalRevenue,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costo del venduto",
    values: f.totalCOGS.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "MARGINE LORDO",
    values: f.grossProfit,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine lordo %",
    values: f.grossMarginPct,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costo personale",
    values: f.hrCosts.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Costi operativi",
    values: f.opexCosts.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Contributi",
    values: f.grantIncome,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "EBITDA",
    values: f.ebitda,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine EBITDA %",
    values: f.ebitdaMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Ammortamenti",
    values: f.depreciation.map(v => -v),
    n: n
  }), f.svalutazioneCrediti.some(v => v > 0) && /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Sval. crediti (B10d)",
    values: f.svalutazioneCrediti.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "EBIT",
    values: f.ebit,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Interessi passivi",
    values: f.interest.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Utile ante imposte (EBT)",
    values: f.ebt,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 IRES",
    values: f.ires.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 IRAP",
    values: f.irap.map(v => -v),
    n: n
  }), f.taxCreditUsed.some(v => v > 0) && /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Credito d'imposta",
    values: f.taxCreditUsed,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "UTILE NETTO",
    values: f.netIncome,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  Margine netto %",
    values: f.netMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il Conto Economico mostra se l'attivit\xE0 \xE8 redditizia. L'EBITDA misura la capacit\xE0 di generare cassa dalla gestione operativa. Se l'EBITDA \xE8 negativo, il modello di business ha un problema strutturale indipendentemente dal finanziamento.")), tab === "bs" && /*#__PURE__*/React.createElement(Card, {
    title: "Stato Patrimoniale Previsionale",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase",
      letterSpacing: ".05em"
    }
  }, "ATTIVO"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cassa e disponibilit\xE0",
    values: f.cash.map(v => Math.max(0, v)),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crediti commerciali",
    values: f.ar,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  (Fondo sval. crediti)",
    values: f.fondoSvalCrediti.map(function(v){return -v;}),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Rimanenze",
    values: f.inventory,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Immobilizzazioni nette",
    values: f.netFA,
    n: n
  }), hasFundingGap && /*#__PURE__*/React.createElement(YearRow, {
    label: "  Fabbisogno (scoperto)",
    values: f.fundingGap,
    n: n
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "TOTALE ATTIVO",
    values: f.totalLiabEq.map(v => Math.abs(v)),
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 12
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase",
      letterSpacing: ".05em"
    }
  }, "PASSIVO E PATRIMONIO NETTO"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debiti commerciali",
    values: f.ap,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debiti tributari",
    values: f.totalTax,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debiti previdenziali (D13)",
    values: f.debitiPrevidenziali,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Risconti passivi (contributi)",
    values: f.deferredGrant,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debito finanziario",
    values: f.netDebt,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Fondo TFR",
    values: f.cumTFR,
    n: n
  }), f.revolvingCredit.some(function(v){return v > 0;}) && /*#__PURE__*/React.createElement(YearRow, {
    label: "\u26A0\uFE0F Fido di cassa (revolving)",
    values: f.revolvingCredit,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Patrimonio netto",
    values: f.equity,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "TOTALE PASSIVO E PN",
    values: f.totalLiabEqAdj,
    n: n,
    bold: true,
    highlight: true
  }), hasFundingGap && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "\u26A0\uFE0F Fabbisogno finanziario",
    values: f.fundingGap,
    n: n,
    bold: true
  })), /*#__PURE__*/React.createElement(Note, null, "Lo Stato Patrimoniale fotografa la struttura finanziaria dell'azienda. La banca controlla: (1) che il PN sia positivo, (2) che il rapporto Debito/Equity sia ", "<", " 3\xD7, (3) che il current ratio sia ", ">", " 1. Un PN negativo \xE8 causa legale di scioglimento.")), tab === "cf" && /*#__PURE__*/React.createElement(Card, {
    title: "Rendiconto Finanziario (OIC 10)",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 operativa"), /*#__PURE__*/React.createElement(YearRow, {
    label: "Utile netto",
    values: f.netIncome,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Ammortamenti",
    values: f.depreciation,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + TFR accantonato (non-cash)",
    values: f.tfrAccrual,
    n: n
  }), f.svalutazioneCrediti.some(v => v > 0) && /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Sval. crediti (non-cash)",
    values: f.svalutazioneCrediti,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \xB1 \u0394 Capitale circolante",
    values: YEARS.map((_, i) => {
      const wcTrade = i === 0 ? -(f.ar[0] + f.inventory[0] - f.ap[0]) : -(f.ar[i] - f.ar[i - 1] + (f.inventory[i] - f.inventory[i - 1]) - (f.ap[i] - f.ap[i - 1]));
      const wcTax = i === 0 ? f.totalTax[0] : f.totalTax[i] - f.totalTax[i - 1];
      const wcPrev = i === 0 ? f.debitiPrevidenziali[0] : f.debitiPrevidenziali[i] - f.debitiPrevidenziali[i - 1];
      return wcTrade + wcTax + wcPrev;
    }),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \xB1 Rettifica contributi",
    values: YEARS.map((_, i) => f.grantCashIn[i] - f.grantIncome[i]),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "CF OPERATIVO",
    values: f.cfOperating,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 8
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 di investimento"), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Investimenti",
    values: f.cfInvesting,
    n: n
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      height: 8
    }
  }), /*#__PURE__*/React.createElement("div", {
    style: {
      padding: "4px 0",
      fontSize: 12,
      fontWeight: 700,
      color: "#1e3a5f",
      textTransform: "uppercase"
    }
  }, "Attivit\xE0 di finanziamento"), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Nuovi finanziamenti",
    values: YEARS.map((_, i) => assumptions.debtAmount[i] || 0),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Rimborso debito",
    values: YEARS.map((_, i) => -(f.localRepayment[i] || 0)),
    n: n
  }), (f.capitaleSocialeInflow || 0) > 0 && /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Conferimento capitale sociale",
    values: YEARS.map((_, i) => i === 0 ? f.capitaleSocialeInflow : 0),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  + Apporto equity",
    values: YEARS.map((_, i) => assumptions.equityInjection[i] || 0),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "  \u2212 Dividendi",
    values: f.dividends.map(v => -v),
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "CF FINANZIAMENTO",
    values: f.cfFinancing,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "FLUSSO DI CASSA NETTO",
    values: f.netCF,
    n: n,
    bold: true,
    highlight: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cassa cumulata",
    values: f.cumCash,
    n: n,
    bold: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il Cash Flow mostra se l'azienda genera o brucia cassa. Un CF Operativo negativo per pi\xF9 anni indica che il business non si auto-sostiene. Il CF Finanziamento (debiti + equity) copre il fabbisogno iniziale, ma alla banca interessa che il CF Operativo diventi positivo.")),

  // ‚ïê‚ïê‚ïê V5.1: BILANCIO CIVILISTICO art. 2424/2425 c.c. ‚ïê‚ïê‚ïê
  tab === "civil" && f.ceCivil && /*#__PURE__*/React.createElement("div", {
    style: { display: "flex", flexDirection: "column", gap: 16 }
  },
    // ‚îÄ‚îÄ CE art. 2425 ‚îÄ‚îÄ
    /*#__PURE__*/React.createElement(Card, { title: "Conto Economico ‚Äî art. 2425 c.c.", accent: true },
      /*#__PURE__*/React.createElement(YearHeader, { n: n }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "A) VALORE DELLA PRODUZIONE"),
      /*#__PURE__*/React.createElement(YearRow, { label: "A1) Ricavi vendite e prestazioni", values: f.ceCivil.map(c => c.A1), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "A5) Altri ricavi e proventi", values: f.ceCivil.map(c => c.A5), n: n }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale valore della produzione (A)", values: f.ceCivil.map(c => c.totA), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "B) COSTI DELLA PRODUZIONE"),
      /*#__PURE__*/React.createElement(YearRow, { label: "B6) Materie prime, suss., consumo, merci", values: f.ceCivil.map(c => c.B6), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "B7) Per servizi", values: f.ceCivil.map(c => c.B7), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "B8) Per godimento beni di terzi", values: f.ceCivil.map(c => c.B8), n: n }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 12px", fontSize: 11, fontWeight: 600, color: "#374151" } }, "B9) Per il personale"),
      /*#__PURE__*/React.createElement(YearRow, { label: "    a) Salari e stipendi", values: f.ceCivil.map(c => c.B9a), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "    b) Oneri sociali", values: f.ceCivil.map(c => c.B9b), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "    c) Trattamento fine rapporto", values: f.ceCivil.map(c => c.B9c), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "    e) Altri costi del personale", values: f.ceCivil.map(c => c.B9e), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale costi personale (B9)", values: f.ceCivil.map(c => c.totB9), n: n, bold: true }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 12px", fontSize: 11, fontWeight: 600, color: "#374151" } }, "B10) Ammortamenti e svalutazioni"),
      /*#__PURE__*/React.createElement(YearRow, { label: "    b) Amm.to immob. materiali", values: f.ceCivil.map(c => c.B10b), n: n }),
      f.ceCivil.some(c => c.B10d > 0) && /*#__PURE__*/React.createElement(YearRow, { label: "    d) Sval. crediti attivo circ.", values: f.ceCivil.map(c => c.B10d), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale amm.ti e svalutazioni (B10)", values: f.ceCivil.map(c => c.totB10), n: n, bold: true }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale costi della produzione (B)", values: f.ceCivil.map(c => c.totB), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement(YearRow, { label: "DIFFERENZA A \u2212 B", values: f.ceCivil.map(c => c.diffAB), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "C) PROVENTI E ONERI FINANZIARI"),
      /*#__PURE__*/React.createElement(YearRow, { label: "C17) Interessi e altri oneri finanziari", values: f.ceCivil.map(c => -c.C17), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale proventi e oneri finanziari (C)", values: f.ceCivil.map(c => c.totC), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "Risultato prima delle imposte (A\u2212B\u00B1C)", values: f.ceCivil.map(c => c.risultatoPrimaImposte), n: n, bold: true }),
      /*#__PURE__*/React.createElement(YearRow, { label: "20) Imposte sul reddito (IRES+IRAP)", values: f.ceCivil.map(c => -c.imposte20), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "    di cui IRES", values: f.ceCivil.map(c => -c.ires20), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "    di cui IRAP", values: f.ceCivil.map(c => -c.irap20), n: n }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "21) UTILE (PERDITA) DELL'ESERCIZIO", values: f.ceCivil.map(c => c.utile21), n: n, bold: true, highlight: true }),
      /*#__PURE__*/React.createElement(Note, null, "Schema conforme all'art. 2425 c.c. (forma abbreviata ex art. 2435-bis per PMI). Voci B9 scomposte in salari, oneri sociali, TFR e altri costi. Voce B10d = svalutazione crediti (OIC 15). Le voci con importo zero vengono comunque esposte per completezza formale.")
    ),

    // ‚îÄ‚îÄ SP art. 2424 ‚îÄ‚îÄ
    /*#__PURE__*/React.createElement(Card, { title: "Stato Patrimoniale ‚Äî art. 2424 c.c.", accent: true },
      /*#__PURE__*/React.createElement(YearHeader, { n: n }),

      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 13, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "ATTIVO"),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 12, fontWeight: 700, color: "#374151" } }, "B) Immobilizzazioni"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  II - Immobilizzazioni materiali", values: f.spCivil.map(c => c.BII), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale immobilizzazioni (B)", values: f.spCivil.map(c => c.totB_att), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 12, fontWeight: 700, color: "#374151" } }, "C) Attivo circolante"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  I - Rimanenze", values: f.spCivil.map(c => c.CI), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  II - Crediti (lordi)", values: f.spCivil.map(c => c.CII_lordo), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "       (Fondo sval. crediti)", values: f.spCivil.map(c => -c.CII_fondo), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  II - Crediti (netti)", values: f.spCivil.map(c => c.CII), n: n, bold: true }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  IV - Disponibilit\xE0 liquide", values: f.spCivil.map(c => c.CIV), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale attivo circolante (C)", values: f.spCivil.map(c => c.totC_att), n: n, bold: true }),

      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "TOTALE ATTIVO", values: f.spCivil.map(c => c.totAttivo), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 12 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 13, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "PASSIVO"),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 12, fontWeight: 700, color: "#374151" } }, "A) Patrimonio netto"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  I - Capitale sociale", values: f.spCivil.map(c => c.AI), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  IV - Riserva legale", values: f.spCivil.map(c => c.AIV), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  VI - Altre riserve", values: f.spCivil.map(c => c.AVI), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  VIII - Utili (perdite) a nuovo", values: f.spCivil.map(c => c.AVIII), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  IX - Utile (perdita) esercizio", values: f.spCivil.map(c => c.AIX), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale patrimonio netto (A)", values: f.spCivil.map(c => c.totA_pass), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 12, fontWeight: 700, color: "#374151" } }, "B) Fondi per rischi e oneri"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale fondi (B)", values: f.spCivil.map(c => c.B_fondi), n: n }),

      /*#__PURE__*/React.createElement(YearRow, { label: "C) Trattamento fine rapporto", values: f.spCivil.map(c => c.C_tfr), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 12, fontWeight: 700, color: "#374151" } }, "D) Debiti"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  D4) Debiti verso banche", values: f.spCivil.map(c => c.D4), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  D7) Debiti verso fornitori", values: f.spCivil.map(c => c.D7), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  D12) Debiti tributari", values: f.spCivil.map(c => c.D12), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  D13) Debiti previdenziali", values: f.spCivil.map(c => c.D13), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Totale debiti (D)", values: f.spCivil.map(c => c.totD), n: n, bold: true }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  di cui esigibili entro es. succ.", values: f.spCivil.map(c => c.D_entro), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  di cui esigibili oltre es. succ.", values: f.spCivil.map(c => c.D_oltre), n: n }),

      /*#__PURE__*/React.createElement(YearRow, { label: "E) Ratei e risconti passivi", values: f.spCivil.map(c => c.E_ratei), n: n }),

      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "TOTALE PASSIVO", values: f.spCivil.map(c => c.totPassivo), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      // Verifica quadratura
      /*#__PURE__*/React.createElement(YearRow, {
        label: "\u2705 Verifica: Attivo \u2212 Passivo",
        values: f.spCivil.map(c => c.totAttivo - c.totPassivo),
        n: n, bold: true
      }),
      /*#__PURE__*/React.createElement(Note, null, "Schema conforme all'art. 2424 c.c. (forma abbreviata ex art. 2435-bis per PMI). Debiti scomposti per natura con separata indicazione entro/oltre l'esercizio successivo (art. 2424, co. 1, lett. D). Patrimonio Netto con 5 componenti (OIC 28). La riga 'Verifica' deve essere sempre zero: Attivo = Passivo + PN.")
    ),

    // ‚îÄ‚îÄ Rendiconto Finanziario OIC 10 (metodo indiretto) ‚îÄ‚îÄ
    f.cfOIC10 && /*#__PURE__*/React.createElement(Card, { title: "Rendiconto Finanziario ‚Äî OIC 10 (metodo indiretto)", accent: true },
      /*#__PURE__*/React.createElement(YearHeader, { n: n }),

      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "A) FLUSSI FINANZIARI ATTIVIT\xC0 OPERATIVA"),
      /*#__PURE__*/React.createElement(YearRow, { label: "Utile (perdita) dell'esercizio", values: f.cfOIC10.map(c => c.utileEsercizio), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Imposte sul reddito", values: f.cfOIC10.map(c => c.imposteReddito), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Interessi passivi", values: f.cfOIC10.map(c => c.interessiPassivi), n: n }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "1. Utile prima imposte, interessi e plus/minus", values: f.cfOIC10.map(c => c.sub1), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 4 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 11, fontWeight: 600, color: "#374151" } }, "Rettifiche per elementi non monetari"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Accantonamento TFR", values: f.cfOIC10.map(c => c.accTFR), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Ammortamenti immobilizzazioni", values: f.cfOIC10.map(c => c.accAmm), n: n }),
      f.cfOIC10.some(c => c.accSval > 0) && /*#__PURE__*/React.createElement(YearRow, { label: "  Svalutazioni crediti", values: f.cfOIC10.map(c => c.accSval), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale rettifiche non monetarie", values: f.cfOIC10.map(c => c.totRettNonMon), n: n, bold: true }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "2. Flusso prima delle variazioni del CCN", values: f.cfOIC10.map(c => c.sub2), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 4 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 11, fontWeight: 600, color: "#374151" } }, "Variazioni del capitale circolante netto"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Decr./(incr.) rimanenze", values: f.cfOIC10.map(c => c.deltaRimanenze), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Decr./(incr.) crediti vs clienti", values: f.cfOIC10.map(c => c.deltaCrediti), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Incr./(decr.) debiti vs fornitori", values: f.cfOIC10.map(c => c.deltaFornitori), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Incr./(decr.) debiti tributari", values: f.cfOIC10.map(c => c.deltaTributari), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Incr./(decr.) debiti previdenziali", values: f.cfOIC10.map(c => c.deltaPrevidenziali), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Incr./(decr.) risconti passivi", values: f.cfOIC10.map(c => c.deltaRiscontiPass), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale variazioni CCN", values: f.cfOIC10.map(c => c.totDeltaCCN), n: n, bold: true }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "3. Flusso dopo le variazioni del CCN", values: f.cfOIC10.map(c => c.sub3), n: n, bold: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 4 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 11, fontWeight: 600, color: "#374151" } }, "Altre rettifiche"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  (Interessi pagati)", values: f.cfOIC10.map(c => c.interessiPagati), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  (Imposte sul reddito pagate)", values: f.cfOIC10.map(c => c.impostePagate), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Totale altre rettifiche", values: f.cfOIC10.map(c => c.totAltreRett), n: n, bold: true }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "Flusso finanziario attivit\xE0 operativa (A)", values: f.cfOIC10.map(c => c.cfOpA), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "B) FLUSSI FINANZIARI ATTIVIT\xC0 DI INVESTIMENTO"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  (Investimenti in immob. materiali)", values: f.cfOIC10.map(c => c.cfInvB), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Flusso finanziario attivit\xE0 di investimento (B)", values: f.cfOIC10.map(c => c.cfInvB), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 8 } }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "4px 0", fontSize: 12, fontWeight: 700, color: "#1e3a5f", textTransform: "uppercase", letterSpacing: ".05em" } }, "C) FLUSSI FINANZIARI ATTIVIT\xC0 DI FINANZIAMENTO"),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 11, fontWeight: 600, color: "#374151" } }, "Mezzi di terzi"),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Accensione finanziamenti", values: f.cfOIC10.map(c => c.nuoviFin), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  (Rimborso finanziamenti)", values: f.cfOIC10.map(c => -c.rimborsoFin), n: n }),
      /*#__PURE__*/React.createElement("div", { style: { padding: "2px 0 2px 0", fontSize: 11, fontWeight: 600, color: "#374151" } }, "Mezzi propri"),
      f.cfOIC10.some(c => c.conferimentoCS > 0) && /*#__PURE__*/React.createElement(YearRow, { label: "  Conferimento capitale sociale", values: f.cfOIC10.map(c => c.conferimentoCS), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "  Apporto equity", values: f.cfOIC10.map(c => c.apportoEquity), n: n }),
      f.cfOIC10.some(c => c.divPagati > 0) && /*#__PURE__*/React.createElement(YearRow, { label: "  (Dividendi pagati)", values: f.cfOIC10.map(c => -c.divPagati), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Flusso finanziario attivit\xE0 di finanziamento (C)", values: f.cfOIC10.map(c => c.cfFinC), n: n, bold: true, highlight: true }),

      /*#__PURE__*/React.createElement("div", { style: { height: 12 } }),
      /*#__PURE__*/React.createElement(Div, null),
      /*#__PURE__*/React.createElement(YearRow, { label: "Incremento (decremento) disponibilit\xE0 liquide (A\u00B1B\u00B1C)", values: f.cfOIC10.map(c => c.deltaLiq), n: n, bold: true, highlight: true }),
      /*#__PURE__*/React.createElement("div", { style: { height: 4 } }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Disponibilit\xE0 liquide inizio esercizio", values: f.cfOIC10.map(c => c.liqInizio), n: n }),
      /*#__PURE__*/React.createElement(YearRow, { label: "Disponibilit\xE0 liquide fine esercizio", values: f.cfOIC10.map(c => c.liqFine), n: n, bold: true }),
      /*#__PURE__*/React.createElement(Note, null, "Schema conforme OIC 10, Appendice A, Schema n.1 (metodo indiretto). Flusso operativo: dall'Utile si risale al flusso di cassa rettificando per elementi non monetari (TFR, ammortamenti, svalutazioni), variazioni del CCN, interessi e imposte effettivamente pagati. Le tre categorie (A+B+C) riconciliano con la variazione di cassa del periodo.")
    )
  ),

  tab === "kpi" && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  }, /*#__PURE__*/React.createElement(Card, {
    title: "Indici di Redditivit\xE0",
    accent: true
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine lordo %",
    values: f.grossMarginPct,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine EBITDA %",
    values: f.ebitdaMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine netto %",
    values: f.netMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROE (Return on Equity)",
    values: f.roe,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROI (Return on Investment)",
    values: f.roi,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ROA (Return on Assets)",
    values: f.roa,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cost-to-Income",
    values: f.costToIncome,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Incidenza personale/ricavi",
    values: f.hrOnRevenue,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crescita ricavi YoY",
    values: f.revenueGrowth,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Crescita EBITDA YoY",
    values: f.ebitdaGrowth,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Il margine lordo dipende dal pricing e dai costi diretti. L'EBITDA margin mostra l'efficienza operativa complessiva. ROE ", ">", " 8% \xE8 buono per una PMI; se il ROE \xE8 N/A, il patrimonio netto \xE8 negativo o in perdita.")), /*#__PURE__*/React.createElement(Card, {
    title: "Indici di Sostenibilit\xE0 Finanziaria (richiesti dalle banche)"
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "DSCR",
    values: f.dscr,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "DSCR Cash-based (EBA)",
    values: f.dscrCash,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "DSCR CADS (conservativo)",
    values: f.dscrCADS,
    n: n,
    dec: 2
  }), f.burnRate.some(function(v){return v > 0;}) && /*#__PURE__*/React.createElement(YearRow, {
    label: "\uD83D\uDD25 Burn Rate (\u20AC/mese)",
    values: f.burnRate,
    n: n
  }), f.runway.some(function(v){return v !== null;}) && /*#__PURE__*/React.createElement(YearRow, {
    label: "\u23F1\uFE0F Runway (mesi)",
    values: f.runway.map(function(v){return v !== null ? Math.round(v) : null;}),
    n: n,
    dec: 0
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "ICR (Interest Coverage)",
    values: f.icr,
    n: n,
    dec: 1
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Current ratio",
    values: f.currentRatio,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Equity Ratio (PN/Attivo)",
    values: f.equityRatio,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debt/Equity",
    values: f.debtEquity,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Debito/EBITDA",
    values: f.debtToEbitda,
    n: n,
    dec: 1
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Cash Debt Coverage",
    values: f.cashDebtCoverage,
    n: n,
    dec: 2
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Rapporto indebitamento",
    values: f.debtRatio,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Note, null, "Tre versioni DSCR: EBITDA-based (semplificata), Cash-based EBA (CF Operativo), e CADS (conservativa: EBITDA \u2212 imposte \u2212 \u0394NWC \u2212 CAPEX). Banche richiedono \u2265 1,2\xD7. Equity Ratio EBA \u2265 20-25%. Debito/EBITDA \u003C 3-4\xD7. Cash Debt Coverage \u003E 0,4\xD7.")), /*#__PURE__*/React.createElement(Card, {
    title: "Analisi Break-Even e Capitale Circolante"
  }, /*#__PURE__*/React.createElement(YearHeader, {
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Costi fissi totali",
    values: f.fixedCosts,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Break-Even Point (\u20AC)",
    values: f.bep,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Margine di sicurezza",
    values: f.bepMargin,
    n: n,
    pct: true
  }), /*#__PURE__*/React.createElement(Div, null), /*#__PURE__*/React.createElement(YearRow, {
    label: "PFN",
    values: f.pfn,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "NWC (Cap. Circolante Netto)",
    values: f.nwc,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Organico",
    values: f.headcount,
    n: n
  }), /*#__PURE__*/React.createElement(YearRow, {
    label: "Ricavo per dipendente",
    values: f.revPerEmp,
    n: n
  }), /*#__PURE__*/React.createElement(Note, null, "Il ", /*#__PURE__*/React.createElement("strong", null, "BEP"), " indica il fatturato minimo per pareggiare. Il ", /*#__PURE__*/React.createElement("strong", null, "margine di sicurezza"), " \xE8 quanto i ricavi superano il BEP: se ", "<", " 10%, basta un piccolo calo delle vendite per andare in perdita. La ", /*#__PURE__*/React.createElement("strong", null, "PFN"), " positiva indica che l'azienda ha pi\xF9 liquidit\xE0 che debiti \u2014 condizione ideale per negoziare con le banche. Il ", /*#__PURE__*/React.createElement("strong", null, "NWC"), " positivo indica che l'attivo corrente copre i debiti a breve."))),
    
    /* -√¢‚Äö¬¨- NEW TABS (at top level, outside KPI div) -√¢‚Äö¬¨- */
    tab === "benchmark" && React.createElement(Card, { title: "\uD83C\uDFAF Confronto con Benchmark di Settore" },
      React.createElement(Tip, { text: "Confronto KPI del piano con i valori mediani del settore selezionato nello step Azienda." }),
      f.benchmarks && f.benchmarks.comparison && React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13 } },
        React.createElement("thead", null,
          React.createElement("tr", null,
            React.createElement("th", { style: { textAlign: "left", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11 } }, "KPI"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, color: "#1e3a5f" } }, "Tuo Piano (ultimo anno)"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f", fontSize: 11, color: "#6b7280" } }, "Mediana Settore"),
            React.createElement("th", { style: { textAlign: "center", padding: "10px 12px", borderBottom: "2px solid #1e3a5f" } }, "")
          )
        ),
        React.createElement("tbody", null,
          f.benchmarks.comparison.map((b, i) => {
            const isGood = b.invert ? (b.actual <= b.benchmark * 1.1) : (b.actual >= b.benchmark * 0.9);
            const isBad = b.invert ? (b.actual > b.benchmark * 1.5) : (b.actual < b.benchmark * 0.5);
            const fVal = b.unit === "pct" ? fmtPct(b.actual) : b.unit === "gg" ? ((b.actual||0) + " gg") : ((b.actual||0).toFixed(1) + "\u00D7");
            const fBen = b.unit === "pct" ? fmtPct(b.benchmark) : b.unit === "gg" ? (b.benchmark + " gg") : (b.benchmark.toFixed(1) + "\u00D7");
            return React.createElement("tr", { key: i, style: { background: i % 2 === 0 ? "#f9fafb" : "#fff" } },
              React.createElement("td", { style: { padding: "10px 12px", fontWeight: 600, color: "#374151" } }, b.kpi),
              React.createElement("td", { style: { textAlign: "center", padding: "10px 12px", fontFamily: "'JetBrains Mono',monospace", fontWeight: 700, color: isGood ? "#059669" : isBad ? "#dc2626" : "#d97706" } }, fVal),
              React.createElement("td", { style: { textAlign: "center", padding: "10px 12px", fontFamily: "'JetBrains Mono',monospace", color: "#6b7280" } }, fBen),
              React.createElement("td", { style: { textAlign: "center", fontSize: 18 } }, isGood ? "\u2705" : isBad ? "\u274C" : "\u26A0\uFE0F")
            );
          })
        )
      ),
      React.createElement(Note, null, "Benchmark indicativi basati su dati aggregati ISTAT/Cerved per il settore selezionato. Possono variare per dimensione e area geografica.")
    ),
    tab === "charts" && React.createElement(ChartsPanel, { financials: f, company }),
    tab === "sensitivity" && React.createElement(SensitivityPanel, { company, revenues, hrs, opexItems, investments, assumptions }),
    tab === "montecarlo" && React.createElement(MonteCarloPanel, { company, revenues, hrs, opexItems, investments, assumptions }),
    tab === "scenarios" && React.createElement(ScenarioComparePanel, { company, revenues, hrs, opexItems, investments, assumptions, savedScenarios: savedScenarios || [], onSaveScenario: onSaveScenario || (() => {}) }),

    tab === "summary" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      React.createElement(Card, { title: "Executive Summary", accent: true },
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 12, marginBottom: 16 } },
          React.createElement("div", { style: { padding: 16, background: "#eff6ff", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "Ricavi " + YL[last]),
            React.createElement("div", { style: { fontSize: 20, fontWeight: 700, color: "#1e40af" } }, fmtEur(f.totalRevenue[last]))
          ),
          React.createElement("div", { style: { padding: 16, background: "#f0fdf4", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "EBITDA Margin"),
            React.createElement("div", { style: { fontSize: 20, fontWeight: 700, color: "#16a34a" } }, (f.ebitdaMargin[last] * 100).toFixed(1) + "%")
          ),
          React.createElement("div", { style: { padding: 16, background: f.netIncome[last] >= 0 ? "#f0fdf4" : "#fef2f2", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "Utile Netto " + YL[last]),
            React.createElement("div", { style: { fontSize: 20, fontWeight: 700, color: f.netIncome[last] >= 0 ? "#16a34a" : "#dc2626" } }, fmtEur(f.netIncome[last]))
          ),
          React.createElement("div", { style: { padding: 16, background: (f.dscr[last] || 0) >= 1.2 ? "#f0fdf4" : "#fef3c7", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "DSCR"),
            React.createElement("div", { style: { fontSize: 20, fontWeight: 700, color: (f.dscr[last] || 0) >= 1.2 ? "#16a34a" : "#d97706" } }, f.dscr[last] !== null ? f.dscr[last].toFixed(2) + "x" : "N/A")
          )
        ),
        f.burnRate[0] > 0 && React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: 12, marginBottom: 16 } },
          React.createElement("div", { style: { padding: 12, background: "#fef2f2", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "\uD83D\uDD25 Burn Rate Anno 1"),
            React.createElement("div", { style: { fontSize: 16, fontWeight: 700, color: "#dc2626" } }, fmtEur(f.burnRate[0]) + "/mese")
          ),
          React.createElement("div", { style: { padding: 12, background: f.runway[0] && f.runway[0] > 12 ? "#f0fdf4" : "#fef3c7", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "\u23F1\uFE0F Runway Anno 1"),
            React.createElement("div", { style: { fontSize: 16, fontWeight: 700, color: f.runway[0] && f.runway[0] > 12 ? "#16a34a" : "#d97706" } }, f.runway[0] ? Math.round(f.runway[0]) + " mesi" : "N/A")
          ),
          React.createElement("div", { style: { padding: 12, background: "#eff6ff", borderRadius: 10, textAlign: "center" } },
            React.createElement("div", { style: { fontSize: 11, color: "#6b7280", marginBottom: 4 } }, "CAGR Ricavi"),
            React.createElement("div", { style: { fontSize: 16, fontWeight: 700, color: "#1e40af" } }, (f.revenueCAGR * 100).toFixed(1) + "%")
          )
        ),
        React.createElement("div", { style: { lineHeight: 1.7, color: "#374151", fontSize: 14 } },
          generateExecutiveSummary(company, f, n, revenues, investments, hrs)
        )
      ),
      React.createElement(Note, null, "Sintesi auto-generata dai dati inseriti. Inclusa nel PDF esportato.")
    ),

    tab === "nota" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      generateNotaIntegrativa(company, f, n, revenues, investments, hrs, opexItems, assumptions).map(function(section, idx) {
        return React.createElement(Card, { key: idx, title: section.title },
          React.createElement("div", { style: { lineHeight: 1.7, color: "#374151", fontSize: 14 } }, section.text)
        );
      }),
      React.createElement(Note, null, "Nota Integrativa auto-generata. Verificare e integrare con informazioni qualitative.")
    ),

    tab === "multiScenario" && React.createElement("div", { style: { display: "flex", flexDirection: "column", gap: 16 } },
      React.createElement(Card, { title: "Confronto Scenari", accent: true },
        (savedScenarios && savedScenarios.length > 0) ?
          React.createElement("div", { style: { overflowX: "auto" } },
            React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: 13 } },
              React.createElement("thead", null,
                React.createElement("tr", null,
                  React.createElement("th", { style: { textAlign: "left", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#f9fafb" } }, "KPI"),
                  React.createElement("th", { style: { textAlign: "right", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#eff6ff", fontWeight: 700 } }, "Corrente"),
                  savedScenarios.map(function(sc, si) {
                    return React.createElement("th", { key: si, style: { textAlign: "right", padding: "8px 12px", borderBottom: "2px solid #e5e7eb", background: "#f9fafb" } }, sc.name || "Scenario " + (si + 1));
                  })
                )
              ),
              React.createElement("tbody", null,
                [
                  ["Ricavi " + YL[last], fmtEur(f.totalRevenue[last])],
                  ["EBITDA " + YL[last], fmtEur(f.ebitda[last])],
                  ["EBITDA Margin", (f.ebitdaMargin[last] * 100).toFixed(1) + "%"],
                  ["Utile Netto", fmtEur(f.netIncome[last])],
                  ["DSCR", f.dscr[last] !== null ? f.dscr[last].toFixed(2) + "x" : "N/A"],
                  ["Cassa Cumulata", fmtEur(f.cumCash[last])],
                  ["PFN", fmtEur(f.pfn[last])],
                  ["Organico", String(f.headcount[last])]
                ].map(function(row, ri) {
                  return React.createElement("tr", { key: ri, style: { background: ri % 2 === 0 ? "#fff" : "#f9fafb" } },
                    React.createElement("td", { style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", fontWeight: 600, fontSize: 12 } }, row[0]),
                    React.createElement("td", { style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", textAlign: "right", fontWeight: 700, color: "#1e40af", fontSize: 12 } }, row[1]),
                    savedScenarios.map(function(sc, si) {
                      var scFin = computeFinancials(sc.company || company, sc.revenues || revenues, sc.hrs || hrs, sc.opexItems || opexItems, sc.investments || investments, sc.assumptions || assumptions);
                      var vals = [fmtEur(scFin.totalRevenue[last]), fmtEur(scFin.ebitda[last]), (scFin.ebitdaMargin[last] * 100).toFixed(1) + "%", fmtEur(scFin.netIncome[last]), scFin.dscr[last] !== null ? scFin.dscr[last].toFixed(2) + "x" : "N/A", fmtEur(scFin.cumCash[last]), fmtEur(scFin.pfn[last]), String(scFin.headcount[last])];
                      return React.createElement("td", { key: si, style: { padding: "8px 12px", borderBottom: "1px solid #f3f4f6", textAlign: "right", fontSize: 12 } }, vals[ri]);
                    })
                  );
                })
              )
            )
          ) :
          React.createElement("div", { style: { textAlign: "center", padding: 40, color: "#9ca3af" } },
            React.createElement("div", { style: { fontSize: 40, marginBottom: 12 } }, "\u2696\uFE0F"),
            React.createElement("div", { style: { fontSize: 14 } }, "Nessuno scenario salvato."),
            React.createElement("div", { style: { fontSize: 12, marginTop: 8 } }, 'Vai alla tab "Scenari" per salvare configurazioni e confrontarle qui.')
          )
      )
    )

    );
}

/* ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê=
   MAIN APP
   ==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê==√Ç¬ê= */
function App() {
  const [step, setStep] = useState(0);
  const [lang, setLang] = useState("it");
  const [showOnboard, setShowOnboard] = useState(!localStorage.getItem("pe_onboard_done"));
  const t = I18N[lang] || I18N.it;
  const [company, setCompany] = useState(DEFAULTS.company);
  const [revenues, setRevenues] = useState([DEFAULTS.revenueLine()]);
  const [hrs, setHrs] = useState([DEFAULTS.hr()]);
  const [opexItems, setOpexItems] = useState([DEFAULTS.opex()]);
  const [investments, setInvestments] = useState([DEFAULTS.investment()]);
  const [assumptions, setAssumptions] = useState(DEFAULTS.assumptions);
  const [savedScenarios, setSavedScenarios] = useState([]);
  const fileRef = useRef(null);
  updateYL(company);
  const financials = useMemo(() => computeFinancials(company, revenues, hrs, opexItems, investments, assumptions), [company, revenues, hrs, opexItems, investments, assumptions]);
  const exportJSON = () => {
    const data = {
      version: "1.0",
      type: "piano-economico",
      company,
      revenues,
      hrs,
      opexItems,
      investments,
      assumptions,
      generatedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json"
    });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `piano-economico-${sanitizeName(company.name)}.json`;
    a.click();
  };
  const importJSON = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.company) setCompany({
          ...DEFAULTS.company,
          ...data.company
        });
        if (data.revenues) setRevenues(data.revenues.map(r => ({
          ...r,
          // V5.2: Sanitize percentages > 1 (user may enter 65 instead of 0.65)
          grossMargin: r.grossMargin > 1 ? r.grossMargin / 100 : r.grossMargin
        })));
        if (data.hrs) setHrs(data.hrs);
        if (data.opexItems) setOpexItems(data.opexItems.map(o => ({
          ...o,
          // V5.2: Sanitize percentOfRevenue (4 ‚Üí 0.04, user may enter % not decimal)
          percentOfRevenue: o.isPercentOfRevenue && o.percentOfRevenue > 1 ? o.percentOfRevenue / 100 : (o.percentOfRevenue || 0)
        })));
        if (data.investments) setInvestments(data.investments);
        if (data.assumptions) {
          const merged = {
            ...DEFAULTS.assumptions,
            ...data.assumptions
          };
          // Deep merge nested objects
          if (data.assumptions.scenarioMultiplier) merged.scenarioMultiplier = {
            ...DEFAULTS.assumptions.scenarioMultiplier,
            ...data.assumptions.scenarioMultiplier
          };
          // Ensure arrays have correct length
          ["debtAmount", "debtRepayment", "equityInjection"].forEach(k => {
            if (!Array.isArray(merged[k]) || merged[k].length < 5) merged[k] = [...(merged[k] || []), ...[0, 0, 0, 0, 0]].slice(0, 5);
          });
          setAssumptions(merged);
        }
        alert("‚úÖ Piano importato correttamente!");
      } catch (err) {
        alert("‚ùå Errore: file non valido. Usa un file .json generato da questa app.");
      }
    };
    reader.readAsText(file);
    e.target.value = "";
  };
  return /*#__PURE__*/React.createElement("div", {
    style: {
      minHeight: "100vh"
    }
  }, showOnboard && React.createElement("div", { className: "v4-onboard-overlay" },
    React.createElement("div", { className: "v4-onboard-card" },
      React.createElement("div", { style: { fontSize: 48, marginBottom: 16 } }, "\uD83D\uDCCA"),
      React.createElement("h2", null, t.onboardTitle),
      React.createElement("p", null, t.onboardDesc),
      React.createElement("button", { className: "v4-onboard-btn", onClick: function() { setShowOnboard(false); try { localStorage.setItem("pe_onboard_done", "1"); } catch(e){} } }, t.onboardBtn)
    )
  ), /*#__PURE__*/React.createElement("header", {
    style: {
      background: "linear-gradient(135deg,#0f2440 0%,#1e3a5f 50%,#1a365d 100%)",
      padding: "16px 32px",
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      borderBottom: "3px solid #d4af37"
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h1", {
    style: {
      margin: 0,
      fontSize: 22,
      fontFamily: "'Playfair Display',serif",
      fontWeight: 900,
      color: "#fff"
    }
  }, "Piano Economico"), /*#__PURE__*/React.createElement("p", {
    style: {
      margin: "2px 0 0",
      fontSize: 12,
      color: "#94a3b8",
      fontWeight: 500
    }
  }, company.name || "Nuova Azienda", company.scenario !== "base" && /*#__PURE__*/React.createElement(Badge, {
    color: "#d4af37"
  }, company.scenario === "pessimistic" ? "Pessimistico" : "Ottimistico"))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8,
      flexWrap: "wrap"
    }
  }, /*#__PURE__*/React.createElement("input", {
    ref: fileRef,
    type: "file",
    accept: ".json",
    onChange: importJSON,
    style: {
      display: "none"
    }
  }), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => fileRef.current.click()
  }, t.importJsonFull), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: exportJSON
  }, t.exportJsonFull), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, t.exportExcelFull), /*#__PURE__*/React.createElement(Btn, {
    small: true,
    onClick: () => exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, t.exportPdfFull), /*#__PURE__*/React.createElement("button", {
    onClick: function() { setLang(lang === "it" ? "en" : "it"); },
    style: { padding: "6px 14px", borderRadius: 8, border: "1px solid rgba(255,255,255,0.3)", background: "rgba(255,255,255,0.1)", color: "#fff", cursor: "pointer", fontSize: 13, fontWeight: 600, marginLeft: 8 }
  }, lang === "it" ? "\uD83C\uDDEC\uD83C\uDDE7 EN" : "\uD83C\uDDEE\uD83C\uDDF9 IT"))), React.createElement("div", { className: "v4-progress" }, React.createElement("div", { className: "v4-progress-bar", style: { width: ((step + 1) / 8 * 100) + "%" } })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      maxWidth: 1200,
      margin: "0 auto",
      padding: "0 16px",
      gap: 24
    }
  }, /*#__PURE__*/React.createElement("nav", {
    style: {
      width: 200,
      flexShrink: 0,
      paddingTop: 24,
      position: "sticky",
      top: 0,
      height: "fit-content"
    }
  }, getSteps(lang).map(s => {
    const vld = s.id < 7 ? getStepValidation(s.id, company, revenues, hrs, opexItems, investments) : "ok";
    const dotCol = vld === "ok" ? "#059669" : vld === "partial" ? "#d97706" : "#d1d5db";
    return React.createElement("button", {
    key: s.id,
    onClick: () => setStep(s.id),
    style: {
      display: "flex", alignItems: "center", gap: 10, width: "100%",
      padding: "12px 16px", border: "none", borderRadius: 10, marginBottom: 4,
      background: step === s.id ? "#fff" : "transparent",
      boxShadow: step === s.id ? "0 2px 8px rgba(0,0,0,.06)" : "none",
      cursor: "pointer", textAlign: "left", transition: "all .2s"
    }
  }, React.createElement("span", { style: { fontSize: 18 } }, s.icon),
  React.createElement("div", { style: { flex: 1 } },
    React.createElement("div", { style: { fontSize: 13, fontWeight: step === s.id ? 700 : 500, color: step === s.id ? "#1e3a5f" : "#6b7280" } }, s.label),
    React.createElement("div", { style: { fontSize: 10, color: "#9ca3af", marginTop: 1 } }, s.id + 1, "/", 8)
  ),
  React.createElement("div", { style: { width: 8, height: 8, borderRadius: "50%", background: dotCol, flexShrink: 0 } })
  ); }), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 16,
      padding: 14,
      background: "#fff",
      borderRadius: 12,
      border: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: 10,
      color: "#6b7280",
      fontWeight: 600,
      textTransform: "uppercase",
      marginBottom: 8,
      letterSpacing: ".05em"
    }
  }, t.anteprimaAnno1), [[t.ricavi, financials.totalRevenue[0]], ["EBITDA", financials.ebitda[0]], [t.utile, financials.netIncome[0]], [t.cassa, financials.cumCash[0]]].map(([l, v]) => /*#__PURE__*/React.createElement("div", {
    key: l,
    style: {
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12,
      marginBottom: 4
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, l), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 600,
      color: v >= 0 ? "#059669" : "#dc2626"
    }
  }, fmt(v)))), financials.dscr[0] != null && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 8,
      paddingTop: 8,
      borderTop: "1px solid #f3f4f6",
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, "DSCR"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 700,
      color: financials.dscr[0] >= 1.2 ? "#059669" : financials.dscr[0] >= 1 ? "#d97706" : "#dc2626"
    }
  }, fmt(financials.dscr[0], 2), "\xD7")), financials.bepMargin[0] != null && /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      fontSize: 12,
      marginTop: 2
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      color: "#6b7280"
    }
  }, "vs BEP"), /*#__PURE__*/React.createElement("span", {
    style: {
      fontFamily: "'JetBrains Mono',monospace",
      fontWeight: 600,
      color: financials.bepMargin[0] >= 0.1 ? "#059669" : financials.bepMargin[0] >= 0 ? "#d97706" : "#dc2626"
    }
  }, fmtPct(financials.bepMargin[0])))), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 12,
      padding: 14,
      background: "#f0f9ff",
      borderRadius: 12,
      border: "1px solid #bae6fd",
      fontSize: 11,
      color: "#0369a1",
      lineHeight: 1.5
    }
  }, /*#__PURE__*/React.createElement("strong", null, "Esporta come:"), /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCD7 Excel \u2014 foglio modificabile", /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCD5 PDF \u2014 report stampabile", /*#__PURE__*/React.createElement("br", null), "\uD83D\uDCBE JSON \u2014 ricarica qui")), /*#__PURE__*/React.createElement("main", {
    style: {
      flex: 1,
      paddingTop: 24,
      paddingBottom: 80,
      minWidth: 0
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "step-enter",
    key: "step-" + step
  }, React.createElement(SoftWarnings, { warnings: getSoftWarnings(step, company, revenues, hrs, investments, assumptions, lang) }), step === 0 && /*#__PURE__*/React.createElement(StepCompany, {
    company: company,
    setCompany: setCompany,
    setRevenues: setRevenues,
    setHrs: setHrs,
    setOpexItems: setOpexItems,
    setInvestments: setInvestments,
    setAssumptions: setAssumptions
  }), step === 1 && /*#__PURE__*/React.createElement(StepRevenue, {
    revenues: revenues,
    setRevenues: setRevenues,
    company: company
  }), step === 2 && /*#__PURE__*/React.createElement(StepProduction, {
    revenues: revenues,
    investments: investments,
    company: company
  }), step === 3 && /*#__PURE__*/React.createElement(StepHR, {
    hrs: hrs,
    setHrs: setHrs,
    company: company
  }), step === 4 && /*#__PURE__*/React.createElement(StepOpEx, {
    opexItems: opexItems,
    setOpexItems: setOpexItems,
    company: company
  }), step === 5 && /*#__PURE__*/React.createElement(StepInvestments, {
    investments: investments,
    setInvestments: setInvestments,
    company: company
  }), step === 6 && /*#__PURE__*/React.createElement(StepAssumptions, {
    assumptions: assumptions,
    setAssumptions: setAssumptions,
    company: company
  }), step === 7 && /*#__PURE__*/React.createElement(StepResults, {
    financials: financials,
    company: company,
    assumptions: assumptions,
    revenues: revenues,
    hrs: hrs,
    opexItems: opexItems,
    investments: investments,
    savedScenarios: savedScenarios,
    onSaveScenario: (s) => setSavedScenarios(prev => [...prev, s]),
    lang: lang
  })), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      marginTop: 32,
      paddingTop: 20,
      borderTop: "1px solid #e5e7eb"
    }
  }, /*#__PURE__*/React.createElement(Btn, {
    onClick: () => setStep(Math.max(0, step - 1)),
    disabled: step === 0
  }, lang === "en" ? "\u2190 Back" : "\u2190 Indietro"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: 8
    }
  }, step === 7 && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Btn, {
    onClick: () => exportExcel(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD7 Excel"), /*#__PURE__*/React.createElement(Btn, {
    onClick: () => exportPDF(company, financials, revenues, hrs, opexItems, investments, assumptions)
  }, "\uD83D\uDCD5 PDF")), step < STEPS.length - 1 ? /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: () => {
      if (step === 6) {
        var warns = [];
        if (revenues.every(function(r) { return r.volumes.every(function(v) { return v === 0; }); })) warns.push(t.warnVolumi);
        if (hrs.every(function(h) { return h.count.every(function(c) { return c === 0; }); })) warns.push(t.warnPersonale);
        if (investments.length === 0 || investments.every(function(inv) { return inv.cost === 0; })) warns.push(t.warnInvestimenti);
        if (warns.length > 0 && !window.confirm("\u26A0\uFE0F " + t.datiIncompleti + ":\n\u2022 " + warns.join("\n\u2022 ") + "\n\n" + t.warnProcedere)) return;
      }
      setStep(step + 1);
    }
  }, lang === "en" ? "Next \u2192" : "Avanti \u2192") : /*#__PURE__*/React.createElement(Btn, {
    primary: true,
    onClick: exportJSON
  }, t.salvaPiano))))));
}
ReactDOM.render(/*#__PURE__*/React.createElement(App, null), document.getElementById("root"));
</script>
</body>
</html>
